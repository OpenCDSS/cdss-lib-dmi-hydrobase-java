// ----------------------------------------------------------------------------
// HydroBaseDMI.java - base class for all HydroBase operations
// ----------------------------------------------------------------------------
// Copyright:   See the COPYRIGHT file
// ----------------------------------------------------------------------------
// Notes:
// (1) This class must override determineDatabaseVersion() and readGlobalData()
// in DMI.java
// ----------------------------------------------------------------------------
// History:
// 2002-09-19	J. Thomas Sapienza, RTi	Initial version from HydroBase_DMI.
// 2002-09-23	JTS, RTi		Updated readCUGeolocsForWDIDs.
// 2002-09-30	JTS, RTi		Code to handle reading CUCrop info
//					was finalized.
// 2002-10-04	JTS, RTi		Query to read BlaneyCriddle methods
//					added.
// 2002-10-14	Steven A. Malers, RTi	Update to handle more true HydroBase
//					design.  In particular:
//					* Defined VERSION_* contants consistent
//					  with previous HydroBase versions.
//					  The secondary dates on versions need
//                                        to be researched but for now set to
//					  the same as the first version number.
//					* Add getProperties() to return a Vector
//					  of String that can be displayed in,
//					  for example, a ReportJFrame.
//					* Remove test main program - should not
//					  carry around the code in the general
//					  package.
//					* Move the utility methods for handling
//					  water district id parsing/forming to
//					  the HydroBaseWaterDistrict class.
//					* Add getDatabaseProperties().
//					* Add support for db_version table.
//					* Change conventions to match those
//					  of RTi.DMI and RTi.DMI.RiversideDB_DMI
//					  so that code is easier to maintain.
//					* Add readStructureGeolocList().
//					* As queries are tested, add trim() for
//					  all string data before setting in data
//					  objects.
// 2002-11-08	SAM, RTi		Make further changes:
//					* changed
//					  HydroBase_WaterDistrict.parseWDID to
//					  return an int[] so adjust as needed.
//					* Remove readCUGeoloc* since this
//					  processing should be handled in
//					  StateDMI using more fundamental
//					  queries.
//					* Implement code in readGlobalData() and
//					  add getCountyRef(), getHUC() to return
//					  global data.
// 2002-11-11	SAM, RTi		Adjust structure query for WDIDs because
//					Access craps on long statements.  Just
//					recursively call the same read method
//					to simplify the logic.
// 2002-11-25	SAM, RTi		Add support for queries of:
//					* cu_method
//					* cropchar
//					* cu_blaney_criddle
// 2003-01-05	SAM, RTi		Update based on changes to the DMI
//					package.  In particular, change the
//					constructors.
// 2003-02-05	JTS, RTi		Added code to handle new tables:
//					agstats, area_cap, cu_clim_wts, cu_coeff
// 2003-02-06	JTS, RTi		Added code to handle new tables:
//					cu_mod_hargreaves, cu_penman_monteith,
//					cu_structure, calls, call_chronology,
//					contact, courtcase, irrig_acre,
//					irrig_time_series, dam, emergency_plan,
//					dam_inspection, dam_outlet,
//					dam_spillway
// 2003-02-07	JTS, RTi		Added code for new tables:
//					Diversion_comment, drillers_k_sum
// 2003-02-10	JTS, RTi		Added code for new tables:
//					Geoloc, Equipment, general_comment, 
//					irrig_acre (query), irrig_structure,
//					legacy_stream, loc_type, map_file,
//					meas_type, mf_reach, person_details
//					pump_test, rt_meas, res_eom, res_meas,
//					reservoir
// 2003-02-11	JTS, RTi		Added code for new tables:
//					rolodex, small_dam, frost_dates,
//					stationGeolocMeasType,
//					stationGeoloc, station, station_rem,
//					snow_crse, stream, struct_meas_type,
//					structure_aka, irrig_summary,
//					structurelocation, sync_preferences,
//					special_data
// 2003-02-12	JTS, RTi		Added code for new tables:
//					template_format, special_data/wis
//					user_preferences, user_security,
//					user_template, wd_water, wd_water_aka,
//					sheet_name, wis_comments, wis_data,
//					wis_format, wis_formula, wis_import,
//					water_district, waterrightirrigsummary,
// 2003-02-13	JTS, RTi		- Added code for new tables:
//					  net_amts, transact, wells, 
//					  well_to_layer, well_to_parcel,
//					  well_to_structure, well_application,
//					  well_application/geoloc, well_meas
//					- Check query code to make sure it
//					  is consistent with the HBDMI code
//					  from which it was ported
// 2003-02-14	JTS, RTi		- Check query code to make sure it
//					  is consistent with the HBDMI code
//					  from which it was ported.
//					- Added code for headgate table.
// 2003-02-17	JTS, RTi		- Check query code to make sure it 
//					  is consistent with the HBDMI code
//					  from which it was ported.
// 					- Added code for annual_amt,
//					  use, irr_type_ref, irr_status_ref,
//					  crop_ref, basin, month_ref, tab_trib,
//					  infrequent_wc, unpermitted_wells,
//					  geophlogs, logtypes, volcanics tables.
//					  Also for the daily_* queries.
// 2003-02-18	JTS, RTi		- Added code for daily_pcpn, 
//					  monthly_pcpn,	monthly_temp, 
//					  monthly_evap, monthly_snow, 
//					  monthly_flow,	monthly_nflow, 
//					  annual_wc, daily_amt,	daily_wc, 
//					  structure/geoloc/strucmeastype
//					- Fixed SQL errors in various queries
// 2003-02-19	JTS, RTi		- Fixed SQL errors in various queries
//					- Added versioning methods from HBDMI
//					  and began adding versioning support
//					  to individual queries.
//					- Listed names of all tables involved
//					  in a query in the read...() method's
//					  javadoc.
// 2003-02-20	JTS, RTi		- Finished adding versioning support
//					  to individual queries.
//					- Adapted many queries for use in 
//					  the structure summary report.
// 2003-02-21	JTS, RTi		- Corrected errors in misc queries.
// 2003-02-22	SAM, RTi		* Add
//			  readCUClimWtsStationGeolocListForCountyAndHydrounit
//					  and remove CUClimateWeights code.
//					* Add CUClimWtsStationGeoloc for joined
//					  data and related code.
// 2003-02-24	JTS, RTi		* Renamed all *Geoloc* objects to 
//					  *Geoloc*
//					* Many more revisions, code cleaning.
// 2003-02-25	JTS, RTi		* Moved a number of methods in from
//					  HBDMIUtil.  
//					* Cleaned up miscellaneous RE VISIT 
//					  statements.
// 2003-02-26	JTS, RTi		* Modified the readNetAmtsList() query
//					  for Water Right reports.
//					* Added str_type query.
// 2003-02-27	JTS, RTi		* Added code for irrig_summary_ts table.
// 2003-03-05	JTS, RTi		* Added code for county table lookup.
//					* Moved a lot of code related to lookup
//					  tables in here from HydroBase_GUI_Main
// 2003-03-12	JTS, RTi		* Added code for writing a user 
//					  preference to the database. 
//					* Added table-specific code in here
//					  from out of the HydroBase_GUI screens.
// 2003-03-13	JTS, RTi		* Moved in code to get the structure
//					  description for a given str type.
//					* Added method to find WD, ID for a 
//					  given structure num
// 2003-03-25	JTS, RTi		Added the user preference reading,
//					setting and saving code.
// 2003-03-26	JTS, RTi		* Removed use of StringTokenizer from 
//					  methods moved in here.
//					* Updated the getDatabaseProperties to
//					  return water district information.
// 2003-03-27	JTS, RTi		* Corrected logic problems in saving
//					  user preferences.
//					* Eliminated duplicate options in 
//					  sort fields.
// 2003-03-31	JTS, RTi		* Added the __userSecurityPermissions
//					  code.
// 2003-04-01	JTS, RTi		* Added the readWISStructures query.
// 2003-04-01				* Added the getMax..., getMin... and 
//					  getExtreme... methods.
//					* Added the 
//					  readWDWaterNoStructureJoinList query.
// 2003-04-02	JTS, RTi		Corrected all the getDate()s that should
//					have been getTimestamp()s.
// 2003-04-03	JTS, RTi		* Added a lot of variables to the 
//					  finalize() method.
//					* Did a lot of alphebetization.
//					* Removed some very old and unused 
//					  methods; moved others to other files.
//					* Went over all the javadocs for 
//					  accuracy.  
//					* Marked methods that are not used in
//					  DWR.DMI.HydroBaseDMI package.
//					* Marked which other classes and methods
//					  call the various readXXX() methods.
// 2003-04-14	JTS, RTi		Split buildSQL into the multiple
//					buildSQL version to get around a
//					constraint of class files that limits
//					the number of byte operations.
// 2003-05-20	JTS, RTi		Added code for the well application gui.
// 2003-05-28	JTS, RTi		* Added code for the ground water gui
//					* Cleaned up some older code
// 2003-08-06	JTS, RTi		Added SQL for all the queries to the 
//					javadocs.
// 2003-09-23	JTS, RTi		* Corrected bug in getDatabaseProperties
//					  that was resulting in invalid water
//					  districts being returned.
// 2003-09-24	JTS, RTi		* Added readStructureForStructure_num().
//					* Added 
//				       readIrrigStructureListForStructure_num().
//					* Added
//				     readIrrigTimeSeriesListForIrrig_acre_num().
// 					* Added
//				     readIrrigTimeSeriesYearForIrrig_acre_num().
//					* Added
//				     readIrrigTimeSeriesYearsForStructure_num().
// 2003-09-25	JTS, RTi		Added 
//				       readStructMeasTypeListForStructure_num().
// 2003-09-26	JTS, RTi		Added 
//					readStructureListForStructure_num().
// 2003-10-01	JTS, RTi		* Added getLocationTypeDescription().
// 2003-10-02	JTS, RTi		* Added 
//				       readRolodexForRolodex_numStructure_num().
//					* Added readContactListForRolodex_num().
//					* Added
//				       readReservoirStructureForStructure_num().
//					* Added
//			      readStructMeasTypeListForStructure_numMeas_type().
// 2003-10-03	JTS, RTi		* Added
//					readSmallDamStructureForStructure_num().
//					* Added
// 					  readDamForStructure_num().
// 2003-10-06	JTS, RTi		* Added
//					readEmergencyPlanListForStructure_num().
//					* Added
//					readDamInspectionListForStructure_num().
//					* Added
//					  readDamOutletListForStructure_num().
//					* Added
//					  readDamSpillwayListForStructure_num().
// 2003-10-16	JTS, RTi		* Added readWis_daily_wc().
//					* Added readSheetNameListForWis_num().
//					* Added readWis_formatListForWis_num().
//					* Added 
//					  readWis_dataListForWis_numSet_date().
//					* Added
//				       readWis_commentsListForWis_numSet_date().
//					* Added
//					  readWis_formulaListForWis_num().
//					* Added
//					  readWis_importListForWis_num().
// 2003-10-17	JTS, RTi		* Added 
//					  deleteWis_dataForWis_numSet_date().
//					* Added
//					 deleteWis_commentsForWis_numSet_date().
//					* Added writeWis_comments().
// 					* Added
// 		    deleteWis_daily_wcForWis_numWis_columnWdIdCal_yearCal_mon().
//					* Added readStructureForWDID().
// 2003-11-19	JTS, RTi		* Renamed all the readWISXXX*() methods
//					  to readWis_xxx*().
//					* Added:
//					  deleteWis_formatForWis_num()
//					  deleteWis_importForWis_num()
//					  deleteWis_formulaForWis_num()
//					  writeWis_format()
//					  writeWis_formula()
//					  writeWis_import()
//					  readStreamListForWDStr_trib_to()
//					  writeSheet_name()
//					  deleteWis_dataForWis_num()
//					  deleteWis_commentsForWis_num()
//			   updateSheet_nameGain_methodEffective_dateForWis_num()
// 2003-11-28	JTS, RTi		Added readSheetNameListForSheet_type().
// 2003-11-30	SAM, RTi		* Add readTimeSeries() for use by TSTool
//					  and StateView/CWRAT.
//					* Rename readMonthlyData() to
//					  readMonthlyStationData().
//					* readTimeSeries() is public but make
//					  helper methods like
//					  readMonthlyStationData() private.
//					* Remove readMonthlyPCPN, etc. since
//					  readMonthlyStationData() does all the
//					  work and its documentation tells what
//					  to do.
//					* In read methods for MeasType,
//					  StationGeolocMeasType, or
//					  StructureGeolocStructMeasType, allow
//					  missing/null input to be ignored when
//					  adding the where clauses.
//					* The division was not getting queried
//					  for StationGeooocMeasType - add it to
//					  the query.
//					* Add readDailyStationData() and remove
//					  individual methods since the one
//					  method can do all the work.
//					* Streamline toDailyTSList().
//					* Update readRTMeasList() to take
//					  required parameters.
//					* Change
//					  readStationGeolocMeasTypeFor
//					  Meas_typeTime_step () to
//					  readStationGeolocMeasTypeList
//					  ForMeas_typeTime_step () since it
//					  returns a Vector.
//					* Add
//					  readStructureGeolocStructMeasTypeFor
//					  Meas_typeTime_step () - for use by
//					  TSTool.
//					* Add readStructureGeolocForWDID().
// 2003-12-03	JTS, RTi		Corrected bug in 
//					readSheetNameDistinctList that was 
//					causing all records to be read.
// 2003-12-08	SAM, RTi		* Add readResMeasList() with period.
// 					* Add period to
//					  readResMeasListForStructure_num().
// 					* Add period to
//					  readAnnualAmtList().
//					* Add support for HydroBase_AnnualRes.
//					* Don't join diversion_comment with
//					  structure when doing a query.
// 2003-12-17	SAM, RTi		* Add methods to read Agstats for
//					  distinct county/type and also read all
//					  records for a county/type - rearrange
//					  the select to facilitate data
//					  processing.
//					* Add
//					  readIrrigSummaryTSStructureList(
//					  distinct).
//					* Change readIrrigSummaryTSStructureList
//					  ForWDIDAndPeriod () to
//					  readIrrigSummaryTSStructureListForWDID
//					  ListLand_usePeriod () for greater
//					  flexibility.
// 2004-01-02	SAM, RTi		* Update readStationGeolocMeasTypeList
//					  ForMeas_typeTime_StepVax_field
//					  Data_source() to also take a list of
//					  where clauses, for use with the new
//					  InputFilter_JPanel.
//					* Similar for readStructureGeolocStruct
//					  MeasTypeListForMeas_typeTime_step ().
// 2004-01-07	JTS, RTi		Corrected where clause construction 
//					in:
//					  - getGroundWaterWhereClause().
//					  - getStructureWhereClause().
// 2004-01-14	SAM, RTi		* Change readTimeSeries for historical
//					  well levels to take a USGS, USBR, or
//					  WDID.
//					* Add getLatestVersionString() to
//					  support getVersionComments(), similar
//					  to legacy HBDMI code.
// 2004-01-26	SAM, RTi		* Remove structure table from diversion
//					  comments query statement in buildSQL()
//					  and let the one read method add the
//					  table itself.
// 2004-01-28	SAM, RTi		* Change "Available period" to
//					  "HydroBase available period" and
//					  "Requested Period" to
//					  "HydroBase query period".
//					* ResEOM and ResEOY time series were
//					  using a meas_type instance instead
//					  of struct_meas_type - fixed.
// 2004-02-07	SAM, RTi		* Add read methods for
//					  agricultural_crop_stats.
//					* Change readTimeSeries() to process the
//					  agricultural_crop_stats time series,
//					  not ag_stats.
//					* Add code to support
//					  readStructureIrrigSummaryTS() - the
//					  old code had base and derived parts
//					  of the table names reversed.
//					* Change STR_TYPE to STRTYPE in several
//					  places in buildSQL().
// 2004-02-18	SAM, RTi		* Fix bug in readTimeSeries() - the
//					  standard comments were clobbering
//					  notes added to comments during
//					  processing.
// 2004-02-20	SAM, RTi		* Change agricultural_crop_stats to
//					  agricultural_CASS_crop_stats.
//					* Add code to read
//					  agricultural_NASS_crop_stats.
//					* Add global data for water divisions -
//					  this can be used in GUI code to
//					  format menus and also input filters.
// 2004-02-23	SAM, RTi		* Add readParcelUseTS().
// 2004-02-26	JTS, RTi		* Added readStructureIrrigSummaryList
//					  ForStructure_num().
// 2004-02-28	SAM, RTi		* Change readStationGeolocList() to
//					  readStationGeolocListForStationIDs().
//					  The former was not used.
//					  Remove "meas_type" from the query
//					  since there is other more appropriate
//					  code to do a join.
// 2004-03-01	SAM, RTi		* Finish adding readParcelUseTS() -
//					  apparently was in the middle of this
//					  but did not finish before.
//					* Also overload to take a list of parcel
//					  identifiiers.
// 2004-03-08	JTS, RTi		Added code to read and write from 
//					the TSProduct and TSProductProps tables.
// 2004-04-12	SAM, RTi		* Reservoir measurements where clause
//					  for query period did not have proper
//					  SQL - fixed.
//					* Similar for well measurements.
// 2004-05-03	JTS, RTi		* Implements TSProductDMI's getDMIName()
//					  and writeTSProduct() methods.
//					* Added 
//					readTSProductPropsListForTSProduct_num()
//					* Added 
//		     readTSProductListForTSProduct_numProductGroup_numUser_num()
//					* Added readTSProductForIdentifier().
//					* Added deleteTSProductForIdentifier().
//					* Added
// 					 deleteTSProductPropsForTSProduct_num().
//					* Added writeTSProductProps().
// 2004-05-12	JTS, RTi		* Added isGuestLoggedIn() to determine 
//					  whether the currently-logged-in user 
//					  is guest.
//					* Added readParcelUseTSStructureToParcel
//					  ListForStructure_num().
// 2004-05-17	JTS, RTi		* Changed
//					 readStructureGeolocStructMeasTypeList()
//					  so that it can pull some data from
//					  the unpermitted_wells table.
//		SAM, RTi		* RelTotal time series data were not
//					  being processed.  Fix.
// 2004-05-19	SAM, RTi		* Enable reading WIS time series in
//					  readTimeSeries().
//					* When reading sheet names, default the
//					  order by to the sheet name.
// 2004-05-21	SAM, RTi		* Add readSheetNameWISFormatList
//					  DistinctSheetNameIdentifier()
// 2004-05-21	JTS, RTi		* Converted improper underscoring in
//					  method names to make them consistent
//					  with other read* and write* methods.
//					* Added readWISNetworkDataForWis_num().
//					* Added deleteWISNetworkDataForWis_num()
//					* Added 
//					  deleteWISNetworkDataForWis_numID().
//					* Added writeWISNetworkData().
// 2004-05-27	JTS, RTi		Structure of the wis_network_data table
//					(now the wis_diagram_data table)
//					changed.
// 2004-06-14	SAM, RTi		* Add readStructureIrrigSummaryForWDID()
//					  to support StateDMI.
// 2004-06-15	SAM, RTi		* Take advantage of the new DMI JOIN
//					  features for the above method.
// 2004-06-22	JTS, RTi		Revised class following review.
//					* GUI-related strings and methods moved 
//					  to HydroBase_GUI_Util.
//					* Other static methods moved to
//					  HydroBase_Util.
//					* getExtremeRecord(), getMinRecord(),
//					  getMaxRecord() moved to DMIUtil.
//					* Updated version number to 20040701.
// 2004-07-07	JTS, RTi		Corrected errors in:
//					* readRolodexForRolodex_num().
//					* readDiversionCommentListFor
//					  Structure_num().
//					* Checked queries with multiple tables
//					  to ensure that they are setting their
//					  linking WHERE statements properly 
//					  from within buildSQL().
// 2004-07-09	JTS, RTi		* readGlobalData() now reads the
//					  ref_ciu lookup table data.
//					* Added lookupCIUDescription().
// 2004-09-06	SAM, RTi		* Add elevation to the HydroBase station
//					  time series comments.
// 2004-09-21	SAM, RTi		* Use new
//					  HydroBase_ParcelUseTSStructureToParcel
//					  class for joined data.
//					* Change readWellsWellToParcelList to
//					  take parameters to limit the query.
//					* Update readParcelUseTSList() to take
//					  the calendar year - this is an open-
//					  ended query so one more parameter
//					  should not make a difference.
// 2004-11-18	JTS, RTi		Database connections are now closed with
//					DMI.closeResultSet().
// 2005-01-10	JTS, RTi		Removed getStationWhereClause().
// 2005-01-13	JTS, RTi		Updated readStrTypeList() to use the
//					new ref_Structure_Type table.
// 2005-01-27	JTS, RTi		* Made query type constants protected.
//					* Added lookupUseDefinitionForUse().
//					* Added lookupUseDefinitionForXUse().
// 2005-02-02	JTS, RTi		* Changed the default login to 'cdss'.
//					* Added new constructors that take an
//					  additional parameter specifying
//					  whether to enable stored procedures.
//					* Corrected small errors related to
//					  stored procedure naming conventions.
//					* User preferences is no longer queried
//					  on both user_num and application,
//					  since user_num is unique in the table.
// 2005-02-03	JTS, RTi		* Moved some queries out of 
//					  readGlobalData() into their own 
//					  methods.
//					* Added setupViewNumbersHashtable()
//					* Added code to do SPFlex queries for
//					  the structure view.
// 2005-02-09	JTS, RTi		* Created open SPFlex queries for 
//					  several existing queries:
//					  - readNetAmtsList()
//					  - readTransactList()
//					  - readPumpTestList()
// 					  - readStationGeolocMeasTypeList()
//				       - readStructureGeolocStructMeasTypeList()
//					  - readWellApplicationGeolocList()
//					  - readStructureGeolocList()
//					* Removed old definitions of old 
//					  stored procedures that have been 
//					  changed out of the code for setting
//					  up stored procedures.
// 2005-02-10	JTS, RTi		* Created open SPFlex queries for:
//					  - readCropcharList()
//					  - readAgriculturalCASSCropStatsList()
//					  - readAgriculturalNASSCropStatsList()
// 2005-02-11	JTS, RTi		* Created open SPFlex queries for:
//					 - readStructureGeolocForStructure_num()
// 2005-02-14	JTS, RTi		* Added toDamSPList().
//					* Added toDamInspectionSPList().
//					* Added toStructureSmallDamSPList().
//					* Added toStructureMFReachSPList().
//					* Added toStreamSPList().
//					* Added toContactSPList().
//					* Removed
//				 readUserPreferencesListForUser_numApplication()
//					* Added toGeolocSPList().
//					* Added toEquipmentSPList().
//					* Added toMapfileSPList().
//					* Added toStructureAKASPList().
//					* Added readCallsListForCall_num().
//					* Added toCallsSPList().
//				       * Added readCallsListForSetReleaseDates()
// 					* Added 
//				     readDailyWCListForStructure_numRecordType()
//					* Added toWISSheetNameSPList().
//					* Added readWISCommentsListForWis_num().
// 2005-02-15	JTS, RTi		* Added toTSProductSPList().
//					* Added 
//				readStructureGeolocListForWDStream_numStr_type()
//					* Added
//				  readSheetNameListForSheet_nameEffective_date()
//					* Added
//					readWISFormatListForWis_numNotRow_type()
//					* Removed code related to the following
//					  tables:
//					  - irrig_acre
//					  - irrig_status
//					  - irrig_structure
//					  - irrig_time_series
//					  - irrig_type
//					  - legacy_stream
//					  - logtypes
//					  - special_data
//					  - sync_preferences
//					  - tab_trib
//					  - template_format
//					  - user_template
//					  - volcanics
//					  - wd_water_aka
//					* Removed SQL from the Javadocs for
//					  the methods.
//					* Cleaned up the list of stored 
//					  procedures, removing those that 
//					  do not exist.
// 2005-02-16	JTS, RTi		* Continued updating queries to support
//					  views and stored procedures.
//					* Renamed sheet_name table to 
//					  wis_sheet_name.
// 2005-02-17	JTS, RTi		* Added toIrrigSummaryNetAmtsSPList().
//					* Added 
//					  toAgriculturalCASSCropStatsSPList()
//					* Added 
//					  toAgriculturalNASSCropStatsSPList()
//					* Continued converting methods to use
//					  views and stored procedures.
//					* Added toAnnualResSPList().
//					* Added toResEOMSPList():
// 2005-02-21	JTS, RTi		* Added toSnowCrseSPList();
//					* Added readStructureIrrigSummaryTSList
//					  that takes a Vector of WDIDs.
//					* A new readNetAmtsList() method was
//					  added that takes a Vector of WDIDs.
//					* readStructureReservoirListForWDIDList
//					  was renamed to 
//					  readStructureReservoirForWDID
//					* Added toCropcharSPList().
//					* Cross-referenced deprecated methods
//					  with TSTool, StateDMI, and StateView
//					  and removed those that were not used
//					  anywhere.
//					* Alphabetized read methods as they
//					  were badly out of order.
//					* Removed all unused toX() methods.
//					* Removed all unused query constants.
// 2005-02-22	JTS, RTi		* Added toStationGeolocCUClimWtsSPList()
//					* Finalized the readWISFormat() methods.
//					* Added deleteWISForWis_numSet_date().
//					* Converted delete methods to use
//					  stored procedures.
//					* Converted write methods to use
//					  stored procedures.
// 2005-02-23	JTS, RTi		* Corrected errors in toNetAmtsSPList()
//					  and toTransactSPList().
//					* Removed getSFUTCombinations().
//					* Renamed readCallsListForCall_num()
//					  to readCallsForCall_num().
//					* Removed readGeolocListForDistinctHUC()
//					  because all the code related to it
//					  has been commented out for over 2 
//					  years.
//					* Cleaned up REVISITs.
//					* getUserDate() moved to 
//					  HydroBase_GUI_Util.
//					* Changed the query variables to 
//					  private because they are not used
//					  outside this class.
//					* Recombined the buildSQL() method into
//					  a single method because whatever 
//					  constraint was being worked around 
//					  before appears to be gone now.
// 2005-02-24	JTS, RTi		Begin work on unit tests, fixing small
//					bugs as they appear.
// 2005-02-28	JTS, RTi		Continue fixing query bus for unit
//					tests.
// 2005-03-01	JTS, RTi		* Daily TS queries changed to match the
//					  columns returned from the views. 
//					  All TS queries other than PCPN had the
//					  daily data flags added to their
// 					  field list.
// 2005-03-04	JTS, RTi			* Finished checked every Stored 
//					  Procedure/View query against the 
//					  old SQL query to make sure they 
//					  return the same values.
//					* Some methods were taking -1 as
//					  a marker to not use an int value and
//					  others were taking -999.  Made them
//					  all use -999.
// 2005-03-07	JTS, RTi		closeResultSet() calls were modified
//					to handle additional closing that needs
//					done when stored procedures are used.
// 2005-03-09	JTS, RTi		* Began testing delete and write
//					  statements.
//					* HydroBase_SheetName ->
//					  HydroBase_WISSheetName.
//					* HydroBase_SheetNameSpecialData ->
//					  HydroBase_WISSheetNameSpecialData.
//					* HydroBase_SheetNameWISFormat ->
//					  HydroBase_WISSheetNameWISFormat.
//					* Overrode dmiSelect(), dmiDelete(),
//					  and dmiWrite() for printing
//					  debugging information.
// 2005-03-10	JTS, RTi		Added 
//					readParcelUseTSDistinctCalYearsList().
// 2005-03-24	JTS, RTi		Corrected null pointer exception 
//					happening in readTimeSeries() because
//					mt.getMeas_num() was being used, when
//					stored procedures weren't setting mt.
// 2005-04-07	JTS, RTi		Corrected error in readTimeSeries() 
//					where meas_nums were not being set 
//					properly for certain non-store procedure
//					time series reads.
// 2005-04-08	JTS, RTi		When constructors are called with null
//					user names and passwords, the default
//					values are determined based on whether
//					the dmi is supposed to use stored 
//					procedures or not.
// 2005-04-11	JTS, RTi		Added updateCallCommentsForCall_num().
// 2005-04-27	JTS, RTi		When checking for the latest database
//					version (20040701) stored procedures 
//					are checked for.
// 2005-05-09	JTS, RTi		* All Pump Test queries now return
//					  pump test view objects (for non-SP
//					  queries).
//					* Station and related queries now
//					  return Station view objects for
//					  non-SP queries.
//					* Well application queries now return
//					  well application view objects for
//					  non-SP queries.
// 2005-05-22	SAM, RTi		* Fix typo in constructor for default
//					  login for old database.
//					* Add stored procedure and input name
//					  information to getVersionComments().
//					* Change readTimeSeries() warnings to
//					  level 3 to be consistent with TSTool
//					  error-handling.
// 2005-05-23	JTS, RTi		readStructureReservoirForWDID() now 
//					returns a HydroBase_StructureReservoir
//					object, not a Vector.
// 2005-06-01	JTS, RTi		Corrected error in query that joins
//					structure to irrig_summary_ts.
// 2005-06-03	JTS, RTi		Added new version (20050501).
// 2005-06-07	JTS, RTi		* Corrected error in 
//					  getLatestVersionString() that was 
//					  preventing version strings from being
//					  pulled out for stored procedure 
//					  connections.
//					* Views have been checked for backwards
//					  compatability with older database
//					  versions.  Corrections were made to
//					  the station and structure views.
// 2005-06-13	JTS, RTi		Began working on the 20050701 version.
//					This versio of the database has support
//					for the new design of the groundwater
//					well data.
// 2005-07-07	JTS, RTi		* Added support for querying All 
//					  Divisions at once.
//					* Added support for querying Division 8.
// 2005-07-11	JTS, RTi		* The net_amts and transacts tables
//					  no longer use their x.... fields.
// 2005-07-13	SAM, RTi		* Add support for IDivTotal, IDivClass,
//					  IRelTotal, IRelClass, time series.
// 2005-10-18	JTS, RTi		* Boosted performance by moving 
//					  lookup Vector reading to when they
//					  are needed first, rather than reading
//					  all in at initialization.
// 2005-10-27	JTS, RTi		Stored Procedure and SQL strings are now
//					also printed at Debug level 30, though
//					for certain security-sensitive 
//					operations this is temporarily disabled.
// 2005-11-10	SAM, RTi		Changed "Station and time series
//					information from HydroBase" to include
//					"determined at time of query" because
//					TSTool changes result in new units, etc.
// 2005-11-15	JTS, RTi		New database version 20051115, which
//					adds 3 fields to the groundwater tables.
// 2005-11-21	JTS, RTi		Added code to read Aquifer data.
// 2005-12-01	SAM, RTi		Fix so that units for temperature time
//					series are set from the data records and
//					not hard-coded.
// 2005-12-14	JTS, RTi		"local" is now recognized as a valid
//					server name in the constructor that 
//					takes a proplist.  In addition, if 
//					local is specified to this constructor
//					it will attempt to try the two known
//					ports (one after the other) in the
//					open() method.
// 2006-04-26	SAM, RTi		Update readTimeSeries() to recognize
//					properties to fill daily diversion time
//					series with carry forward.
// 2006-05-25	JTS, RTi		Cleaned up as many REVISITs as possible.
// 2006-06-28	SAM, RTi		When reading structure time series,
//					throw a NoDataFoundException if a
//					struct_meas_type is not found, so that
//					calling code can handle the exception
//					more explicitly.
// 2006-08-15	SAM, RTi		Change setSecure(true) to
//					setSecure(false) to prevent password
//					information from being printed in debug
//					messages.
// 2006-10-30	SAM, RTi		Add code to read CASS livestock
//					statistics.
//					Add code to read CUPopulation.
// 2007-02-23	SAM, RTi
//					Update to handle HydroBase 20060201 release.
//					Since there is not a DB design version record for
//					this, key off the 20061003 version.
//					In particular, handle SFUT with G: at end and F: that
//					is 7-digit, padded with zeros.
//					Clean up code based on Eclipse feedback.
// 2007-04-16	SAM, RTi		Update to specify optional calendar year when
//					reading parcel_use and structure data.
// 2007-05-02	SAM, RTi		Update to handle HydroBase 20070502 release.
//					Include administrative flows.
//					Add query for usp_Developer_FLEX_codes to help with
//					version checks.
// ----------------------------------------------------------------------------
// EndHeader

package DWR.DMI.HydroBaseDMI;

import java.sql.ResultSet;

import java.util.Date;
import java.util.Hashtable;
import java.util.Vector;

import RTi.DMI.DMI;
import RTi.DMI.DMIDeleteStatement;
import RTi.DMI.DMIUtil;
import RTi.DMI.DMISelectStatement;
import RTi.DMI.DMIWriteStatement;
import RTi.DMI.DMIStatement;
import RTi.DMI.DMIStoredProcedureData;

import RTi.GR.GRLimits;

import RTi.GRTS.TSProduct;
import RTi.GRTS.TSProductAnnotationProvider;
import RTi.GRTS.TSProductDMI;

import RTi.TS.DayTS;
import RTi.TS.HourTS;
import RTi.TS.IrregularTS;
import RTi.TS.MinuteTS;
import RTi.TS.MonthTS;
import RTi.TS.TS;
import RTi.TS.TSIdent;
import RTi.TS.YearTS;

import RTi.Util.GUI.InputFilter_JPanel;
import RTi.Util.GUI.SimpleJComboBox;

import RTi.Util.IO.IOUtil;
import RTi.Util.IO.Prop;
import RTi.Util.IO.PropList;

import RTi.Util.Message.Message;

import RTi.Util.String.StringUtil;

import RTi.Util.Time.DateTime;
import RTi.Util.Time.TimeInterval;
import RTi.Util.Time.TimeUtil;

/**
The HydroBaseDMI provides an interface to the State of Colorado's HydroBase
database.  Most functionality is related to reading information from HydroBase
in order to support StateView/CWRAT, TSTool, StateDMI, and other CDSS software.
However, a few methods are available for writing and deleting data, in
particular for administrative data edits (calls and WIS) in CWRAT.<p>

A database connection is made either by specifying a pre-defined ODBC DSN (used
with Microsoft Access) or by specifying a database server name, in which case
SQL Server is assumed and the database name is assumed to be "HydroBase".  In
either case, a login can be specified using a SelectHydroBaseJDialog instance.
Once logged-in, HydroBaseDMI will determine the HydroBase version and will
read global data (e.g., water district numbers and names) in order to allow
faster lookups from memory.  The user preferences for the user who logged in
are also saved in memory.<P>

<b>SQL Method Naming Conventions</b><p>

Most methods in this class follow the naming conventions described below, with
exceptions being utility or look-up methods that do not actually execute SQL.
In some cases where SQL is not executed, methods are being considered for
transfer to the HydroBase_Util
or HydroBase_GUI_Util classes.
The first word in the method name is one of the following:<br>
<ol>
<li>read</li>
<li>write</li>
<li>delete</li>
<li>count</li>
</ol>

The second part of the method name is the data object being operated on.
If a list is returned, then "List" is included in the method name.
Finally, if a select based on a where clause is used, the method includes the
field for the Where.  Examples are:

<ol>
<li>	readMeasTypeList</li>
<li>	readMeasTypeForMeasType_num</li>
</ol>
<p>

The HydroBaseDMI code has migrated over time and will continue to change.  In
particular, efforts are occurring to use stored procedures to interact with
HydroBase, to allow optimization of code and to encapsulate the design of the
database so that HydroBase design changes can be made without breaking SQL
calls.  In order to support stored procedures, the documentation for this
class indicates both the SQL that is executed and the name of the stored
procedure(s) that execute the SQL.  This is possible only in cases where the
SQL is "statically" defined.  However, many of the HydroBaseDMI methods have
"dynamic" lists of arguments that can be used in WHERE and ORDER BY clauses.
This is required by some user interfaces that allow multiple selections to be
made in various combinations or because various software is calling a method
with a variety of combinations of parameters.  The conversion of these calls
to a static stored procedure representation will take further optimization.

<p>
<b>Notes on versioning:</b><br>
Version changes require changes throughout the code base.  In general, the
HydroBase data objects include data members for the most recent database design,
but place-holders for additional data from older designs may be retained.  New
database and software will ignore old values but the values will be filled in
if a software feature supports backward-compatibility and an old HydroBase
happens to be used.  The following
example tells all the changes that need to be made when a new field is
added to an existing table:<p>
<ul>
<li>in buildSQL(), add the new field to all the select and write statement
sections for the appropriate table.  Do not forget to wrap this new code
with tests for the proper version (DMI.isDatabaseVersionAtLeast())</li>
<li>if, for the table XXXX, a method exists like:<br>
<code>private Vector toXXXXList</code><br>
then add the field to the Vector-filling code in this method</li>
<li>go to the HydroBase_XXXX.java object that represents the table for
which this field was added.  Add the data member for the field, 
get/set statements, and then add the field (with brief information on the
version in which it was added) to the toString()</li>
<li>add the field, and the appropriate version-checking code, to the 
writeXXXX() method</li>
<li>update determineDatabaseVersion()</li>
</ul>
*/
public class HydroBaseDMI 
extends DMI 
implements TSProductAnnotationProvider, TSProductDMI {

/**
HydroBase release dates.  The value of each integer is the design version,
followed by the release date.
These values must be hanled in determineDatabaseVersion() and
isVersionAtLeast().
*/

public final static long VERSION_20070525 = 2007052520070525L;
public final static long VERSION_LATEST = VERSION_20070525;

public final static long VERSION_20070502 = 2007050220070502L;

public final static long VERSION_20070416 = 2007041620070416L;

public final static long VERSION_20061003 = 2006100320070201L;

public final static long VERSION_20051115 = 2005111520051115L;

public final static long VERSION_20050701 = 2005050120050701L;

public final static long VERSION_20050501 = 2005050120050501L;

/**
<ul>
<li><i>Agricultural_NASS_Crop_stats</i> field exists.</li>
</ul>
*/
public final static long VERSION_20040701 = 2004070120040701L;

/**
<ul>
<li><i>str_type</i> table exists.</li>
</ul>
*/
public final static long VERSION_20030701 = 2003070120030701L;

/**
<ul>
<li><i>geoloc.elev</i> is present (used to be <i>geoloc.elevation</i> in 
RTi version)</li>
<li><i>geoloc.elev</i> field exists.</li>
</ul>
*/
public final static long VERSION_20010326 = 2001032620010326L;

/**
<ul>
<li><i>structure_to_well</i> is changed to <i>well_to_structure</i></li>
<li><i>well_parcels</i> is changed to <i>well_to_parcel</i></li>
<li><i>layers</i> is changed to <i>well_to_layer</i></li>
<li><i>well_to_structure</i> table exists.</li>
</ul>
*/
public final static long VERSION_20000706 = 2000070620000706L;

/**
<ul>
<li><i>struct_to_well</i> table has a <i>unique_ditch</i> column.</li>
</ul>
*/
public final static long VERSION_20000427 = 2000042720000427L;

/**
<ul>
<li><i>geoloc</i> table has a <i>elevation</i> column.</li>
<li>has well_application and struct_to_well tables
(however, these are not checked because they may not always be linked
in).
<li>
</ul>
*/
public final static long VERSION_20000301 = 2000030120000301L;

/**
<ul>
<li><i>contact</i> table has a <i>phone_ext</i> column.</li>
<li><i>ref_county</i> table has an <i>abbrev</i> column.</li>
<li><i>geoloc</i> table has a <i>utm_x</i> column.</li>
<li><i>person_details</i> table has a <i>priority</i> column.</li>
<li><i>rolodex</i> table has a <i>lic_no</i> column.</li>
<li><i>station</i> table has a <i>transbsn</i> column.</li>
<li><i>structure</i> table has a <i>transbsn</i> column.</li>
<li><i>user_security</i> table has an <i>application</i> column.</li>
</ul>
*/
public final static long VERSION_19990305 = 1999030519990305L;

/**
<ul>
<li>Has the <i>irrig_summary</i> table.</li>
<li>The <i>irrig_time_series</i> table has <i>wd</i> and <i>id</i> columns.</li>
</ul>
*/
public final static long VERSION_19990202 = 1999020219990202L;

/**
<ul>
<li>Has a <i>struct_meas_type</i> table.</li>
*/
public final static long VERSION_19980428 = 1998042819980428L;

/**
<ul>
<li>Has a <i>geoloc</i>table.</li>
<li>Has a <i>structure</i> table.</li>
<li>Has a <i>station</i> table.</li>
</ul>	
*/
public final static long VERSION_19970501 = 1997050119970501L;

/**
Unknown version.
*/
public final static long VERSION_UNKNOWN  = 0L;

// agricultural_CASS_crop_statistics
private final int __S_AGRICULTURAL_CASS_CROP_STATS = 20;
private final int __S_AGRICULTURAL_CASS_CROP_STATS_DISTINCT = 21;

private final int __S_AGRICULTURAL_CASS_LIVESTOCK_STATS = 24;
private final int __S_AGRICULTURAL_CASS_LIVESTOCK_STATS_DISTINCT = 25;

// agricultural_NASS_crop_statistics
private final int __S_AGRICULTURAL_NASS_CROP_STATS = 29;
private final int __S_AGRICULTURAL_NASS_CROP_STATS_DISTINCT = 30;

// annual_amt
private final int __S_ANNUAL_AMT = 40;

// annual_res
private final int __S_ANNUAL_RES = 50;

// annual_wc
private final int __S_ANNUAL_WC = 60;
private final int __S_ANNUAL_WC_SFUT_DISTINCT = 61;

// aquifer
private final int __S_AQUIFER = 70;

// area_cap
private final int __S_AREA_CAP = 80;

// calls
private final int __S_CALLS = 140;
private final int __S_CALLS_SP = 142;
private final int __S_CALLS_EDIT_SP = 143;
private final int __W_CALLS = 144;
private final int __W_CALLS_2 = 145;
private final int __W_CALLS_3 = 146;
private final int __W_CALLS_4 = 147;
private final int __W_CALLS_5 = 148;
private final int __W_CALLS_6 = 149;

// contact
private final int __S_CONTACT = 160;

// courtcase
private final int __S_COURTCASE_FOR_STRUCTURE_NUM = 201;

// crop_ref
private final int __S_CROP_REF = 260;

// cropchar
private final int __S_CROPCHAR = 280;
private final int __S_CROPCHAR_DISTINCT = 281;
private final int __S_CROPCHAR_FOR_METHOD_DESC = 282;
private final int __S_CROPCHAR_FOR_LENGTHOFSEASON_GT_0 = 283;

// cu_blaney_criddle
private final int __S_CU_BLANEY_CRIDDLE = 300;
private final int __S_CG_CU_BLANEY_CRIDDLE = 301;
private final int __S_CU_BLANEY_CRIDDLE_DISTINCT = 302;
private final int __S_CU_BLANEY_CRIDDLE_FOR_METHOD_DESC = 303;
private final int __S_CG_CU_BLANEY_CRIDDLE_FOR_METHOD_DESC = 304;

// cu_coeff
private final int __S_CU_COEFF = 360;

// cu_method
private final int __S_CU_METHOD = 380;

// cu_method_distinct
private final int __S_CU_METHOD_DISTINCT = 400;

// cu_mod_hargreaves
private final int __S_CG_CU_MOD_HARGREAVES = 421;
private final int __S_CG_CU_MOD_HARGREAVES_FOR_METHOD_DESC = 423;

// cu_penman_monteith
private final int __S_CG_CU_PENMAN_MONTEITH = 441;
private final int __S_CG_CU_PENMAN_MONTEITH_FOR_METHOD_DESC = 443;

//DailyAdminFlow
protected final int __S_DAILY_ADMIN_FLOW = 460;

// daily_amt
private final int __S_DAILY_AMT = 480;

// daily_evap
protected final int __S_DAILY_EVAP = 500;

// daily_flow
protected final int __S_DAILY_FLOW = 520;

// daily_max_t
protected final int __S_DAILY_MAX_T = 540;

// daily_min_t
protected final int __S_DAILY_MIN_T = 560;

// daily_pcpn
protected final int __S_DAILY_PCPN = 580;

// daily_snow
protected final int __S_DAILY_SNOW = 600;

// daily_solar
protected final int __S_DAILY_SOLAR = 620;

// daily_vp
protected final int __S_DAILY_VP = 640;

// daily_wc
protected final int __S_DAILY_WC = 660;

// daily_wind
protected final int __S_DAILY_WIND = 680;

// dam
private final int __S_DAM = 700;

// dam_inspection
private final int __S_DAM_INSPECTION = 720;

// dam_outlet
private final int __S_DAM_OUTLET = 740;

// dam_spillway
private final int __S_DAM_SPILLWAY = 760;

// developer flex codes
private final int __S_DEVELOPER_FLEX_CODES = 750;

// dbversion
private final int __S_DBVERSION = 780;
private final int __S_DBVERSION_FOR_VERSION_TYPE = 781;

// diversion_comment
private final int __S_DIVERSION_COMMENT = 800;
private final int __S_DIVERSION_COMMENT_FOR_STRUCTURE_NUM = 801;

// emergency_plan
private final int __S_EMERGENCY_PLAN = 840;

// equipment
private final int __S_EQUIPMENT = 860;

// frost_dates
private final int __S_FROST_DATES = 880;

// general_comment
private final int __S_GENERAL_COMMENT = 900;

// geoloc
private final int __S_GEOLOC = 920;
private final int __S_GEOLOC_FOR_HUC = 921;

// geophlogs
private final int __S_GEOPHLOGS = 1000;

// loc_type
private final int __S_LOC_TYPE = 1160;

// mapfile
private final int __S_MAPFILE = 1200;

// meas_type
private final int __S_MEAS_TYPE = 1220;
private final int __S_MEAS_TYPE_DISTINCT = 1221;

// mf_reach
private final int __S_MF_REACH = 1240;

// monthly_evap
protected final int __S_MONTHLY_TOTAL_EVAP = 1280;

// monthly_flow
protected final int __S_MONTHLY_MAX_ADMIN_FLOW = 1290;
protected final int __S_MONTHLY_MAX_FLOW = 1300;
protected final int __S_MONTHLY_MIN_FLOW = 1301;
protected final int __S_MONTHLY_MIN_ADMIN_FLOW = 1310;
protected final int __S_MONTHLY_TOTAL_FLOW = 1302;
protected final int __S_MONTHLY_TOTAL_ADMIN_FLOW = 1311;

// monthly_nflow
protected final int __S_MONTHLY_TOTAL_NFLOW = 1320;

// monthly_pcpn
protected final int __S_MONTHLY_TOTAL_PCPN = 1340;

// monthly_snow
protected final int __S_MONTHLY_TOTAL_SNOW = 1360;

// monthly_temp
protected final int __S_MONTHLY_AVG_MAX_T = 1380;
protected final int __S_MONTHLY_AVG_MIN_T = 1381;
protected final int __S_MONTHLY_MEAN_T = 1382;

// net_amts
private final int __S_NET_AMTS = 1400;
private final int __S_NET_AMTS_FOR_WD_ID = 1401;

// parcel_use_ts
private final int __S_PARCEL_USE_TS = 1410;
private final int __S_PARCEL_USE_TS_DISTINCT = 1412;
private final int __S_PARCEL_USE_TS_STRUCTURE_TO_PARCEL_JOIN = 1411;
private final int __S_PARCEL_USE_TS_STRUCTURE_TO_PARCEL_JOIN_FOR_CAL_YEAR = 1413;

// person_details
private final int __S_PERSON_DETAILS = 1420;

// pump_test
private final int __S_PUMP_TEST = 1440;
private final int __S_PUMP_TEST_VIEW = 1441;

// ref_ciu
private final int __S_REF_CIU = 1430;

// ref_county
private final int __S_REF_COUNTY = 180;

// res_eom
private final int __S_RES_EOM = 1460;

// res_meas
private final int __S_RES_MEAS = 1480;

// reservoir
private final int __S_RESERVOIR = 1500;
private final int __S_RESERVOIR_FOR_STRUCTURE_NUM = 1501;

// rolodex
private final int __S_ROLODEX_FOR_ROLODEX_NUM = 1521;
private final int __S_ROLODEX_FOR_STRUCTURE_NUM = 1522;

// rt_meas
private final int __S_RT_MEAS = 1540;

// small_dam
private final int __S_SMALL_DAM = 1580;

// snow_crse
private final int __S_SNOW_CRSE = 1600;

// station
private final int __S_STATION_GEOLOC_MEAS_TYPE = 1642;
private final int __S_STATION_GEOLOC_CU_CLIM_WTS = 1643;
private final int __S_STATION_GEOLOC_MEAS_TYPE_DISTINCT = 1644;
private final int __S_STATION_FOR_STATION_ID = 1645;
private final int __S_STATION_GEOLOC_FOR_STATION_ID = 1646;
private final int __S_STATION_VIEW = 1647;
private final int __S_STATION_MEAS_TYPE_VIEW = 1648;
private final int __S_STATION_MEAS_TYPE_DISTINCT_VIEW = 1649;

// str_type
private final int __S_STR_TYPE = 1670;

// stream
private final int __S_STREAM_FOR_WD = 1680;
private final int __S_STREAM_FOR_STREAM_NUM = 1681;
private final int __S_STREAM_FOR_WD_STR_TRIB_TO = 1682;

// struct_meas_type
private final int __S_STRUCT_MEAS_TYPE = 1700;
private final int __S_STRUCT_MEAS_TYPE_DISTINCT = 1701;
private final int __S_STRUCT_MEAS_TYPE_FOR_STRUCTURE_NUM = 1702;
private final int __S_STRUCT_MEAS_TYPE_FOR_STRUCTURE_NUM_MEAS_TYPE = 1703;
private final int __S_STRUCT_MEAS_TYPE_DISTINCT_2 = 1704;
private final int __S_STRUCT_MEAS_TYPE_VIEW = 1705;

// structure
private final int __S_STRUCTURE_IRRIG_SUMMARY_JOIN = 1710;
private final int __S_STRUCTURE_LIST_FOR_WDID = 1720;
private final int __S_STRUCTURE_GEOLOC_LIST_FOR_WDID = 1721;
private final int __S_STRUCTURE_GEOLOC_STRUCT_MEAS_TYPE = 1722;
private final int __S_STRUCTURE_GEOLOC_STRUCT_MEAS_TYPE_2 = 1731;
private final int __S_STRUCTURE_GEOLOC_STRUCT_MEAS_TYPE_DISTINCT = 1723;
private final int __S_STRUCTURE_GEOLOC = 1724;
private final int __S_STRUCTURE_DISTINCT_WD = 1725;
private final int __S_STRUCTURE = 1726;
private final int __S_STRUCTURE_WD_WATER = 1727;
private final int __S_STRUCTURE_IRRIG_SUMMARY_JOIN_FOR_STRUCTURE_NUM = 1728;
private final int __S_STRUCTURE_FOR_STRUCTURE_NUM = 1729;
private final int __S_STRUCTURE_GEOLOC_FOR_STRUCTURE_NUM = 1730;
private final int __S_STRUCTURE_VIEW = 1732;

// structure_aka
private final int __S_STRUCTURE_AKA = 1740;

// structure + irrig_summary_ts
private final int __S_STRUCTURE_IRRIG_SUMMARY_TS_JOIN = 1750;
private final int __S_STRUCTURE_IRRIG_SUMMARY_TS_JOIN_DISTINCT = 1751;
private final int __S_STRUCTURE_IRRIG_SUMMARY_TS_JOIN_DISTINCT_SP = 1752;
private final int __S_STRUCTURE_IRRIG_SUMMARY_TS_VIEW = 1753;
private final int __S_STRUCTURE_IRRIG_SUMMARY_TS_DISTINCT_VIEW = 1754;

// transact
private final int __S_TRANSACT = 1820;
private final int __S_TRANSACT_FOR_STRUCTURE_NUM = 1821;

// tsproduct
private final int __D_TSPRODUCT = 1826;
private final int __S_TSPRODUCT = 1827;
private final int __S_TSPRODUCT_FOR_IDENTIFIER = 1828;
private final int __W_TSPRODUCT_INSERT = 1829;
private final int __W_TSPRODUCT_UPDATE = 1830;
private final int __W_TSPRODUCT_2 = 1831;
private final int __S_TSPRODUCT_MAX_TSPRODUCT_NUM = 1832;

// tsproductprops
private final int __S_TSPRODUCTPROPS = 1834;
private final int __W_TSPRODUCTPROPS = 1835;
private final int __D_TSPRODUCTPROPS = 1836;

// unpermitted_wells
private final int __S_UNPERMITTED_WELLS = 1840;
private final int __S_UNPERMITTED_WELL_STRUCT_MEAS_TYPE_VIEW = 1841;

// use
private final int __S_USE = 1860;

// user_preferences
private final int __S_USER_PREFERENCES = 1880;
private final int __W_USER_PREFERENCES_INSERT = 1881;
private final int __W_USER_PREFERENCES_UPDATE = 1882;

// user_security
private final int __S_USER_SECURITY = 1900;
private final int __S_USER_SECURITY_FOR_USER_NUM = 1901;
private final int __W_USER_SECURITY = 1902;
private final int __W_USER_SECURITY_2 = 1903;

// water_district
private final int __S_WATER_DISTRICT = 1960;
private final int __S_WATER_DISTRICT_BY_DIV = 1961;

// water_division
private final int __S_WATER_DIVISION = 1970;

// wd_water
private final int __S_WD_WATER_NO_STRUCTURE = 1983;

// well_application
private final int __S_WELL_APPLICATION = 2100;
private final int __S_WELL_APPLICATION_GEOLOC = 2101;
private final int __S_WELL_APPLICATION_VIEW = 2102;

// well_meas
private final int __S_WELL_MEAS = 2120;

// wells_layer
private final int __S_WELLS_LAYER = 2140;

// wells_parcel
private final int __S_WELLS_PARCEL = 2160;
private final int __S_WELLS_PARCEL_STRUCTURE = 2161;

// wells_structure
private final int __S_WELLS_STRUCTURE = 2180;

// wells
private final int __S_WELLS = 2200;

// wis_comments
private final int __D_WIS_COMMENTS_FOR_WIS_NUM = 1999;
private final int __S_WIS_COMMENTS_FOR_WIS_NUM_SET_DATE = 2001;
private final int __W_WIS_COMMENTS = 2002;

// wis_daily_wc
private final int __D_WIS_DAILY_WC = 2221;
private final int __S_WIS_DAILY_WC = 2222;
private final int __W_WIS_DAILY_WC = 2223;

// wis_data
private final int __S_WIS_DATA = 2020;
private final int __S_WIS_DATA_FOR_WIS_NUM_SET_DATE = 2021;
private final int __W_WIS_DATA = 2022;
private final int __D_WIS_DATA = 2023;

// wis_diagram_data
private final int __S_WIS_DIAGRAM_DATA = 2085;
private final int __W_WIS_DIAGRAM_DATA = 2086;
private final int __D_WIS_DIAGRAM_DATA = 2087;
private final int __D_WIS_DIAGRAM_DATA_FOR_WIS_NUM = 2088;

// wis_format
private final int __S_WIS_FORMAT = 2040;
private final int __W_WIS_FORMAT = 2042;
private final int __D_WIS_FORMAT = 2043;

// wis_formula
private final int __S_WIS_FORMULA = 2060;
private final int __W_WIS_FORMULA = 2061;
private final int __D_WIS_FORMULA = 2062;

// wis_import
private final int __S_WIS_IMPORT = 2080;
private final int __W_WIS_IMPORT = 2081;
private final int __D_WIS_IMPORT = 2082;

// wis_sheet_name
private final int __S_WIS_SHEET_NAME_DISTINCT = 1561;
private final int __W_WIS_SHEET_NAME = 1562;
private final int __S_WIS_SHEET_NAME_FOR_WIS_NUM = 1563;
private final int __S_WIS_SHEET_NAME_WIS_FORMAT_DISTINCT = 1567;
private final int __W_WIS_SHEET_NAME_GAIN_METHOD = 1570;
private final int __D_WIS_SHEET_NAME = 1571;

// wis_data (not actualy tables, but groups of tables for SP)
private final int __D_WIS_DATA_1 = 2100;
private final int __D_WIS_DATA_2 = 2101;


/**
Used to denote that a user has all permissions.
*/
private final String __ALL_PERMISSIONS = "-999";

/**
Used to denote that a user has no permissions.
*/
private final String __NO_PERMISSIONS = "0";

/**
Whether the currently-logged-in user is the guest user.
*/
private boolean __isGuest = false;

/**
Whether to print SQL or SP strings at debug level 30 as database operations
execute.
*/
private boolean __printQueryStrings = true;

/**
Whether to use stored procedures or not.
*/
private boolean __useSP = false;

/**
The last DMISelectStatement executed by the DMI.  This is used for stored
procedure connections in order that the stored procedures can be closed 
properly.
*/
private DMISelectStatement __lastStatement = null;

/**
The hashtable that caches stored procedure information.
*/
private Hashtable __storedProcedureHashtable = null;

/**
Holds the relationship of views to the view numbers used internally by the
SPFlex stored procedure.
*/
private Hashtable __viewNumbers = null;

/**
Database version, used with getLatestVersionString().
*/
private int __design_version = -1;

/**
Data version, used with getLatestVersionString().
*/
private int __data_version = -1;

/**
The number of the user for which user preferences were read.
*/
private int __userNum = -1;

/**
Holds all the user preferences read when a user logs in to the database.
*/
private PropList __prefsProps = null;

/**
The current user permissions as read from the database.
*/
private String __userSecurityPermissions = __NO_PERMISSIONS;

/**
Vector of TSProductAnnotationProviders.
*/
private Vector __providers = new Vector();

/**
Distinct Aquifers from the refAquifer table.
*/
private Vector __AquiferRef_Vector = null;

/**
Distinct CU Methods from the CU_Blaney_Criddle table.
*/
private Vector __BlaneyCriddleCUMethod_Vector = null;

/**
Distinct counties from the refCounty table.
*/
private Vector __CountyRef_Vector = null;

/**
Distinct CU Methods from the cropchar table.
*/
private Vector __CropcharCUMethod_Vector = null;

/**
Crops from the refCrop table.
*/
private Vector __CropRef_Vector = null;

/**
HUC from Geoloc.HUC
*/
private Vector __HUC_Vector = null;

/**
Location types from the refLocType table.
*/
private Vector __LocTypes_Vector = null;

/**
Distinct meas types.
*/
private Vector __MeasType_Vector = null;

/**
CIUs from the refCIU table.
*/
private Vector __RefCIU_Vector = null;

/**
Structure types from the refStrType table.
*/
private Vector __StrTypes_Vector = null;

/**
Distinct StructMeasTypes.
*/
private Vector __StructMeasType_Vector = null;

/**
Use types from the refUseType table.
*/
private Vector __UseTypes_Vector = null;

/**
Water districts data.
*/
private Vector __WaterDistricts_Vector = null;

/**
Water districts sorted by division.
*/
private Vector __WaterDistrictsByDiv_Vector = null;

/**
Water disitricts from structures.
*/
private Vector __WaterDistrictsFromStructures_Vector = null;

/**
Water divisions data.
*/
private Vector __WaterDivisions_Vector = null;

/**
This Vector will contain HydroBase_Structure objects, UNLESS stored procedures
are being used, in which case it will contain HydroBase_StructureView objects.
*/
private Vector __WISStructures_Vector = null;

/** 
Constructor for a predefined ODBC DSN that does not enable Stored Procedures.
@param database_engine The database engine to use (see the DMI constructor).
@param odbc_name The ODBC DSN that has been defined on the machine.
If null, default to "HydroBase".
@param system_login If not null, this is used as the system login to make the
connection.  If null, the default system login is used ("guest").
@param system_password If not null, this is used as the system password to make
the connection.  If null, the default system password is used ("guest").
*/
public HydroBaseDMI (	String database_engine, String odbc_name,
			String system_login, String system_password )
throws Exception {
	this(database_engine, odbc_name, system_login, system_password, false);
}

/** 
Constructor for a predefined ODBC DSN.
@param database_engine The database engine to use (see the DMI constructor).
@param odbc_name The ODBC DSN that has been defined on the machine.
If null, default to "HydroBase".
@param system_login If not null, this is used as the system login to make the
connection.  If null, the default system login is used ("guest").
@param system_password If not null, this is used as the system password to make
the connection.  If null, the default system password is used ("guest").
@param useStoredProcedures specifies whether stored procedures should be used.
*/
public HydroBaseDMI (	String database_engine, String odbc_name,
			String system_login, String system_password,
			boolean useStoredProcedures)
throws Exception
{	// Use the default system login and password
	super ( database_engine, odbc_name, system_login, system_password );

	// Turn off printing of the Stored Procedure or SQL string to 
	// Debug 30, for the sake of security. 
	__printQueryStrings = false;

	setUseStoredProcedures(useStoredProcedures);

	if ( odbc_name == null ) {
		// Use the default...
		setODBCName("HydroBase");
	}
	if (useStoredProcedures) {
		if ( system_login == null ) {
			// Use the default...
			setSystemLogin("cdss");
		}
		if ( system_password == null ) {
			// Use the default...
			setSystemPassword("cdss%tools");
		}
	}
	else {
		if ( system_login == null ) {
			// Use the default...
			setSystemLogin("crdss");
		}
		if ( system_password == null ) {
			// Use the default...
			setSystemPassword("crdss3nt");
		}
	}
	
	setEditable(true);
	setSecure(false);
	setCapitalize(true);
	if (IOUtil.testing()) {
		dumpSQLOnError(true);
		dumpSQLOnExecution(false);
	}

	// Turn back on printing of Stored Procedure or SQL strings to 
	// Debug 30.
	__printQueryStrings = true;
}

/** 
Constructor for a database server and database name, to use an automatically
created URL to connect to a database that does not use stored procedures.
@param database_engine The database engine to use (see the DMI constructor).
If null, default to "SQLServer2000".
@param database_server The IP address or DSN-resolvable database server
machine name.
@param database_name The database name on the server.  If null, default to
"HydroBase".
@param port Port number used by the database.  If negative, default to that for
the database engine.
@param system_login If not null, this is used as the system login to make the
connection.  If null, the default system login is used ("guest").
@param system_password If not null, this is used as the system password to make
the connection.  If null, the default system password is used ("guest").
*/
public HydroBaseDMI (	String database_engine, String database_server,
			String database_name, int port,
			String system_login, String system_password )
throws Exception {
	this(database_engine, database_server, database_name, port,
		system_login, system_password, false);
}

/** 
Constructor for a database server and database name, to use an automatically
created URL.
@param database_engine The database engine to use (see the DMI constructor).
If null, default to "SQLServer2000".
@param database_server The IP address or DSN-resolvable database server
machine name.
@param database_name The database name on the server.  If null, default to
"HydroBase".
@param port Port number used by the database.  If negative, default to that for
the database engine.
@param system_login If not null, this is used as the system login to make the
connection.  If null, the default system login is used ("guest").
@param system_password If not null, this is used as the system password to make
the connection.  If null, the default system password is used ("guest").
@param useStoredProcedures specifies whether stored procedures should be used.
*/
public HydroBaseDMI (	String database_engine, String database_server,
			String database_name, int port,
			String system_login, String system_password,
			boolean useStoredProcedures)
throws Exception
{	// Use the default system login and password
	super ( database_engine, database_server, database_name, port,
		system_login, system_password );

	// Turn off printing of the Stored Procedure or SQL string to 
	// Debug 30, for the sake of security. 
	__printQueryStrings = false;
	
	setUseStoredProcedures(useStoredProcedures);
	
	if ( database_engine == null ) {
		// Use the default...
		setDatabaseEngine("SQLServer2000");
	}
	if ( database_name == null ) {
		// Use the default...
		setDatabaseName("HydroBase");
	}
	if (useStoredProcedures) {
		if ( system_login == null ) {
			// Use the default...
			setSystemLogin("cdss");
		}
		if ( system_password == null ) {
			// Use the default...
			setSystemPassword("cdss%tools");
		}
	}
	else {
		if ( system_login == null ) {
			// Use the default...
			setSystemLogin("crdss");
		}
		if ( system_password == null ) {
			// Use the default...
			setSystemPassword("crdss3nt");
		}
	}
	
	setEditable(true);
	setSecure(false);
	setCapitalize(true);
	if (IOUtil.testing()) {
		dumpSQLOnError(false);
		dumpSQLOnExecution(false);
	}

	// Turn back on printing of Stored Procedure or SQL strings to 
	// Debug 30.
	__printQueryStrings = true;
}

/** 
Constructor for a database server and database name, to use an automatically
created URL.
@param props a PropList containing properties controlling how to connect
to the database.  The following properties are available:<p>
<table>
<tr>
<td><b>Property Name</b></td><td><b>Default Value</b></td></tr>
<tr>
<td>HydroBase.DatabaseEngine</td><td>SQLServer2000</td></tr>
<tr>
<td>HydroBase.DatabaseServer</td><td><b>None -- required.</b>Can be "local",
in which case the current machine on which the software is running is 
connected to.</td></tr>
<tr>
<td>HydroBase.DatabaseName</td><td>HydroBase</td></tr>
<tr>
<td>HydroBase.UseStoredProcedures</td><td>True</td></tr>
<tr>
<td>HydroBase.SystemLogin</td><td>cdss (if using stored procedures)<p>
crdss (if not using stored procedures)</td></tr>
<tr>
<td>HydroBase.SystemPassword</td><td>cdss%tools (if using stored procedures)<p>
crdss3nt (if not using stored procedures)</td></tr>
<tr>
<td>HydroBase.Port</td><td>1433, then 21784 (if connecting to a remote server)
<p>21784, then 1433 (if connecting to a local machine)</td></tr>
</table>
*/
public HydroBaseDMI(PropList props) 
throws Exception {
	// Use the default system login and password
	super();

	// Turn off printing of the Stored Procedure or SQL string to 
	// Debug 30, for the sake of security. 
	__printQueryStrings = false;

	String database_engine = null;
	String database_server = null;
	String database_name = null;
	String system_login = null;
	String system_password = null;
	String portS = null;
	String useStoredProceduresS = null;

	String defaultDatabase_name = null;
	String defaultServer_name = null;

	if (props != null) {
		database_engine = props.getValue("HydroBase.DatabaseEngine");
		database_server = props.getValue("HydroBase.DatabaseServer");
		database_name = props.getValue("HydroBase.DatabaseName");
		useStoredProceduresS = props.getValue(
			"HydroBase.UseStoredProcedures");
		system_login = props.getValue("HydroBase.SystemLogin");
		system_password = props.getValue("HydroBase.SystemPassword");
		portS = props.getValue("HydroBase.Port");

		defaultDatabase_name = props.getValue(
			"HydroBase.DefaultDatabaseName");
		defaultServer_name = props.getValue(
			"HydroBase.DefaultServerName");
	}
	
	if (database_engine == null) {
		database_engine = "SQLServer2000";
	}

	if (database_server == null) {
		if (defaultServer_name == null) {
			throw new Exception("No HydroBase.DefaultServerName or "
				+ "HydroBase.DatabaseServer property set in "
				+ "configuration file.");
		}
		else {
			database_server = defaultServer_name;
		}
	}

	if (database_name == null) {
		if (defaultDatabase_name == null) {
			database_name = "HydroBase";
		}
		else {
			database_name = defaultDatabase_name;
		}
	}

	boolean useStoredProcedures = true;
	if (useStoredProceduresS != null) {
		if (useStoredProceduresS.equalsIgnoreCase("false")) {
			useStoredProcedures = false;
		}
	}

	if (useStoredProcedures) {
		if (system_login == null) {
			system_login = "cdss";
		}

		if (system_password == null) {
			system_password = "cdss%tools";
		}
	}
	else {
		if (system_login == null) {
			system_login = "crdss";
		}

		if (system_password == null) {
			system_password = "crdss3nt";
		}
	}
	
	int port = -1;
	if (portS != null) {
		port = StringUtil.atoi(portS);
	}
	else {
		if (database_server.equalsIgnoreCase(HydroBase_Util.LOCAL)
		    || IOUtil.getProgramHost().equalsIgnoreCase(
		    database_server)) {
		    	// connecting to the local machine.  Try the MSDE 
			// port first.
			database_server = IOUtil.getProgramHost();
			__localPorts = new int[2];
			__localPorts[0] = 21784;
			__localPorts[1] = 1433;
			port = __localPorts[0];
		}
		else {
		    	// connecting to a remote machine.  Try the SQL 
			// Server port first.
			__localPorts = new int[2];
			__localPorts[0] = 1433;
			__localPorts[1] = 21784;
			port = __localPorts[0];
		}
	}

	initialize(database_engine, database_server, database_name, port,
		system_login, system_password, null, true);
	
	setUseStoredProcedures(useStoredProcedures);

	// Turn back on printing of Stored Procedure or SQL strings to 
	// Debug 30.
	__printQueryStrings = true;
}

private static int[] __localPorts = null;

// A METHODS

public void addAnnotationProvider(String name) {
	__providers.add(name);
}

public void addAnnotations(TSProduct product, PropList props) {}

// B METHODS

/** 
Build an SQL string based on a requested SQL statement code.  This defines 
the basic statement and allows overloaded methods to avoid redundant code.
This method is used to eliminate redundant code where methods use the same
basic statement but with different where clauses.
@param statement Statement to set values in.
@param sqlNumber the number of the SQL statement to build.  Usually defined
as a private constant as a mnemonic aid.
@return a string containing the full SQL.
*/
private void buildSQL (DMIStatement statement, int sqlNumber)
throws Exception {
	DMISelectStatement select;
	DMIWriteStatement write;
	boolean distinct = false;
	String table = null;
	long version = getDatabaseVersion();

	if (canSetUpStoredProcedure(statement, sqlNumber)) {
		// where, distinct and order by clauses can be set
		// as usual for other types of queries.
		return;
	}
	
	switch (sqlNumber) {
		case __S_AGRICULTURAL_CASS_CROP_STATS:
			select = (DMISelectStatement)statement;
			select.addField("agricultural_cass_crop_stats.st");
			select.addField("agricultural_cass_crop_stats.county");
			select.addField(
				"agricultural_cass_crop_stats.commodity");
			select.addField(
				"agricultural_cass_crop_stats.practice");
			select.addField(
				"agricultural_cass_crop_stats.cal_year");
			select.addField("agricultural_cass_crop_stats.Planted");
			select.addField(
				"agricultural_cass_crop_stats.pltdharv");
			select.addField(
				"agricultural_cass_crop_stats.harvested");
			select.addField("agricultural_cass_crop_stats.pltdyld");
			select.addField("agricultural_cass_crop_stats.yield");
			select.addField(
				"agricultural_cass_crop_stats.yieldunit");
			select.addField(
				"agricultural_cass_crop_stats.production");
			select.addField(
				"agricultural_cass_crop_stats.productionunit");
			select.addTable("agricultural_cass_crop_stats");
			break;
		case __S_AGRICULTURAL_CASS_CROP_STATS_DISTINCT:
			select = (DMISelectStatement)statement;
			select.addField("agricultural_cass_crop_stats.st");
			select.addField("agricultural_cass_crop_stats.county");
			select.addField(
				"agricultural_cass_crop_stats.commodity");
			select.addField(
				"agricultural_cass_crop_stats.practice");
			select.addTable("agricultural_cass_crop_stats");
			break;		
		case __S_AGRICULTURAL_NASS_CROP_STATS:
			select = (DMISelectStatement)statement;
			select.addField("agricultural_nass_crop_stats.st");
			select.addField("agricultural_nass_crop_stats.county");
			select.addField(
				"agricultural_nass_crop_stats.commodity");
			select.addField(
				"agricultural_nass_crop_stats.cal_year");
			select.addField(
				"agricultural_nass_crop_stats.ag_amt");
			select.addField(
				"agricultural_nass_crop_stats.flag");
			select.addTable("agricultural_nass_crop_stats");
			break;
		case __S_AGRICULTURAL_NASS_CROP_STATS_DISTINCT:
			select = (DMISelectStatement)statement;
			select.addField("agricultural_nass_crop_stats.st");
			select.addField("agricultural_nass_crop_stats.county");
			select.addField(
				"agricultural_nass_crop_stats.commodity");
			select.addTable("agricultural_nass_crop_stats");
			break;			
		case __S_ANNUAL_AMT:
			select = (DMISelectStatement)statement;
			select.addField("annual_amt.meas_num");
			select.addField("annual_amt.structure_num");
			select.addField("annual_amt.quality");
			select.addField("annual_amt.irr_year");
			select.addField("annual_amt.fdu");
			select.addField("annual_amt.ldu");
			select.addField("annual_amt.dwc");
			select.addField("annual_amt.maxq");
			select.addField("annual_amt.maxq_date");
			select.addField("annual_amt.nobs");
			select.addField("annual_amt.nus");
			select.addField("annual_amt.amt_nov");
			select.addField("annual_amt.amt_dec");
			select.addField("annual_amt.amt_jan");
			select.addField("annual_amt.amt_feb");
			select.addField("annual_amt.amt_mar");
			select.addField("annual_amt.amt_apr");
			select.addField("annual_amt.amt_may");
			select.addField("annual_amt.amt_jun");
			select.addField("annual_amt.amt_jul");
			select.addField("annual_amt.amt_aug");
			select.addField("annual_amt.amt_sep");
			select.addField("annual_amt.amt_oct");
			select.addField("annual_amt.ann_amt");
			select.addField("annual_amt.unit");
			select.addField("annual_amt.func");
			select.addField("annual_amt.div");
			select.addField("annual_amt.wd");
			select.addField("annual_amt.[id]");
			select.addTable("annual_amt");
			break;
		case __S_ANNUAL_RES:
			select = (DMISelectStatement)statement;
			select.addField("annual_res.meas_num");
			select.addField("annual_res.irr_year");
			select.addField("annual_res.structure_num");
			select.addField("annual_res.fdu");
			select.addField("annual_res.ldu");
			select.addField("annual_res.dwc");
			select.addField("annual_res.ann_amt");
			select.addTable("annual_res");
			break;			
		case __S_ANNUAL_WC:
			select = (DMISelectStatement)statement;
			select.addField("annual_wc.meas_num");
			select.addField("annual_wc.structure_num");
			select.addField("annual_wc.quality");
			select.addField("annual_wc.irr_year");
			select.addField("annual_wc.fdu");
			select.addField("annual_wc.ldu");
			select.addField("annual_wc.dwc");
			select.addField("annual_wc.maxq");
			select.addField("annual_wc.maxq_date");
			select.addField("annual_wc.nobs");
			select.addField("annual_wc.nus");
			select.addField("annual_wc.amt_nov");
			select.addField("annual_wc.amt_dec");
			select.addField("annual_wc.amt_jan");
			select.addField("annual_wc.amt_feb");
			select.addField("annual_wc.amt_mar");
			select.addField("annual_wc.amt_apr");
			select.addField("annual_wc.amt_may");
			select.addField("annual_wc.amt_jun");
			select.addField("annual_wc.amt_jul");
			select.addField("annual_wc.amt_aug");
			select.addField("annual_wc.amt_sep");
			select.addField("annual_wc.amt_oct");
			select.addField("annual_wc.ann_amt");
			select.addField("annual_wc.unit");
			select.addField("annual_wc.func");
			select.addField("annual_wc.div");
			select.addField("annual_wc.wd");
			select.addField("annual_wc.[id]");
			select.addField("annual_wc.s");
			select.addField("annual_wc.f");
			select.addField("annual_wc.u");
			select.addField("annual_wc.t");
			select.addTable("annual_wc");
			break;
		case __S_ANNUAL_WC_SFUT_DISTINCT:
			select = (DMISelectStatement)statement;
			select.addField("annual_wc.s");
			select.addField("annual_wc.f");
			select.addField("annual_wc.u");
			select.addField("annual_wc.t");
			select.addTable("annual_wc");
			select.selectDistinct(true);
			break;			
		case __S_AREA_CAP:
			select = (DMISelectStatement)statement;
			select.addField("area_cap.ac_num");
			select.addField("area_cap.structure_num");
			select.addField("area_cap.div");
			select.addField("area_cap.wd");
			select.addField("area_cap.[id]");
			select.addField("area_cap.elevation");
			select.addField("area_cap.gage_height");
			select.addField("area_cap.surface_area");
			select.addField("area_cap.volume");
			select.addTable("area_cap");
			break;
		case __S_CALLS:
			select = (DMISelectStatement)statement;
			select.addField("calls.call_num");
			select.addField("calls.wdwater_num");
			select.addField("calls.net_num");
			select.addField("calls.structure_num");
			select.addField("calls.date_time_set");
			select.addField("calls.date_time_released");
			select.addField("calls.adminno");
			select.addField("calls.districts_affected");
			select.addField("calls.str_name");
			select.addField("calls.wd");
			select.addField("calls.[id]");
			select.addField("calls.strname");
			select.addField("calls.strtribto");
			select.addField("calls.apro_date");
			select.addField("calls.dcr_amt");
			select.addField("calls.set_comments");
			select.addField("calls.release_comments");
			select.addField("calls.release_call_num");
			select.addField("calls.deleted");
			select.addField("calls.div");
			select.addField("calls.archive_date");
			select.addTable("calls");
			break;
		case __S_CONTACT:
			select = (DMISelectStatement)statement;
			select.addField("contact.contact_num");
			select.addField("contact.rolodex_num");
			select.addField("contact.contact_type");
			if (version < VERSION_19990305) {
				select.addField("contact.area_code");
			}
			select.addField("contact.phone_number");
			select.addField("contact.contact_text");
			select.addField("contact.first_contact");
			select.addField("rolodex.rolodex_num");
			if (version >= VERSION_19990305) {
				select.addField("contact.phone_ext");
			}
			select.addTable("contact");
			select.addTable("rolodex");
			select.addTable("person_details");
			select.addWhereClause("contact.rolodex_num "
				+ "= rolodex.rolodex_num");
			select.addWhereClause("person_details.rolodex_num "
				+ "= rolodex.rolodex_num");
			break;
		case __S_COURTCASE_FOR_STRUCTURE_NUM:
			select = (DMISelectStatement)statement;
			select.addField("courtcase.case_no_num");
			select.addField("courtcase.case_no");
			select.addField("courtcase.case_no_book");
			select.addField("courtcase.case_no_page");
			select.addField("courtcase.case_no_comment");
			select.addField("courtcase.decree_summary");
			select.addField("courtcase.structure_num");
			select.addTable("courtcase");
			break;
		case __S_CROP_REF:
			select = (DMISelectStatement)statement;
			select.addField("crop_ref.crop_code");
			select.addField("crop_ref.crop_desc");
			select.addTable("crop_ref");
			break;
		case __S_CROPCHAR:
		case __S_CROPCHAR_FOR_METHOD_DESC:
		case __S_CROPCHAR_FOR_LENGTHOFSEASON_GT_0:
			select = (DMISelectStatement)statement;
			select.addField("cropchar.cropnum");
			if (version >= VERSION_20000427) {
				select.addField("cropchar.method_desc");
			}
			select.addField("cropchar.cropname");
			select.addField("cropchar.tempearlymoisture");
			select.addField("cropchar.templatemoisture");
			select.addField("cropchar.initialroot");
			select.addField("cropchar.maxroot");
			select.addField("cropchar.madlevel");
			select.addField("cropchar.maxappdepth");
			select.addField("cropchar.daystofullcover");
			select.addField("cropchar.plantingmon");
			select.addField("cropchar.plantingday");
			select.addField("cropchar.harvestmon");
			select.addField("cropchar.harvestday");
			select.addField("cropchar.daystofirstcut");
			select.addField("cropchar.daysbetweencuts");
			select.addField("cropchar.lengthofseason");
			select.addField("cropchar.springfrostmethod");
			select.addField("cropchar.fallfrostmethod");
			select.addField("cropchar.irrig_cropnum");
			select.addTable("cropchar");
			break;
		case __S_CROPCHAR_DISTINCT:
			select = (DMISelectStatement)statement;
			select.addField("cropchar.method_desc");
			select.addTable("cropchar");
			break;
		case __S_CU_BLANEY_CRIDDLE:
		case __S_CG_CU_BLANEY_CRIDDLE:
		case __S_CU_BLANEY_CRIDDLE_FOR_METHOD_DESC:
		case __S_CG_CU_BLANEY_CRIDDLE_FOR_METHOD_DESC:
			// REVISIT (SAM)
			// does not match query definition from HBDMI
			// Join crop, cu_method, cu_blaney_criddle.  The read
			// method should define a where on crop name or cu
			// method description.
			// REVISIT (SAM) - actually, the definition of a
			// HydroBase_CUBlaneyCriddle object is dependent on
			// all 3 tables because the data objects contain arrays
			// of data!  Need to discuss.
			select = (DMISelectStatement)statement;
			select.addField("crop.cropnum");
			select.addField("crop.cropname");
			select.addField("cu_method.method_desc");
			select.addField("cu_blaney_criddle.curve_type");
			select.addField("cu_blaney_criddle.curve_value");
			select.addField("cu_blaney_criddle.cropgrowcoeff");
			select.addTable("crop");
			select.addTable("cu_method");
			select.addTable("cu_blaney_criddle");
			select.addWhereClause("crop.cropnum=cu_method.cropnum");
			select.addWhereClause("cu_method.method_num "
				+ "= cu_blaney_criddle.method_num");		
			break;
		case __S_CU_BLANEY_CRIDDLE_DISTINCT:
			// REVISIT (SAM) - I added this to support StateDMI
			// All we want is the distinct cu_method.method_desc
			// that apply for cu_blaney_criddle records but we
			// need to do a join to get it to work...
			select = (DMISelectStatement)statement;
			select.addField("cu_method.method_desc");
			select.addTable("cu_method");
			select.addTable("cu_blaney_criddle");
			select.addWhereClause(
			"cu_method.method_num=cu_blaney_criddle.method_num");
			break;
		case __S_CU_COEFF:
			select = (DMISelectStatement)statement;
			select.addField("cu_coeff.consnum");
			select.addField("cu_coeff.consname");
			select.addField("cu_coeff.consuse");
			select.addField("cu_coeff.cu_coeff");
			select.addTable("cu_coeff");
			break;
		case __S_CU_METHOD:
			select = (DMISelectStatement)statement;
			select.addField("cu_method.method_num");
			select.addField("cu_method.cropnum");
			select.addField("cu_method.method_desc");
			select.addTable("cu_method");
			select.addTable("cu_blaney_criddle");
			select.addWhereClause(
			"cu_method.method_num=cu_blaney_criddle.method_num");
			break;
		case __S_CU_METHOD_DISTINCT:
			select = (DMISelectStatement)statement;
			select.addField("cu_method.method_desc");
			select.addTable("cu_method");
			select.selectDistinct ( true);
			break;
		case __S_CG_CU_MOD_HARGREAVES:
		case __S_CG_CU_MOD_HARGREAVES_FOR_METHOD_DESC:
			select = (DMISelectStatement)statement;
			select.addField("crop.cropnum");
			select.addField("crop.cropname");
			select.addField("cu_mod_hargreaves.cover_10");
			select.addField("cu_mod_hargreaves.cover_80");
			select.addField("cu_mod_hargreaves.firstcut");
			select.addField("cu_mod_hargreaves.maturity");
			select.addField("cu_mod_hargreaves.secondcut");
			select.addField("cu_mod_hargreaves.harvest");
			select.addField("cu_mod_hargreaves.k1");
			select.addField("cu_mod_hargreaves.k2");
			select.addField("cu_mod_hargreaves.k3");
			select.addField("cu_method.method_desc");
			select.addTable("crop");
			select.addTable("cu_mod_hargreaves");
			select.addTable("cu_method");
			select.addWhereClause("crop.cropnum "
				+ "= cu_method.cropnum");
			select.addWhereClause("cu_method.method_num "
				+ "= cu_mod_hargreaves.method_num");
			break;
		case __S_CG_CU_PENMAN_MONTEITH:
		case __S_CG_CU_PENMAN_MONTEITH_FOR_METHOD_DESC:
			select = (DMISelectStatement)statement;
			select.addField("crop.cropnum");
			select.addField("crop.cropname");
			select.addField("cu_penman_monteith.growthstage_no");
			select.addField("cu_penman_monteith.curve_value");
			select.addField("cu_penman_monteith.cropgrowcoeff");
			select.addField("cu_method.method_desc");
			select.addTable("crop");
			select.addTable("cu_penman_monteith");
			select.addTable("cu_method");
			select.addWhereClause("crop.cropnum "
				+ "= cu_method.cropnum");
			select.addWhereClause("cu_method.method_num = "
				+ "cu_penman_monteith.method_num");
			break;
		case __S_DAILY_AMT:
			select = (DMISelectStatement)statement;
			select.addField("daily_amt.meas_num");
			select.addField("daily_amt.structure_num");
			select.addField("daily_amt.quality");
			select.addField("daily_amt.cal_year");
			select.addField("daily_amt.cal_mon");
			select.addField("daily_amt.irr_year");
			select.addField("daily_amt.irr_mon");
			select.addField("daily_amt.amt1");
			select.addField("daily_amt.obs1");
			select.addField("daily_amt.amt2");
			select.addField("daily_amt.obs2");
			select.addField("daily_amt.amt3");
			select.addField("daily_amt.obs3");
			select.addField("daily_amt.amt4");
			select.addField("daily_amt.obs4");
			select.addField("daily_amt.amt5");
			select.addField("daily_amt.obs5");
			select.addField("daily_amt.amt6");
			select.addField("daily_amt.obs6");
			select.addField("daily_amt.amt7");
			select.addField("daily_amt.obs7");
			select.addField("daily_amt.amt8");
			select.addField("daily_amt.obs8");
			select.addField("daily_amt.amt9");
			select.addField("daily_amt.obs9");
			select.addField("daily_amt.amt10");
			select.addField("daily_amt.obs10");
			select.addField("daily_amt.amt11");
			select.addField("daily_amt.obs11");
			select.addField("daily_amt.amt12");
			select.addField("daily_amt.obs12");
			select.addField("daily_amt.amt13");
			select.addField("daily_amt.obs13");
			select.addField("daily_amt.amt14");
			select.addField("daily_amt.obs14");
			select.addField("daily_amt.amt15");
			select.addField("daily_amt.obs15");
			select.addField("daily_amt.amt16");
			select.addField("daily_amt.obs16");
			select.addField("daily_amt.amt17");
			select.addField("daily_amt.obs17");
			select.addField("daily_amt.amt18");
			select.addField("daily_amt.obs18");
			select.addField("daily_amt.amt19");
			select.addField("daily_amt.obs19");
			select.addField("daily_amt.amt20");
			select.addField("daily_amt.obs20");
			select.addField("daily_amt.amt21");
			select.addField("daily_amt.obs21");
			select.addField("daily_amt.amt22");
			select.addField("daily_amt.obs22");
			select.addField("daily_amt.amt23");
			select.addField("daily_amt.obs23");
			select.addField("daily_amt.amt24");
			select.addField("daily_amt.obs24");
			select.addField("daily_amt.amt25");
			select.addField("daily_amt.obs25");
			select.addField("daily_amt.amt26");
			select.addField("daily_amt.obs26");
			select.addField("daily_amt.amt27");
			select.addField("daily_amt.obs27");
			select.addField("daily_amt.amt28");
			select.addField("daily_amt.obs28");
			select.addField("daily_amt.amt29");
			select.addField("daily_amt.obs29");
			select.addField("daily_amt.amt30");
			select.addField("daily_amt.obs30");
			select.addField("daily_amt.amt31");
			select.addField("daily_amt.obs31");
			select.addField("daily_amt.unit");
			select.addField("daily_amt.func");
			select.addField("daily_amt.div");
			select.addField("daily_amt.wd");
			select.addField("daily_amt.[id]");
			select.addTable("daily_amt");
			break;
		case __S_DAILY_PCPN:
			table = "daily_pcpn";
		case __S_DAILY_WIND:
			if (table == null) {
				table = "daily_wind";
			}
		case __S_DAILY_MIN_T:
			if (table == null) {
				table = "daily_min_t";
			}			
		case __S_DAILY_MAX_T:
			if (table == null) {
				table = "daily_max_t";
			}
		case __S_DAILY_VP:
			if (table == null) {
				table = "daily_vp";
			}
		case __S_DAILY_EVAP:
			if (table == null) {
				table = "daily_evap";
			}
		case __S_DAILY_SOLAR:
			if (table == null) {
				table = "daily_solar";
			}
		case __S_DAILY_SNOW:
			if (table == null) {
				table = "daily_snow";
			}
		case __S_DAILY_FLOW:
			if (table == null) {
				table = "daily_flow";
			}		
			select = (DMISelectStatement)statement;
			select.addField(table + ".meas_num");
			select.addField(table + ".cal_year");
			select.addField(table + ".cal_mon_num");
			select.addField(table + ".station_num");
			select.addField(table + ".cal_mon");
			select.addField(table + ".unit");
			select.addField(table + ".day1");
			if (sqlNumber == __S_DAILY_FLOW 
				&& version < VERSION_20050501) {
				select.addField(table + ".flag1");
				select.addField(table + ".day2");
				select.addField(table + ".flag2");
				select.addField(table + ".day3");
				select.addField(table + ".flag3");
				select.addField(table + ".day4");
				select.addField(table + ".flag4");
				select.addField(table + ".day5");
				select.addField(table + ".flag5");
				select.addField(table + ".day6");
				select.addField(table + ".flag6");
				select.addField(table + ".day7");
				select.addField(table + ".flag7");
				select.addField(table + ".day8");
				select.addField(table + ".flag8");
				select.addField(table + ".day9");
				select.addField(table + ".flag9");
				select.addField(table + ".day10");
				select.addField(table + ".flag10");
				select.addField(table + ".day11");
				select.addField(table + ".flag11");
				select.addField(table + ".day12");
				select.addField(table + ".flag12");
				select.addField(table + ".day13");
				select.addField(table + ".flag13");
				select.addField(table + ".day14");
				select.addField(table + ".flag14");
				select.addField(table + ".day15");
				select.addField(table + ".flag15");
				select.addField(table + ".day16");
				select.addField(table + ".flag16");
				select.addField(table + ".day17");
				select.addField(table + ".flag17");
				select.addField(table + ".day18");
				select.addField(table + ".flag18");
				select.addField(table + ".day19");
				select.addField(table + ".flag19");
				select.addField(table + ".day20");
				select.addField(table + ".flag20");
				select.addField(table + ".day21");
				select.addField(table + ".flag21");
				select.addField(table + ".day22");
				select.addField(table + ".flag22");
				select.addField(table + ".day23");
				select.addField(table + ".flag23");
				select.addField(table + ".day24");
				select.addField(table + ".flag24");
				select.addField(table + ".day25");
				select.addField(table + ".flag25");
				select.addField(table + ".day26");
				select.addField(table + ".flag26");
				select.addField(table + ".day27");
				select.addField(table + ".flag27");
				select.addField(table + ".day28");
				select.addField(table + ".flag28");
				select.addField(table + ".day29");
				select.addField(table + ".flag29");
				select.addField(table + ".day30");
				select.addField(table + ".flag30");
				select.addField(table + ".day31");
				select.addField(table + ".flag31");
			}
			else if (version >= VERSION_20010326) {
				select.addField(table + ".flag1a");
				select.addField(table + ".flag1b");
				select.addField(table + ".day2");
				select.addField(table + ".flag2a");
				select.addField(table + ".flag2b");
				select.addField(table + ".day3");
				select.addField(table + ".flag3a");
				select.addField(table + ".flag3b");
				select.addField(table + ".day4");
				select.addField(table + ".flag4a");
				select.addField(table + ".flag4b");
				select.addField(table + ".day5");
				select.addField(table + ".flag5a");
				select.addField(table + ".flag5b");
				select.addField(table + ".day6");
				select.addField(table + ".flag6a");
				select.addField(table + ".flag6b");
				select.addField(table + ".day7");
				select.addField(table + ".flag7a");
				select.addField(table + ".flag7b");
				select.addField(table + ".day8");
				select.addField(table + ".flag8a");
				select.addField(table + ".flag8b");
				select.addField(table + ".day9");
				select.addField(table + ".flag9a");
				select.addField(table + ".flag9b");
				select.addField(table + ".day10");
				select.addField(table + ".flag10a");
				select.addField(table + ".flag10b");
				select.addField(table + ".day11");
				select.addField(table + ".flag11a");
				select.addField(table + ".flag11b");
				select.addField(table + ".day12");
				select.addField(table + ".flag12a");
				select.addField(table + ".flag12b");
				select.addField(table + ".day13");
				select.addField(table + ".flag13a");
				select.addField(table + ".flag13b");
				select.addField(table + ".day14");
				select.addField(table + ".flag14a");
				select.addField(table + ".flag14b");
				select.addField(table + ".day15");
				select.addField(table + ".flag15a");
				select.addField(table + ".flag15b");
				select.addField(table + ".day16");
				select.addField(table + ".flag16a");
				select.addField(table + ".flag16b");
				select.addField(table + ".day17");
				select.addField(table + ".flag17a");
				select.addField(table + ".flag17b");
				select.addField(table + ".day18");
				select.addField(table + ".flag18a");
				select.addField(table + ".flag18b");
				select.addField(table + ".day19");
				select.addField(table + ".flag19a");
				select.addField(table + ".flag19b");
				select.addField(table + ".day20");
				select.addField(table + ".flag20a");
				select.addField(table + ".flag20b");
				select.addField(table + ".day21");
				select.addField(table + ".flag21a");
				select.addField(table + ".flag21b");
				select.addField(table + ".day22");
				select.addField(table + ".flag22a");
				select.addField(table + ".flag22b");
				select.addField(table + ".day23");
				select.addField(table + ".flag23a");
				select.addField(table + ".flag23b");
				select.addField(table + ".day24");
				select.addField(table + ".flag24a");
				select.addField(table + ".flag24b");
				select.addField(table + ".day25");
				select.addField(table + ".flag25a");
				select.addField(table + ".flag25b");
				select.addField(table + ".day26");
				select.addField(table + ".flag26a");
				select.addField(table + ".flag26b");
				select.addField(table + ".day27");
				select.addField(table + ".flag27a");
				select.addField(table + ".flag27b");
				select.addField(table + ".day28");
				select.addField(table + ".flag28a");
				select.addField(table + ".flag28b");
				select.addField(table + ".day29");
				select.addField(table + ".flag29a");
				select.addField(table + ".flag29b");
				select.addField(table + ".day30");
				select.addField(table + ".flag30a");
				select.addField(table + ".flag30b");
				select.addField(table + ".day31");
				select.addField(table + ".flag31a");
				select.addField(table + ".flag31b");
			}
			else {
				select.addField(table + ".flag1");
				select.addField(table + ".day2");
				select.addField(table + ".flag2");
				select.addField(table + ".day3");
				select.addField(table + ".flag3");
				select.addField(table + ".day4");
				select.addField(table + ".flag4");
				select.addField(table + ".day5");
				select.addField(table + ".flag5");
				select.addField(table + ".day6");
				select.addField(table + ".flag6");
				select.addField(table + ".day7");
				select.addField(table + ".flag7");
				select.addField(table + ".day8");
				select.addField(table + ".flag8");
				select.addField(table + ".day9");
				select.addField(table + ".flag9");
				select.addField(table + ".day10");
				select.addField(table + ".flag10");
				select.addField(table + ".day11");
				select.addField(table + ".flag11");
				select.addField(table + ".day12");
				select.addField(table + ".flag12");
				select.addField(table + ".day13");
				select.addField(table + ".flag13");
				select.addField(table + ".day14");
				select.addField(table + ".flag14");
				select.addField(table + ".day15");
				select.addField(table + ".flag15");
				select.addField(table + ".day16");
				select.addField(table + ".flag16");
				select.addField(table + ".day17");
				select.addField(table + ".flag17");
				select.addField(table + ".day18");
				select.addField(table + ".flag18");
				select.addField(table + ".day19");
				select.addField(table + ".flag19");
				select.addField(table + ".day20");
				select.addField(table + ".flag20");
				select.addField(table + ".day21");
				select.addField(table + ".flag21");
				select.addField(table + ".day22");
				select.addField(table + ".flag22");
				select.addField(table + ".day23");
				select.addField(table + ".flag23");
				select.addField(table + ".day24");
				select.addField(table + ".flag24");
				select.addField(table + ".day25");
				select.addField(table + ".flag25");
				select.addField(table + ".day26");
				select.addField(table + ".flag26");
				select.addField(table + ".day27");
				select.addField(table + ".flag27");
				select.addField(table + ".day28");
				select.addField(table + ".flag28");
				select.addField(table + ".day29");
				select.addField(table + ".flag29");
				select.addField(table + ".day30");
				select.addField(table + ".flag30");
				select.addField(table + ".day31");
				select.addField(table + ".flag31");
			}
			select.addTable(table);
			break;
		case __S_DAILY_WC:
			select = (DMISelectStatement)statement;
			select.addField("daily_wc.meas_num");
			select.addField("daily_wc.structure_num");
			select.addField("daily_wc.quality");
			select.addField("daily_wc.cal_year");
			select.addField("daily_wc.cal_mon");
			select.addField("daily_wc.irr_year");
			select.addField("daily_wc.irr_mon");
			select.addField("daily_wc.amt1");
			select.addField("daily_wc.obs1");
			select.addField("daily_wc.amt2");
			select.addField("daily_wc.obs2");
			select.addField("daily_wc.amt3");
			select.addField("daily_wc.obs3");
			select.addField("daily_wc.amt4");
			select.addField("daily_wc.obs4");
			select.addField("daily_wc.amt5");
			select.addField("daily_wc.obs5");
			select.addField("daily_wc.amt6");
			select.addField("daily_wc.obs6");
			select.addField("daily_wc.amt7");
			select.addField("daily_wc.obs7");
			select.addField("daily_wc.amt8");
			select.addField("daily_wc.obs8");
			select.addField("daily_wc.amt9");
			select.addField("daily_wc.obs9");
			select.addField("daily_wc.amt10");
			select.addField("daily_wc.obs10");
			select.addField("daily_wc.amt11");
			select.addField("daily_wc.obs11");
			select.addField("daily_wc.amt12");
			select.addField("daily_wc.obs12");
			select.addField("daily_wc.amt13");
			select.addField("daily_wc.obs13");
			select.addField("daily_wc.amt14");
			select.addField("daily_wc.obs14");
			select.addField("daily_wc.amt15");
			select.addField("daily_wc.obs15");
			select.addField("daily_wc.amt16");
			select.addField("daily_wc.obs16");
			select.addField("daily_wc.amt17");
			select.addField("daily_wc.obs17");
			select.addField("daily_wc.amt18");
			select.addField("daily_wc.obs18");
			select.addField("daily_wc.amt19");
			select.addField("daily_wc.obs19");
			select.addField("daily_wc.amt20");
			select.addField("daily_wc.obs20");
			select.addField("daily_wc.amt21");
			select.addField("daily_wc.obs21");
			select.addField("daily_wc.amt22");
			select.addField("daily_wc.obs22");
			select.addField("daily_wc.amt23");
			select.addField("daily_wc.obs23");
			select.addField("daily_wc.amt24");
			select.addField("daily_wc.obs24");
			select.addField("daily_wc.amt25");
			select.addField("daily_wc.obs25");
			select.addField("daily_wc.amt26");
			select.addField("daily_wc.obs26");
			select.addField("daily_wc.amt27");
			select.addField("daily_wc.obs27");
			select.addField("daily_wc.amt28");
			select.addField("daily_wc.obs28");
			select.addField("daily_wc.amt29");
			select.addField("daily_wc.obs29");
			select.addField("daily_wc.amt30");
			select.addField("daily_wc.obs30");
			select.addField("daily_wc.amt31");
			select.addField("daily_wc.obs31");
			select.addField("daily_wc.unit");
			select.addField("daily_wc.func");
			select.addField("daily_wc.div");
			select.addField("daily_wc.wd");
			select.addField("daily_wc.[id]");
			select.addField("daily_wc.s");
			select.addField("daily_wc.f");
			select.addField("daily_wc.u");
			select.addField("daily_wc.t");
			select.addTable("daily_wc");
			break;		
		case __S_DAM: 
			select = (DMISelectStatement)statement;
			select.addField("dam.res_num");
			select.addField("dam.staff_num");
			select.addField("dam.agency_num");
			select.addField("dam.owner_status");
			select.addField("dam.damid");
			select.addField("dam.natid");
			select.addField("dam.hazard_class");
			select.addField("dam.aband_code");
			select.addField("dam.remarks");
			select.addField("dam.down_town");
			select.addField("dam.down_town_dist");
			select.addField("dam.compl_year");
			select.addField("dam.purposes");
			select.addField("dam.fed_land");
			select.addField("dam.fed_regs");
			select.addField("dam.strm_code");
			select.addField("dam.dam_type");
			select.addField("dam.length");
			select.addField("dam.height");
			select.addField("dam.str_height");
			select.addField("dam.hyd_height");
			select.addField("dam.crest_width");
			select.addField("dam.crest_elev");
			select.addField("dam.spillway_capacity");
			select.addField("dam.outlet_capacity");
			select.addField("dam.forestid");
			select.addField("dam.phase1");
			select.addField("structure.structure_num");
			select.addField("structure.geoloc_num");
			if (version < VERSION_19990305) {
				select.addField("structure.aquifer_num");
				select.addField("structure.stream_num");
			}
			select.addField("structure.wdwater_num");
			select.addField("structure.div");
			select.addField("structure.wd");
			select.addField("structure.[id]");
			if (version < VERSION_19990305) {
				select.addField("structure.str_mile");
			}			
			select.addField("structure.ciu");
			select.addField("structure.str_type");
			select.addField("structure.str_name");
			select.addField("structure.est_capacity");
			select.addField("structure.est_unit");
			select.addField("structure.dcr_capacity");
			select.addField("structure.dcr_unit");
			select.addField("structure.STRTYPE");
			select.addField("structure.transbsn");
			select.addTable("dam");
			select.addTable("structure");			
			select.addWhereClause("dam.structure_num "
				+ "= structure.structure_num");
			break;
		case __S_DAM_INSPECTION:
			select = (DMISelectStatement)statement;
			select.addField("dam_inspection.dam_inspect_num");
			select.addField("dam_inspection.outlet_num");
			select.addField("dam_inspection.structure_num");
			select.addField("dam_inspection.damid");
			select.addField("dam_inspection.inspection_type");
			select.addField("dam_inspection.inspect_login");
			select.addField("dam_inspection.inspect_date");
			select.addTable("dam_inspection");
			break;
		case __S_DAM_OUTLET:
			select = (DMISelectStatement)statement;
			select.addField("dam_outlet.outlet_num");
			select.addField("dam_outlet.structure_num");
			select.addField("dam_outlet.damid");
			select.addField("dam_outlet.outlet_name");
			select.addField("dam_outlet.type");
			select.addField("dam_outlet.diameter");
			select.addField("dam_outlet.length");
			select.addField("dam_outlet.description");
			select.addField("dam_outlet.capacity");
			select.addTable("dam_outlet");
			break;
		case __S_DAM_SPILLWAY:
			select = (DMISelectStatement)statement;
			select.addField("dam_spillway.dam_spillway_num");
			select.addField("dam_spillway.structure_num");
			select.addField("dam_spillway.damid");
			select.addField("dam_spillway.spillway_name");
			select.addField("dam_spillway.width");
			select.addField("dam_spillway.freeboard");
			select.addField("dam_spillway.wall_side_slope");
			select.addField("dam_spillway.capacity");
			select.addField("dam_spillway.sply_type");
			select.addField("dam_spillway.sply_code");
			select.addTable("dam_spillway");
			break;
		case __S_DBVERSION:
		case __S_DBVERSION_FOR_VERSION_TYPE:
			select = (DMISelectStatement)statement;
			select.addField("db_version.version_num");
			select.addField("db_version.version_type");
			select.addField("db_version.version_id");
			select.addField("db_version.version_date");
			select.addField("db_version.version_comment");
			select.addTable("db_version");
			break;
		case __S_DIVERSION_COMMENT:
		case __S_DIVERSION_COMMENT_FOR_STRUCTURE_NUM:
			select= (DMISelectStatement)statement;
			select.addField("diversion_comment.meas_num");
			select.addField("diversion_comment.structure_num");
			select.addField("diversion_comment.not_used");
			select.addField("diversion_comment.comm_date");
			select.addField("diversion_comment.diver_comment");
			select.addField("diversion_comment.acres_irrig");
			select.addTable("diversion_comment");
			break;
		case __S_EMERGENCY_PLAN:
			select= (DMISelectStatement)statement;
			select.addField("emergency_plan.emer_plan_num");
			select.addField("emergency_plan.structure_num");
			select.addField("emergency_plan.eplan");
			select.addField("emergency_plan.ep_date");
			select.addTable("emergency_plan");
			break;
		case __S_EQUIPMENT:
			select = (DMISelectStatement)statement;
			select.addField("equipment.equip_num");
			select.addField("structure.structure_num");
			select.addField("equipment.date_installed");
			select.addField("equipment.meas_device");
			select.addField("equipment.recorder");
			select.addField("equipment.structure_num");
			select.addTable("equipment");
			select.addTable("structure");
			select.addWhereClause("equipment.structure_num "
				+ "= structure.structure_num");
			break;
		case __S_FROST_DATES:
			select = (DMISelectStatement)statement;
			select.addField("frost_dates.meas_num");
			select.addField("frost_dates.station_num");
			select.addField("frost_dates.cal_year");
			select.addField("frost_dates.l28s");
			select.addField("frost_dates.l32s");
			select.addField("frost_dates.f32f");
			select.addField("frost_dates.f28f");
			select.addTable("frost_dates");
			break;
		case __S_GENERAL_COMMENT:
			select = (DMISelectStatement)statement;		
			select.addField("general_comment." 
				+ "structure_num");
			if (version >= 19990305) {
				select.addField("general_comment.date_entered");
				select.addField("general_comment.comment");
			}
			else {
				select.addField("general_comment."
					+ "genl_comm_num");
				select.addField("general_comment.genl_comment");
				select.addField("general_comment.notes");
			}
			select.addTable("general_comment");
			break;
		case __S_GEOLOC:
		case __S_GEOLOC_FOR_HUC:
			select = (DMISelectStatement)statement;
			select.addField("geoloc.geoloc_num");
			select.addField("geoloc.utm_x");
			select.addField("geoloc.utm_y");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("geoloc.pm");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");
			select.addField("geoloc.tsa");
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");
			select.addField("geoloc.rnga");
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addField("geoloc.coordsns");
			select.addField("geoloc.coordsns_dir");
			select.addField("geoloc.coordsew");
			select.addField("geoloc.coordsew_dir");
			select.addField("geoloc.div");
			select.addField("geoloc.wd");
			select.addField("geoloc.[id]");
			select.addField("geoloc.county");
			select.addField("geoloc.topomap");
			select.addField("geoloc.cty");
			select.addField("geoloc.huc");
			if (version >= 20010326) {
				select.addField("geoloc.elev");
			} 
			else if (version >= 20000427) {
				select.addField("geoloc.elevation");
			} 
			else {
				// older database have elevation in station
			}
			select.addField("geoloc.loc_type");
			select.addField("geoloc.feature_type");
			select.addField("geoloc.accuracy");
			select.addField("geoloc.st");
			select.addField("geoloc.aquifer_num");
			select.addField("geoloc.stream_num");
			select.addField("geoloc.str_mile");
			select.addField("geoloc.loc_description");
			select.addField("geoloc.spotter_version");
			select.addField("geoloc.user_num");
			select.addTable("geoloc");
			break;
		case __S_LOC_TYPE:
			select = (DMISelectStatement)statement;
			select.addField("loc_type.loc_type");
			select.addField("loc_type.loc_type_desc");
			select.addTable("loc_type");
			break;
		case __S_MAPFILE:
			select = (DMISelectStatement)statement;
			select.addField("mapfile.mapfile_num");
			select.addField("mapfile.map_file_no");
			select.addField("mapfile.map_suffix");
			select.addField("mapfile.map_supp_stmt");
			select.addField("mapfile.map_file");
			select.addField("mapfile.map_file_date");
			select.addField("mapfile.structure_num");
			select.addTable("mapfile");
			break;
		case __S_MEAS_TYPE:
			select = (DMISelectStatement)statement;
			select.addField("meas_type.meas_num");
			select.addField("meas_type.station_num");
			select.addField("meas_type.meas_type");
			select.addField("meas_type.time_step");
			select.addField("meas_type.start_year");
			select.addField("meas_type.end_year");
			select.addField("meas_type.transmit");
			select.addField("meas_type.vax_field");
			select.addField("meas_type.meas_count");
			select.addField("meas_type.data_source");
			select.addTable("meas_type");
			break;
		case __S_MEAS_TYPE_DISTINCT:
			select = (DMISelectStatement)statement;
			select.addField("meas_type.meas_type");
			select.addField("meas_type.time_step");
			select.addField("meas_type.data_source");
			select.addField("meas_type.vax_field");
			select.addTable("meas_type");
			select.selectDistinct(true);
			break;
		case __S_MF_REACH:
			select = (DMISelectStatement)statement;
			select.addField("mf_reach.mfr_rate");
			select.addField("mf_reach.mfr_vol");
			select.addField("structure.structure_num");
			select.addField("structure.geoloc_num");
			if (version < VERSION_19990305) {
				select.addField("structure.aquifer_num");
				select.addField("structure.stream_num");
			}
			select.addField("structure.wdwater_num");
			select.addField("structure.div");
			select.addField("structure.wd");
			select.addField("structure.[id]");
			if (version < VERSION_19990305) {
				select.addField("structure.str_mile");
			}
			select.addField("structure.ciu");
			select.addField("structure.str_type");
			select.addField("structure.str_name");
			select.addField("structure.est_capacity");
			select.addField("structure.est_unit");
			select.addField("structure.dcr_capacity");
			select.addField("structure.dcr_unit");
			select.addField("structure.STRTYPE");
			select.addField("structure.transbsn");
			select.addTable("mf_reach");
			select.addTable("structure");
			select.addWhereClause("mf_reach.structure_num "
				+ "= structure.structure_num");
			break;
		case __S_MONTHLY_TOTAL_PCPN:
			select = (DMISelectStatement)statement;
			select.addField("monthly_pcpn.meas_num");
			select.addField("monthly_pcpn.station_num");
			select.addField("monthly_pcpn.cal_year");
			select.addField("monthly_pcpn.cal_mon_num");
			select.addField("monthly_pcpn.cal_mon");
			select.addField("monthly_pcpn.unit");
			select.addField("monthly_pcpn.total_pcpn");
			select.addTable("monthly_pcpn");
			break;
		case __S_MONTHLY_AVG_MAX_T:
		case __S_MONTHLY_AVG_MIN_T:
		case __S_MONTHLY_MEAN_T:		
			select = (DMISelectStatement)statement;
			select.addField("monthly_temp.meas_num");
			select.addField("monthly_temp.station_num");
			select.addField("monthly_temp.cal_year");
			select.addField("monthly_temp.cal_mon_num");
			select.addField("monthly_temp.cal_mon");
			select.addField("monthly_temp.unit");
			if (sqlNumber == __S_MONTHLY_AVG_MAX_T) {
				select.addField("monthly_temp.avg_max_t");
			} 
			else if (sqlNumber == __S_MONTHLY_AVG_MIN_T) {
				select.addField("monthly_temp.avg_min_t");
			}
			else {
				select.addField("monthly_temp.mean_t");
			}
			select.addTable("monthly_temp");
			break;			
		case __S_MONTHLY_TOTAL_EVAP:
			select = (DMISelectStatement)statement;
			select.addField("monthly_evap.meas_num");
			select.addField("monthly_evap.station_num");
			select.addField("monthly_evap.cal_year");
			select.addField("monthly_evap.cal_mon_num");
			select.addField("monthly_evap.cal_mon");
			select.addField("monthly_evap.unit");
			select.addField("monthly_evap.total_evap");
			select.addTable("monthly_evap");
			break;
		case __S_MONTHLY_TOTAL_SNOW:
			select = (DMISelectStatement)statement;
			select.addField("monthly_snow.meas_num");
			select.addField("monthly_snow.station_num");
			select.addField("monthly_snow.cal_year");
			select.addField("monthly_snow.cal_mon_num");
			select.addField("monthly_snow.cal_mon");
			select.addField("monthly_snow.unit");
			select.addField("monthly_snow.total_snow");
			select.addTable("monthly_snow");
			break;		
		case __S_MONTHLY_MAX_FLOW:
		case __S_MONTHLY_MIN_FLOW:
		case __S_MONTHLY_TOTAL_FLOW:
			select = (DMISelectStatement)statement;
			select.addField("monthly_flow.meas_num");
			select.addField("monthly_flow.station_num");
			select.addField("monthly_flow.cal_year");
			select.addField("monthly_flow.cal_mon_num");
			select.addField("monthly_flow.cal_mon");
			if (sqlNumber == __S_MONTHLY_MAX_FLOW) {
				select.addField("monthly_flow.max_q_cfs");
			}
			else if (sqlNumber == __S_MONTHLY_MIN_FLOW) {
				select.addField("monthly_flow.min_q_cfs");
			}
			else {
				select.addField("monthly_flow.total_q_af");
			}
			select.addTable("monthly_flow");
			break;		
		case __S_MONTHLY_TOTAL_NFLOW:
			select = (DMISelectStatement)statement;
			select.addField("monthly_nflow.meas_num");
			select.addField("monthly_nflow.station_num");
			select.addField("monthly_nflow.cal_year");
			select.addField("monthly_nflow.cal_mon_num");
			select.addField("monthly_nflow.cal_mon");
			select.addField("monthly_nflow.total_q_af");
			select.addTable("monthly_nflow");
			break;		
		case __S_NET_AMTS:
		case __S_NET_AMTS_FOR_WD_ID:
			select = (DMISelectStatement)statement;
			select.addField("net_amts.net_num");
			select.addField("net_amts.adj_date");
			select.addField("net_amts.padj_date");
			select.addField("net_amts.apro_date");
			select.addField("net_amts.admin_no");
			select.addField("net_amts.net_rate_abs");
			select.addField("net_amts.net_rate_apex");
			select.addField("net_amts.net_vol_abs");
			select.addField("net_amts.net_vol_apex");
			select.addField("net_amts.net_rate_cond");
			select.addField("net_amts.net_vol_cond");
			select.addField("net_amts.cty");
			select.addField("net_amts.div");
			select.addField("net_amts.[id]");
			select.addField("net_amts.order_no");
			select.addField("net_amts.sec");
			select.addField("net_amts.seca");
			select.addField("net_amts.wd");
			select.addField("net_amts.right_num");
			select.addField("net_amts.xwr_stream_no");
			select.addField("net_amts.adj_type");
			select.addField("net_amts.pm");
			select.addField("net_amts.pri_case_no");
			select.addField("net_amts.q10");
			select.addField("net_amts.q40");
			select.addField("net_amts.q160");
			select.addField("net_amts.rng");
			if (!getDatabaseEngine().equalsIgnoreCase("Access")
			    && version >= VERSION_20040701) {
				select.addField("net_amts.rdir");
			}
			else if (getDatabaseEngine().equalsIgnoreCase("Access")
			    && version > VERSION_20040701) {
				select.addField("net_amts.rdir");
			}			
			select.addField("net_amts.tab_trib");
			select.addField("net_amts.ts");
			if (!getDatabaseEngine().equalsIgnoreCase("Access")
			    && version >= VERSION_20040701) {
				select.addField("net_amts.tdir");
			}
			else if (getDatabaseEngine().equalsIgnoreCase("Access")
			    && version > VERSION_20040701) {
				select.addField("net_amts.tdir");
			}			
			select.addField("net_amts.[use]");
			select.addField("net_amts.wd_stream_name");
			select.addField("net_amts.wr_name");
			select.addField("net_amts.xstrtype");
			select.addField("net_amts.action_comment");
			select.addField("net_amts.unit");
			select.addField("net_amts.[abs]");
			select.addField("net_amts.apex");
			select.addField("net_amts.net_apex");
			select.addField("net_amts.cond");
			select.addField("net_amts.net_cond");
			select.addField("net_amts.net_abs");
			select.addField("net_amts.structure_num");
			select.addTable("net_amts");
			break;			
		case __S_PARCEL_USE_TS:
			select = (DMISelectStatement)statement;
			select.addField("parcel_use_ts.parcel_num");
			select.addField("parcel_use_ts.div");
			select.addField("parcel_use_ts.cal_year");
			select.addField("parcel_use_ts.parcel_id");
			select.addField("parcel_use_ts.perimeter");
			select.addField("parcel_use_ts.area");
			select.addField("parcel_use_ts.land_use");
			select.addField("parcel_use_ts.irrig_type");
			select.addTable("parcel_use_ts");
			break;		
		case __S_PARCEL_USE_TS_DISTINCT:
			select = (DMISelectStatement)statement;
			select.addField("parcel_use_ts.cal_year");
			select.addTable("parcel_use_ts");
			break;					
		case __S_PARCEL_USE_TS_STRUCTURE_TO_PARCEL_JOIN:
		case __S_PARCEL_USE_TS_STRUCTURE_TO_PARCEL_JOIN_FOR_CAL_YEAR:
			select = (DMISelectStatement)statement;
			select.addField("parcel_use_ts.parcel_num");
			select.addField("parcel_use_ts.div");
			select.addField("parcel_use_ts.cal_year");
			select.addField("parcel_use_ts.parcel_id");
			select.addField("parcel_use_ts.perimeter");
			select.addField("parcel_use_ts.area");
			select.addField("parcel_use_ts.land_use");
			select.addField("parcel_use_ts.irrig_type");
			select.addField("structure_to_parcel.structure_num");
			select.addField("structure_to_parcel.primary_flag");
			select.addField("structure_to_parcel.percent_irrig");
			select.addTable("parcel_use_ts");
			select.addTable("structure_to_parcel");
			select.addWhereClause("structure_to_parcel.parcel_num "
				+ "= parcel_use_ts.parcel_num");
			break;					
		case __S_PERSON_DETAILS:
			select = (DMISelectStatement)statement;
			select.addField("structure.structure_num");
			select.addField("structure.div");
			select.addField("structure.wd");
			select.addField("structure.[id]");
			select.addField("person_details.rolodex_num");
			select.addField("person_details.type");
			select.addField("person_details.note");
			if (version < VERSION_19990305) {
				select.addField("person_details.amount");
				select.addField("person_details.priority");
			}
			select.addTable("structure");
			select.addTable("person_details");
			select.addWhereClause("structure.structure_num "
				+ "= person_details.structure_num");
			break;
		case __S_PUMP_TEST:
			select = (DMISelectStatement)statement;
			select.addField("pump_test.structure_num");
			select.addField("pump_test.tswl");
			select.addField("pump_test.tfwl");
			select.addField("pump_test.testq");
			select.addField("pump_test.testtime");
			select.addField("pump_test.trans");
			select.addField("pump_test.k");
			select.addField("pump_test.storativity");
			select.addField("pump_test.leakance");
			select.addField("pump_test.toptestint");
			select.addField("pump_test.basetestint");
			select.addField("pump_test.drawdown");
			select.addField("pump_test.testdate");
			select.addField("pump_test.ptsource");
			select.addField("pump_test.pttype");
			select.addField("pump_test.ptmon");
			select.addField("pump_test.ptobs");
			select.addField("pump_test.ptmultiple");
			select.addField("structure.wd");
			select.addField("structure.[id]");
			select.addField("structure.str_name");
			select.addField("geoloc.pm");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addTable("pump_test");
			select.addTable("structure");
			select.addTable("geoloc");
			select.addWhereClause("structure.structure_num "
				+ "= pump_test.structure_num");
			select.addWhereClause("structure.geoloc_num "
				+ "= geoloc.geoloc_num");
			break;
		case __S_PUMP_TEST_VIEW:
			select = (DMISelectStatement)statement;
			select.addField("pump_test.structure_num");
			select.addField("pump_test.tswl");
			select.addField("pump_test.tfwl");
			select.addField("pump_test.testq");
			select.addField("pump_test.testtime");
			select.addField("pump_test.trans");
			select.addField("pump_test.k");
			select.addField("pump_test.storativity");
			select.addField("pump_test.leakance");
			select.addField("pump_test.toptestint");
			select.addField("pump_test.basetestint");
			select.addField("pump_test.drawdown");
			select.addField("pump_test.testdate");
			select.addField("pump_test.ptsource");
			select.addField("pump_test.pttype");
			select.addField("pump_test.ptmon");
			select.addField("pump_test.ptobs");
			select.addField("pump_test.ptmultiple");
			select.addField("pump_test.sp_cap");
			select.addField("structure.div");
			select.addField("structure.wd");
			select.addField("structure.[id]");
			select.addField("structure.str_name");
			select.addField("geoloc.UTM_x");
			select.addField("geoloc.UTM_y");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("geoloc.pm");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");
			select.addField("geoloc.tsa");
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");
			select.addField("geoloc.rnga");
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addTable("pump_test");
			select.addInnerJoin("structure",
				"structure.structure_num "
				+ "= pump_test.structure_num");
			select.addInnerJoin("geoloc",
				"geoloc.geoloc_num = structure.geoloc_num");
			select.addOrderByClause("structure.str_name");
			select.addOrderByClause("structure.[id]");
			break;
		case __S_REF_CIU:
			select = (DMISelectStatement)statement;
			select.addField("ref_ciu.code");
			select.addField("ref_ciu.description");
			select.addField("ref_ciu.rpt_code");
			if (version > VERSION_20040701) {
				select.addField("ref_ciu.short_desc");
			}
			select.addTable("ref_ciu");
			break;		
		case __S_REF_COUNTY:
			select = (DMISelectStatement)statement;
			table = "ref_county";
			if (version <= VERSION_20040701) {
				table = "county_ref";
			}
			select.addField(table + ".cty");
			select.addField(table + ".county");
			select.addField(table + ".fips_cty");
			select.addField(table + ".fips_st");
			select.addField(table + ".st");
			if (version < VERSION_19990305) {
				select.addField("county.abbrev");
			}
			select.addTable(table);
			break;			
		case __S_RES_EOM:
			select = (DMISelectStatement)statement;
			select.addField("res_eom.meas_num");
			select.addField("res_eom.structure_num");
			select.addField("res_eom.cal_year");
			select.addField("res_eom.cal_mon_num");
			select.addField("res_eom.cal_mon");
			select.addField("res_eom.total_af");
			select.addField("res_eom.data_src");
			select.addTable("res_eom");
			break;
		case __S_RES_MEAS:
			select = (DMISelectStatement)statement;
			select.addField("res_meas.meas_num");
			select.addField("res_meas.structure_num");
			select.addField("res_meas.date_time");
			select.addField("res_meas.gage_height");
			select.addField("res_meas.storage_amt");
			select.addField("res_meas.fill_amt");
			select.addField("res_meas.release_amt");
			select.addField("res_meas.evap_loss_amt");
			select.addTable("res_meas");
			break;
		case __S_RESERVOIR:
		case __S_RESERVOIR_FOR_STRUCTURE_NUM:
			select = (DMISelectStatement)statement;
			select.addField("structure.structure_num");
			if (version < VERSION_19990305) {
				select.addField("structure.aquifer_num");
				select.addField("structure.stream_num");
			}
			select.addField("structure.div");
			select.addField("structure.wd");
			select.addField("structure.[id]");
			if (version < VERSION_19990305) {
				select.addField("structure.str_mile");
			}
			select.addField("structure.str_name");
			select.addField("reservoir.max_storage");
			select.addField("reservoir.normal_storage");
			select.addField("reservoir.surface_area");
			select.addField("reservoir.drain_area");
			select.addTable("structure");
			select.addTable("reservoir");
			select.addWhereClause("reservoir.structure_num "
				+ "= structure.structure_num");
			break;
		case __S_ROLODEX_FOR_ROLODEX_NUM:
		case __S_ROLODEX_FOR_STRUCTURE_NUM:
			select = (DMISelectStatement)statement;
			select.addField("rolodex.rolodex_num");
			select.addField("rolodex.last_name");
			select.addField("rolodex.first_name");
			select.addField("rolodex.middle_name");
			select.addField("rolodex.title");
			select.addField("rolodex.prefix");
			select.addField("rolodex.suffix");
			select.addField("rolodex.full_name");
			select.addField("rolodex.address1");
			select.addField("rolodex.address2");
			select.addField("rolodex.city");
			select.addField("rolodex.st");
			select.addField("rolodex.zip");			
			if (version < VERSION_19990305) {
				select.addField("rolodex.zip_ext");
			}
			select.addField("rolodex.org_name");
			select.addField("rolodex.bond_co_name");
			if (version >= VERSION_19990305) {
				select.addField("rolodex.lic_no");
			}
//			select.addField("rolodex.xaoo");
//			select.addField("rolodex.xaoo2");
			select.addTable("rolodex");
			if (sqlNumber == __S_ROLODEX_FOR_STRUCTURE_NUM) {
				select.addTable("person_details");
				select.addWhereClause("rolodex.rolodex_num "
					+ "= person_details.rolodex_num");	
			}
			break;
		case __S_RT_MEAS:
			select = (DMISelectStatement)statement;
			select.addField("rt_meas.meas_num");
			select.addField("rt_meas.station_num");
			select.addField("rt_meas.date_time");
			select.addField("rt_meas.amt");
			select.addField("rt_meas.unit");
			select.addField("rt_meas.flag");
			select.addTable("rt_meas");
			break;
		case __S_WIS_SHEET_NAME_FOR_WIS_NUM:
			select = (DMISelectStatement)statement;
			table = "wis_sheet_name";
			if (version <= VERSION_20040701) {
				table = "sheet_name";
			}
			select.addField(table + ".wis_num");
			select.addField(table + ".sheet_name");
			select.addField(table + ".effective_date");
			select.addField(table + ".wd");
			select.addField(table + ".gain_method");
			select.addField(table + ".sheet_type");
			select.addField(table + ".comments");
			select.addTable(table);
			break;
		case __S_WIS_SHEET_NAME_DISTINCT:
			select = (DMISelectStatement)statement;
			table = "wis_sheet_name";
			if (version <= VERSION_20040701) {
				table = "sheet_name";
			}			
			select.addField(table + ".sheet_name");
			select.addField(table + ".wd");
			select.addTable(table);
			break;			
		case __W_WIS_SHEET_NAME:
			table = "wis_sheet_name";
			if (version <= VERSION_20040701) {
				table = "sheet_name";
			}					
			write = (DMIWriteStatement)statement;
//			write.addField("wis_num");
			write.addField("sheet_name");
			write.addField("effective_date");
			write.addField("wd");
			write.addField("gain_method");
			write.addField("sheet_type");
			write.addField("comments");
			write.addTable(table);
			break;			
		case __S_WIS_SHEET_NAME_WIS_FORMAT_DISTINCT:		
			table = "wis_sheet_name";
			if (version <= VERSION_20040701) {
				table = "sheet_name";
			}		
			select = (DMISelectStatement)statement;
			select.addField(table + ".sheet_name");
			select.addField("wis_format.identifier");
			select.addTable(table);
			select.addTable("wis_format");
			select.selectDistinct(true);
			select.addWhereClause(table + ".wis_num "
				+ "= wis_format.wis_num");
			break;			
		case __S_SMALL_DAM:
			select = (DMISelectStatement)statement;
			select.addField("small_dam.receipt");
			select.addField("small_dam.small_dam_type");
			select.addField("small_dam.appl_date");
			select.addField("small_dam.compl_date");
			select.addField("small_dam.title_no");
			select.addField("small_dam.outlet_size");
			select.addField("small_dam.outlet_type");
			select.addField("small_dam.height");
			select.addField("small_dam.spillway_height");
			select.addField("small_dam.spillway_width");
			select.addField("small_dam.drain_area");
			select.addField("small_dam.tank_capy");
			select.addField("structure.structure_num");
			select.addField("structure.geoloc_num");
			if (version < VERSION_19990305) {
				select.addField("structure.aquifer_num");
				select.addField("structure.stream_num");
			}
			select.addField("structure.wdwater_num");
			select.addField("structure.div");
			select.addField("structure.wd");
			select.addField("structure.[id]");
			if (version < VERSION_19990305) {
				select.addField("structure.str_mile");
			}
			select.addField("structure.ciu");
			select.addField("structure.str_type");
			select.addField("structure.str_name");
			select.addField("structure.est_capacity");
			select.addField("structure.est_unit");
			select.addField("structure.dcr_capacity");
			select.addField("structure.dcr_unit");
			select.addField("structure.STRTYPE");
			if (version >= VERSION_19990305) {
				select.addField("structure.transbsn");
			}
			else {
//				select.addField("structure.xtia");
			}
			select.addTable("small_dam");
			select.addTable("structure");
			select.addWhereClause("small_dam.structure_num "
				+ "= structure.structure_num");
			break;
		case __S_SNOW_CRSE:
			select = (DMISelectStatement)statement;
			select.addField("snow_crse.meas_num");
			select.addField("snow_crse.station_num");
			select.addField("snow_crse.cal_year");
			select.addField("snow_crse.cal_mon_num");
			select.addField("snow_crse.cal_mon");
			select.addField("snow_crse.day");
			select.addField("snow_crse.unit");
			select.addField("snow_crse.m_num");
			select.addField("snow_crse.m_type");
			select.addField("snow_crse.depth");
			select.addField("snow_crse.swe");
			select.addTable("snow_crse");
			break;
		case __S_STATION_FOR_STATION_ID:
			select = (DMISelectStatement)statement;
			select.addField("station.station_num");
			select.addField("station.geoloc_num");
			select.addField("station.station_name");
			select.addField("station.station_id");
			select.addField("station.drain_area");
			select.addField("station.contr_area");
			select.addField("station.source");
			select.addField("station.abbrev");
			if (version >= VERSION_19990305) {
				select.addField("station.transbsn");
				select.addField("station.nesdis_id");
			}
			else {
				select.addField("station.transmit");
			}
			select.addTable("station");
			break;
		case _S_STATION_GEOLOC:
		case __S_STATION_GEOLOC_FOR_STATION_ID:
			select = (DMISelectStatement)statement;
			select.addField("geoloc.geoloc_num");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("geoloc.pm");
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");
			select.addField("geoloc.tsa");
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");
			select.addField("geoloc.rnga");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addField("geoloc.coordsns");
			select.addField("geoloc.coordsew");
			select.addField("geoloc.county");
			select.addField("geoloc.topomap");
			select.addField("geoloc.cty");
			select.addField("geoloc.loc_type");
			select.addField("geoloc.huc");
			select.addField("geoloc.st");
			select.addField("station.station_num");
			select.addField("station.station_name");
			select.addField("station.station_id");
			select.addField("station.drain_area");
			select.addField("station.contr_area");
			if (version >= VERSION_20010326) {
				select.addField("geoloc.elev");
			} 
			else if (version >= VERSION_20000427) {
				select.addField("geoloc.elevation");
			} 
			else {
				select.addField("station.elevation");
			}
			select.addField("station.source");
			select.addField("station.abbrev");			
			if (version < VERSION_19990305) {
				select.addField("station.transmnt");
			}
			select.addField("geoloc.str_mile");
			select.addField("geoloc.wd");
			select.addField("geoloc.div");
			select.addField("geoloc.stream_num");
			select.addField("geoloc.[id]");
			if (version >= VERSION_19990305) {
				select.addField("station.transbsn");
				select.addField("station.nesdis_id");
				select.addField("geoloc.utm_x");
				select.addField("geoloc.utm_y");
				select.addField("geoloc.coordsns_dir");
				select.addField("geoloc.coordsew_dir");
				select.addField("geoloc.feature_type");
				select.addField("geoloc.accuracy");
			}
			select.addTable("station");
			select.addTable("geoloc");
			select.addWhereClause("station.geoloc_num "
				+ "= geoloc.geoloc_num");
			break;
		case __S_STATION_GEOLOC_CU_CLIM_WTS:
			// REVISIT (SAM) - FOR now I am including only what I
			// need from station and geoloc, but a full query should
			// be done to be consisting with the convention of
			// including all data when tables are joined.
			select = (DMISelectStatement)statement;
			select.addField("cu_clim_wts.hydrounit");
			select.addField("cu_clim_wts.county");
			select.addField("cu_clim_wts.station_num");
			select.addField("cu_clim_wts.cty");
			select.addField("cu_clim_wts.temp_wt");
			select.addField("cu_clim_wts.pcpn_wt");
			select.addField("station.station_id");
			select.addField("geoloc.latdecdeg");
			select.addTable("cu_clim_wts");
			select.addTable("station");
			select.addTable("geoloc");
			select.addWhereClause(
				"cu_clim_wts.station_num=station.station_num");
			select.addWhereClause(
				"station.geoloc_num=geoloc.geoloc_num");
			break;			
		case __S_STATION_GEOLOC_MEAS_TYPE_DISTINCT:
			distinct = true;
		case __S_STATION_GEOLOC_MEAS_TYPE:
			select = (DMISelectStatement)statement;
			select.addField("geoloc.geoloc_num");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("geoloc.pm");
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");
			select.addField("geoloc.tsa");
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");
			select.addField("geoloc.rnga");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addField("geoloc.coordsns");
			select.addField("geoloc.coordsew");
			select.addField("geoloc.county");
			select.addField("geoloc.topomap");
			select.addField("geoloc.cty");
			select.addField("geoloc.loc_type");
			select.addField("geoloc.huc");
			select.addField("geoloc.st");
			select.addField("station.geoloc_num");
			select.addField("station.station_num");
			select.addField("station.station_name");
			select.addField("station.station_id");
			select.addField("station.drain_area");
			select.addField("station.contr_area");
			if (version >= VERSION_20010326) {
				select.addField("geoloc.elev");
			}
			else if (version >= VERSION_20000427) {
				select.addField("geoloc.elevation");
			} 
			else {
				select.addField("station.elevation");
			}
			select.addField("station.source");
			select.addField("station.abbrev");
			if (version < VERSION_19990305) {
				select.addField("station.transmnt");
			}
			select.addField("geoloc.wd");
			select.addField("geoloc.div");
			select.addField("station.station_name");
			if (!distinct) {
				select.addField("meas_type.meas_num");
			}
			select.addField("meas_type.meas_type");
			if (!distinct) {
				select.addField("meas_type.time_step");
				select.addField("meas_type.start_year");
				select.addField("meas_type.end_year");
				select.addField("meas_type.transmit");
				select.addField("meas_type.vax_field");
				select.addField("meas_type.meas_count");
			}
			select.addField("meas_type.data_source");
			if (version >= VERSION_19990305) {
				select.addField("station.transbsn");
				select.addField("station.nesdis_id");
				select.addField("geoloc.utm_x");
				select.addField("geoloc.utm_y");
				select.addField("geoloc.coordsns_dir");
				select.addField("geoloc.coordsew_dir");
				select.addField("geoloc.feature_type");
				select.addField("geoloc.accuracy");
			}
			select.addTable("station");
			select.addTable("geoloc");
			select.addTable("meas_type");
			select.addWhereClause("geoloc.geoloc_num "
				+ "= station.geoloc_num");
			select.addWhereClause("station.station_num "
				+ "= meas_type.station_num");
			break;
		case __S_STATION_VIEW:
			select = (DMISelectStatement)statement;
			select.addField("station.station_num");
			select.addField("station.geoloc_num");
			select.addField("station.station_name");
			select.addField("station.station_id");
			if (version >= VERSION_20040701) {
				select.addField("station.cooperator_id");
			}
			select.addField("station.nesdis_id");
			select.addField("station.drain_area");
			select.addField("station.contr_area");
			select.addField("station.source");
			select.addField("station.abbrev");
			select.addField("station.transbsn");
			select.addField("geoloc.UTM_x");
			select.addField("geoloc.UTM_y");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("geoloc.div");
			select.addField("geoloc.wd");
			select.addField("geoloc.county");
			select.addField("geoloc.topomap");
			select.addField("geoloc.cty");
			select.addField("geoloc.huc");
			select.addField("geoloc.elev");
			select.addField("geoloc.loc_type");
			select.addField("geoloc.accuracy");
			select.addField("geoloc.st");
			select.addTable("station");
			select.addInnerJoin("geoloc",
				"geoloc.geoloc_num = station.geoloc_num");
			break;
		case __S_STATION_MEAS_TYPE_VIEW:
			select = (DMISelectStatement)statement;
			select.addField("station.station_num");
			select.addField("station.geoloc_num");
			select.addField("station.station_name");
			select.addField("station.station_id");
			if (version >= VERSION_20040701) {
				select.addField("station.cooperator_id");
			}
			select.addField("station.nesdis_id");
			select.addField("station.drain_area");
			select.addField("station.contr_area");
			select.addField("station.source");
			select.addField("station.abbrev");
			select.addField("station.transbsn");
			select.addField("meas_type.meas_num");
			select.addField("meas_type.meas_type");
			select.addField("meas_type.time_step");
			select.addField("meas_type.start_year");
			select.addField("meas_type.end_year");
			select.addField("meas_type.vax_field");
			select.addField("meas_type.transmit");
			select.addField("meas_type.meas_count");
			select.addField("meas_type.data_source");
			select.addField("geoloc.UTM_x");
			select.addField("geoloc.UTM_y");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("geoloc.div");
			select.addField("geoloc.wd");
			select.addField("geoloc.county");
			select.addField("geoloc.topomap");
			select.addField("geoloc.cty");
			select.addField("geoloc.huc");
			select.addField("geoloc.elev");
			select.addField("geoloc.loc_type");
			select.addField("geoloc.accuracy");
			select.addField("geoloc.st");
			select.addTable("station");
			select.addInnerJoin("meas_type",
				"meas_type.station_num = station.station_num");
			select.addInnerJoin("geoloc",
				"geoloc.geoloc_num = station.geoloc_num");
			break;
		case __S_STATION_MEAS_TYPE_DISTINCT_VIEW:
			select = (DMISelectStatement)statement;
			select.addField("station.station_num");
			select.addField("station.geoloc_num");
			select.addField("station.station_name");
			select.addField("station.station_id");
			if (version >= VERSION_20040701) {
				select.addField("station.cooperator_id");
			}
			select.addField("station.nesdis_id");
			select.addField("station.drain_area");
			select.addField("station.contr_area");
			select.addField("station.source");
			select.addField("station.abbrev");
			select.addField("station.transbsn");
			select.addField("meas_type.meas_type");
			select.addField("meas_type.data_source");
			select.addField("geoloc.UTM_x");
			select.addField("geoloc.UTM_y");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("geoloc.div");
			select.addField("geoloc.wd");
			select.addField("geoloc.county");
			select.addField("geoloc.topomap");
			select.addField("geoloc.cty");
			select.addField("geoloc.huc");
			select.addField("geoloc.elev");
			select.addField("geoloc.loc_type");
			select.addField("geoloc.accuracy");
			select.addField("geoloc.st");
			select.addTable("station");
			select.addInnerJoin("meas_type",
				"meas_type.station_num = station.station_num");
			select.addInnerJoin("geoloc",
				"geoloc.geoloc_num = station.geoloc_num");
			break;			
		case __S_STR_TYPE:
			select = (DMISelectStatement)statement;
			if (version > VERSION_20040701) {
				select.addField("ref_Structure_Type.str_type");
				select.addField(
					"ref_Structure_Type.str_type_desc");
				select.addField("ref_Structure_Type.rpt_code");
				select.addTable("ref_Structure_Type");
			}
			else {
				select.addField("str_type.str_type");
				select.addField("str_type.str_type_desc");
				select.addField("str_type.rpt_code");
				select.addTable("str_type");
			}
			break;
		case __S_STREAM_FOR_WD:
		case __S_STREAM_FOR_STREAM_NUM:
		case __S_STREAM_FOR_WD_STR_TRIB_TO:
			select = (DMISelectStatement)statement;
			select.addField("stream.stream_num");
			select.addField("stream.stream_name");
			select.addField("stream.str_trib_to");
			select.addField("stream.str_mile");
			select.addTable("legacy_stream");	
			select.addTable("stream");	
			select.addWhereClause("legacy_stream.stream_num "
				+ "= stream.stream_num");
			break;
		case __S_STRUCT_MEAS_TYPE_DISTINCT_2:
			select = (DMISelectStatement)statement;
			select.addField("struct_meas_type.meas_type");
			select.addField("struct_meas_type.time_step");
			select.addField("struct_meas_type.data_source");
			select.addTable("struct_meas_type");
			select.selectDistinct(true);
			break;		
		case __S_STRUCT_MEAS_TYPE_DISTINCT:
		case __S_STRUCT_MEAS_TYPE:
		case __S_STRUCT_MEAS_TYPE_FOR_STRUCTURE_NUM:
		case __S_STRUCT_MEAS_TYPE_FOR_STRUCTURE_NUM_MEAS_TYPE:
			select = (DMISelectStatement)statement;
			select.addField("struct_meas_type.meas_num");
			select.addField("structure.structure_num");
			select.addField("struct_meas_type.meas_type");
			select.addField("struct_meas_type.time_step");
			select.addField("struct_meas_type.start_year");
			select.addField("struct_meas_type.end_year");
			select.addField("struct_meas_type.transmit");
			select.addField("struct_meas_type.meas_count");
			select.addField("struct_meas_type.data_source");
			select.addField("structure.str_name");
			select.addField("structure.wd");
			select.addField("structure.[id]");
			select.addField("struct_meas_type.identifier");
			select.addTable("struct_meas_type");
			select.addTable("structure");
			select.addWhereClause("struct_meas_type.structure_num "
				+ "= structure.structure_num");
			break;
		case __S_STRUCT_MEAS_TYPE_VIEW:
			select = (DMISelectStatement)statement;
			select.addField("structure.div");
			select.addField("structure.wd");
			select.addField("structure.id");
			select.addField("structure.str_name");
			select.addField("geoloc.UTM_x");
			select.addField("geoloc.UTM_y");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("geoloc.pm");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");
			select.addField("geoloc.tsa");
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");
			select.addField("geoloc.rnga");
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addField("geoloc.coordsns");
			select.addField("geoloc.coordsns_dir");
			select.addField("geoloc.coordsew");
			select.addField("geoloc.coordsew_dir");
			select.addField("geoloc.county");
			select.addField("geoloc.topomap");
			select.addField("geoloc.cty");
			select.addField("geoloc.huc");
			select.addField("geoloc.elev");
			select.addField("geoloc.loc_type");
			select.addField("geoloc.st");
			select.addField("geoloc.str_mile");
			select.addField("struct_meas_type.meas_num");
			select.addField("struct_meas_type.structure_num");
			select.addField("struct_meas_type.meas_type");
			select.addField("struct_meas_type.time_step");
			select.addField("struct_meas_type.start_year");
			select.addField("struct_meas_type.end_year");
			select.addField("struct_meas_type.identifier");
			select.addField("struct_meas_type.transmit");
			select.addField("struct_meas_type.meas_count");
			select.addField("struct_meas_type.data_source");
			select.addTable("structure");
			select.addInnerJoin("geoloc",
				"geoloc.geoloc_num = structure.geoloc_num");
			select.addInnerJoin("struct_meas_type",
				"struct_meas_type.structure_num "
				+ "= structure.structure_num");
			break;
		case __S_STRUCTURE_AKA:
			select = (DMISelectStatement)statement;
			select.addField("structure_aka.structure_aka_num");
			select.addField("structure_aka.structure_num");
			select.addField("structure_aka.structure_aka_name");
			select.addField("structure.wd");
			select.addField("structure.[id]");
			select.addField("structure.div");
			select.addTable("structure");
			select.addTable("structure_aka");
			select.addWhereClause("structure_aka.structure_num "
				+ "= structure.structure_num");
			break;
		case __S_STRUCTURE_GEOLOC_LIST_FOR_WDID:
			select = (DMISelectStatement)statement;
			select.addField("structure.structure_num");
			select.addField("structure.wdwater_num");
			select.addField("structure.geoloc_num");
			select.addField("structure.div");
			select.addField("structure.wd");
			select.addField("structure.id");
			select.addField("structure.ciu");
			select.addField("structure.str_type");
			select.addField("structure.STRTYPE");
			select.addField("structure.str_name");
			select.addField("structure.est_capacity");
			select.addField("structure.est_unit");
			select.addField("structure.dcr_capacity");
			select.addField("structure.dcr_unit");
			select.addField("structure.transbsn");
			select.addField("geoloc.geoloc_num");
			select.addField("geoloc.utm_x");
			select.addField("geoloc.utm_y");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("geoloc.pm");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");
			select.addField("geoloc.tsa");
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");
			select.addField("geoloc.rnga");
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addField("geoloc.coordsns");
			select.addField("geoloc.coordsns_dir");
			select.addField("geoloc.coordsew");
			select.addField("geoloc.coordsew_dir");
			select.addField("geoloc.div");
			select.addField("geoloc.wd");
			select.addField("geoloc.id");
			select.addField("geoloc.county");
			select.addField("geoloc.topomap");
			select.addField("geoloc.cty");
			select.addField("geoloc.huc");
			select.addField("geoloc.elev");
			select.addField("geoloc.loc_type");
			select.addField("geoloc.feature_type");
			select.addField("geoloc.accuracy");
			select.addField("geoloc.st");
			select.addField("geoloc.aquifer_num");
			select.addField("geoloc.stream_num");
			select.addField("geoloc.str_mile");
			select.addField("geoloc.loc_description");
			select.addField("geoloc.spotter_version");

			select.addTable("Structure");
			select.addTable("Geoloc");
			select.addWhereClause (
			"Structure.geoloc_num = Geoloc.geoloc_num");
			break;
		case __S_STRUCTURE_GEOLOC_STRUCT_MEAS_TYPE_DISTINCT:
			distinct = true;
		case __S_STRUCTURE_GEOLOC_STRUCT_MEAS_TYPE:
			select = (DMISelectStatement)statement;
			select.addField("structure.wd");
			select.addField("structure.[id]");
			select.addField("structure.str_name");
			select.addField("geoloc.pm");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");			
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");			
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addField("struct_meas_type.start_year");
			select.addField("struct_meas_type.end_year");
			select.addField("struct_meas_type.meas_num");
			select.addField("struct_meas_type.meas_type");
			select.addField("struct_meas_type.time_step");
			select.addField("struct_meas_type.identifier");
			select.addField("struct_meas_type.meas_count");
			select.addField("struct_meas_type.data_source");
			select.addField("structure.structure_num");
			select.addTable("structure");
			select.addTable("geoloc");
			select.addTable("struct_meas_type");
			select.addWhereClause(
				"geoloc.geoloc_num = structure.geoloc_num");
			select.addWhereClause("structure.structure_num "
				+ "= struct_meas_type.structure_num");
			break;
		case __S_STRUCTURE_GEOLOC_STRUCT_MEAS_TYPE_2:
			select = (DMISelectStatement)statement;
			select.addField("structure.wd");
			select.addField("structure.[id]");
			select.addField("structure.str_name");
			select.addField("geoloc.pm");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");			
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");			
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addField("struct_meas_type.start_year");
			select.addField("struct_meas_type.end_year");
			select.addField("structure.structure_num");
			select.addTable("structure");
			select.addTable("geoloc");
			select.addTable("struct_meas_type");
			select.addWhereClause(
				"geoloc.geoloc_num = structure.geoloc_num");
			select.addWhereClause("structure.structure_num "
				+ "= struct_meas_type.structure_num");
			break;
		case __S_STRUCTURE_IRRIG_SUMMARY_JOIN:
		case __S_STRUCTURE_IRRIG_SUMMARY_JOIN_FOR_STRUCTURE_NUM:
			select = (DMISelectStatement)statement;
			select.addField("structure.structure_num");
			select.addField("structure.geoloc_num");
			select.addField("structure.wdwater_num");
			select.addField("structure.div");
			select.addField("structure.wd");
			select.addField("structure.[id]");
			select.addField("structure.ciu");
			select.addField("structure.str_type");
			select.addField("structure.str_name");
			select.addField("structure.est_capacity");
			select.addField("structure.est_unit");
			select.addField("structure.dcr_capacity");
			select.addField("structure.dcr_unit");
			select.addField("structure.STRTYPE");
			select.addField("irrig_summary.tia_gis");
			select.addField("irrig_summary.tia_gis_calyear");
			select.addField("irrig_summary.tia_div");
			select.addField("irrig_summary.tia_div_calyear");
			select.addField("irrig_summary.tia_struct");
			select.addField("irrig_summary.tia_struct_calyear");
			select.addTable("structure");
			// Want to make sure to return records, even if
			// irrig_summary
			select.addLeftJoin("irrig_summary",
			"structure.structure_num=irrig_summary.structure_num");
			break;
		case __S_STRUCTURE:
		case __S_STRUCTURE_FOR_STRUCTURE_NUM:
		case __S_STRUCTURE_LIST_FOR_WDID:
			select = (DMISelectStatement)statement;
			select.addField("Structure.ciu");
			select.addField("Structure.dcr_capacity");
			select.addField("Structure.dcr_unit");
			select.addField("Structure.div");
			select.addField("Structure.est_capacity");
			select.addField("Structure.est_unit");
			select.addField("Structure.geoloc_num");
			select.addField("Structure.[id]");
			select.addField("Structure.str_name");
			select.addField("Structure.str_type");
			select.addField("Structure.STRTYPE");
			select.addField("Structure.structure_num");
			select.addField("Structure.transbsn");
			select.addField("Structure.wd");
			select.addField("Structure.wdwater_num");
			select.addField("structure.xtia");
			select.addTable("Structure");
			break;
		case __S_STRUCTURE_GEOLOC:
		case __S_STRUCTURE_GEOLOC_FOR_STRUCTURE_NUM:
			select = (DMISelectStatement)statement;
			select.addField("geoloc.geoloc_num");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("geoloc.pm");
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");
			select.addField("geoloc.tsa");
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");
			select.addField("geoloc.rnga");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addField("geoloc.coordsns");
			select.addField("geoloc.coordsew");
			select.addField("geoloc.county");
			select.addField("geoloc.topomap");
			select.addField("geoloc.cty");
			select.addField("geoloc.loc_type");
			select.addField("geoloc.huc");
			if (version >= VERSION_20010326) {
				select.addField("geoloc.elev");
			}
			else if (version >= VERSION_20000301) {
				select.addField("geoloc.elevation");
			}
			else {
				//
			}
			select.addField("geoloc.st");
			select.addField("structure.structure_num");
			select.addField("structure.geoloc_num");
			if (version < VERSION_19990305) {
				select.addField("structure.aquifer_num");
			}
			select.addField("geoloc.stream_num");
			select.addField("structure.wdwater_num");
			select.addField("structure.div");
			select.addField("structure.wd");
			select.addField("structure.[id]");
			select.addField("geoloc.str_mile");
			select.addField("structure.ciu");
			select.addField("structure.str_type");
			select.addField("structure.str_name");
			select.addField("structure.est_capacity");
			select.addField("structure.est_unit");
			select.addField("structure.dcr_capacity");
			select.addField("structure.dcr_unit");
			select.addField("structure.STRTYPE");
			if (version < VERSION_19990305) {
//				select.addField("structure.xtia");
			}
			select.addField("wd_water.strname");
			select.addField("rolodex.full_name");
			select.addField("person_details.rolodex_num");
			if (version >= VERSION_19990305) {
				select.addField("geoloc.utm_x");
				select.addField("geoloc.utm_y");
				select.addField("geoloc.coordsns_dir");
				select.addField("geoloc.coordsew_dir");
				select.addField("geoloc.feature_type");
				select.addField("geoloc.accuracy");
				select.addField("structure.transbsn");
				select.addField("geoloc.spotter_version");
			}
			select.addTable("geoloc");
			select.addTable("structure");
			select.addTable("wd_water");
			select.addTable("rolodex");
			select.addTable("person_details");
			select.addWhereClause("geoloc.geoloc_num "
				+ "= structure.geoloc_num");
			select.addWhereClause("wd_water.wdwater_num "
				+ "= structure.wdwater_num");
			select.addWhereClause("person_details.structure_num "
				+ "= structure.structure_num");	
			select.addWhereClause("person_details.rolodex_num "
				+ "= rolodex.rolodex_num");
			break;
		case __S_STRUCTURE_DISTINCT_WD:
			select = (DMISelectStatement)statement;
			select.addField("structure.wd");
			select.addTable("structure");
			break;
		case __S_STRUCTURE_IRRIG_SUMMARY_TS_JOIN:
			select = (DMISelectStatement)statement;
			select.addField("irrig_summary_ts.cal_year");
			select.addField("irrig_summary_ts.land_use");
			select.addField("irrig_summary_ts.acres_total");
			select.addField("irrig_summary_ts.acres_by_drip");
			select.addField("irrig_summary_ts.acres_by_flood");
			select.addField("irrig_summary_ts.acres_by_furrow");
			select.addField("irrig_summary_ts.acres_by_sprinkler");
			select.addField("Structure.ciu");
			select.addField("Structure.dcr_capacity");
			select.addField("Structure.dcr_unit");
			select.addField("Structure.div");
			select.addField("Structure.est_capacity");
			select.addField("Structure.est_unit");
			select.addField("Structure.geoloc_num");
			select.addField("Structure.[id]");
			select.addField("Structure.modified");
			select.addField("Structure.str_name");
			select.addField("Structure.str_type");
			select.addField("Structure.STRTYPE");
			select.addField("Structure.structure_num");
			select.addField("Structure.transbsn");
			select.addField("Structure.user_num");
			select.addField("Structure.wd");
			select.addField("Structure.wdwater_num");
			select.addTable("irrig_summary_ts");
			select.addTable("structure");
			select.addWhereClause("structure.structure_num=" +
					"irrig_summary_ts.structure_num");
			break;			
		case __S_STRUCTURE_IRRIG_SUMMARY_TS_JOIN_DISTINCT:
		case __S_STRUCTURE_IRRIG_SUMMARY_TS_JOIN_DISTINCT_SP:
			select = (DMISelectStatement)statement;
			// Put these in the same order as above.
			// Mainly this just avoids the cal_year and data fields
			// in the irrig_summary_ts table.
			select.addField("irrig_summary_ts.land_use");
			select.addField("Structure.ciu");
			select.addField("Structure.dcr_capacity");
			select.addField("Structure.dcr_unit");
			select.addField("Structure.div");
			select.addField("Structure.est_capacity");
			select.addField("Structure.est_unit");
			select.addField("Structure.geoloc_num");
			select.addField("Structure.[id]");
			select.addField("Structure.modified");
			select.addField("Structure.str_name");
			select.addField("Structure.str_type");
			select.addField("Structure.STRTYPE");
			select.addField("Structure.structure_num");
			select.addField("Structure.transbsn");
			select.addField("Structure.user_num");
			select.addField("Structure.wd");
			select.addField("Structure.wdwater_num");
			select.addTable("irrig_summary_ts");
			select.addTable("structure");
			select.addWhereClause("structure.structure_num=" +
					"irrig_summary_ts.structure_num");
			select.selectDistinct ( true);
			break;			
		case __S_STRUCTURE_VIEW:
			select = (DMISelectStatement)statement;
			select.addField("structure.structure_num");
			select.addField("structure.wdwater_num");
			select.addField("structure.geoloc_num");
			select.addField("structure.div");
			select.addField("structure.wd");
			select.addField("structure.id");
			select.addField("structure.ciu");
			select.addField("structure.str_type");
			select.addField("structure.strtype");
			select.addField("structure.str_name");
			select.addField("structure.est_capacity");
			select.addField("structure.est_unit");
			select.addField("structure.dcr_capacity");
			select.addField("structure.dcr_unit");
			select.addField("structure.transbsn");
			select.addField("structure.xtia");
			if (version > VERSION_20040701) {
				select.addField("ref_structure_type"
					+ ".str_type_desc");
			}
			else {
				select.addField("str_type.str_type_desc");
			}
			select.addField("geoloc.utm_x");
			select.addField("geoloc.utm_y");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("geoloc.pm");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");
			select.addField("geoloc.tsa");
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");
			select.addField("geoloc.rnga");
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addField("geoloc.coordsns");
			select.addField("geoloc.coordsns_dir");
			select.addField("geoloc.coordsew");
			select.addField("geoloc.coordsew_dir");
			select.addField("geoloc.county");
			select.addField("geoloc.topomap");
			select.addField("geoloc.cty");
			select.addField("geoloc.huc");
			select.addField("geoloc.elev");
			select.addField("geoloc.loc_type");
			select.addField("geoloc.accuracy");
			select.addField("geoloc.stream_num");
			select.addField("geoloc.str_mile");
			select.addField("geoloc.spotter_version");
			select.addField("wd_water.strno");
			select.addField("wd_water.strname");
			select.addField("wd_water.strtribto");
			select.addField("rolodex.rolodex_num");
			select.addField("rolodex.full_name");
			select.addField("rolodex.address1");
			select.addField("rolodex.address2");
			select.addField("rolodex.city");
			select.addField("rolodex.st");
			select.addField("rolodex.zip");
			select.addField("tia_gis");
			select.addField("tia_gis_calyear");
			select.addField("tia_div");
			select.addField("tia_div_calyear");
			select.addField("tia_struct");
			select.addField("tia_struct_calyear");
			if (version >= VERSION_20040701) {
				select.addField("structure_decree_summary"
					+ ".dcr_rate_abs");
				select.addField("structure_decree_summary"
					+ ".dcr_rate_cond");
				select.addField("structure_decree_summary"
					+ ".dcr_rate_APEX_abs");
				select.addField("structure_decree_summary"
					+ ".dcr_rate_APEX_cond");
				select.addField("structure_decree_summary"
					+ ".dcr_vol_abs");
				select.addField("structure_decree_summary"
					+ ".dcr_vol_cond");
				select.addField("structure_decree_summary"
					+ ".dcr_vol_APEX_abs");
				select.addField("structure_decree_summary"
					+ ".dcr_vol_APEX_cond");
				select.addField("dcr_rate_abs + dcr_rate_cond "
					+ "+ dcr_rate_APEX_abs + "
					+ "dcr_rate_APEX_cond AS "
					+ "dcr_rate_total");
				select.addField("dcr_vol_abs + dcr_vol_cond "
					+ "+ dcr_vol_APEX_abs +  "
					+ "dcr_vol_APEX_cond AS dcr_vol_total");
			}
			select.addTable("structure");
			if (version > VERSION_20040701) {
				select.addInnerJoin("ref_structure_type",
					"ref_structure_type.str_type "
					+ "= structure.str_type");
			}
			else {
				select.addInnerJoin("str_type",
					"str_type.str_type "
					+ "= structure.str_type");
			}
			select.addInnerJoin("geoloc",
				"geoloc.geoloc_num = structure.geoloc_num");
			select.addLeftJoin("wd_water",
				"wd_water.wdwater_num = structure.wdwater_num");
			select.addLeftJoin("person_details",
				"person_details.structure_num "
				+ "= structure.structure_num");
			select.addLeftJoin("rolodex",
				"rolodex.rolodex_num "
				+ "= person_details.rolodex_num");
			select.addLeftJoin("irrig_summary",
				"irrig_summary.structure_num " 
				+ "= structure.structure_num");
			if (version >= VERSION_20040701) {
				select.addLeftJoin("structure_decree_summary",
					"structure_decree_summary.structure_num"
					+ "= structure.structure_num");
			}
			break;
		case __S_STRUCTURE_IRRIG_SUMMARY_TS_VIEW:
			select = (DMISelectStatement)statement;
			select.addField("structure.structure_num");
			select.addField("structure.wdwater_num");
			select.addField("structure.geoloc_num");
			select.addField("structure.div");
			select.addField("structure.wd");
			select.addField("structure.id");
			select.addField("structure.ciu");
			select.addField("structure.str_type");
			select.addField("structure.strtype");
			select.addField("structure.str_name");
			select.addField("structure.est_capacity");
			select.addField("structure.est_unit");
			select.addField("structure.dcr_capacity");
			select.addField("structure.dcr_unit");
			select.addField("structure.transbsn");
			select.addField("structure.xtia");
			select.addField("geoloc.UTM_x");
			select.addField("geoloc.UTM_y");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("geoloc.pm");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");
			select.addField("geoloc.tsa");
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");
			select.addField("geoloc.rnga");
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addField("geoloc.coordsns");
			select.addField("geoloc.coordsns_dir");
			select.addField("geoloc.coordsew");
			select.addField("geoloc.coordsew_dir");
			select.addField("geoloc.county");
			select.addField("geoloc.topomap");
			select.addField("geoloc.cty");
			select.addField("geoloc.huc");
			select.addField("geoloc.elev");
			select.addField("geoloc.loc_type");
			select.addField("geoloc.accuracy");
			select.addField("geoloc.stream_num");
			select.addField("geoloc.str_mile");
			if (version >= VERSION_20040701) {
				select.addField("structure_decree_summary"
					+ ".dcr_rate_abs");
				select.addField("structure_decree_summary"
					+ ".dcr_rate_cond");
				select.addField("structure_decree_summary"
					+ ".dcr_rate_APEX_abs");
				select.addField("structure_decree_summary"
					+ ".dcr_rate_APEX_cond");
				select.addField("structure_decree_summary"
					+ ".dcr_vol_abs");
				select.addField("structure_decree_summary"
					+ ".dcr_vol_cond");
				select.addField("structure_decree_summary"
					+ ".dcr_vol_APEX_abs");
				select.addField("structure_decree_summary"
					+ ".dcr_vol_APEX_cond");
			}
			select.addField("irrig_summary_ts.cal_year");
			select.addField("irrig_summary_ts.land_use");
			select.addField("irrig_summary_ts.acres_total");
			select.addField("irrig_summary_ts.acres_by_drip");
			select.addField("irrig_summary_ts.acres_by_flood");
			select.addField("irrig_summary_ts.acres_by_furrow");
			select.addField("irrig_summary_ts.acres_by_sprinkler");
			if (version >= VERSION_20040701) {
				select.addField("irrig_summary_ts"
					+ ".acres_by_groundwater");
			}
			select.addTable("structure");
			select.addInnerJoin("geoloc",
				"geoloc.geoloc_num = structure.geoloc_num");
			if (version >= VERSION_20040701) {
				select.addLeftJoin("structure_decree_summary",
					"structure_decree_summary.structure_num"
					+ " = structure.structure_num");
			}
			select.addInnerJoin("irrig_summary_ts",
				"irrig_summary_ts.structure_num"
				+ " = structure.structure_num");
			break;
		case __S_STRUCTURE_IRRIG_SUMMARY_TS_DISTINCT_VIEW:
			select = (DMISelectStatement)statement;
			select.addField("structure.structure_num");
			select.addField("structure.wdwater_num");
			select.addField("structure.geoloc_num");
			select.addField("structure.div");
			select.addField("structure.wd");
			select.addField("structure.id");
			select.addField("structure.ciu");
			select.addField("structure.str_type");
			select.addField("structure.strtype");
			select.addField("structure.str_name");
			select.addField("structure.est_capacity");
			select.addField("structure.est_unit");
			select.addField("structure.dcr_capacity");
			select.addField("structure.dcr_unit");
			select.addField("structure.transbsn");
			select.addField("structure.xtia");
			select.addField("geoloc.UTM_x");
			select.addField("geoloc.UTM_y");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("geoloc.pm");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");
			select.addField("geoloc.tsa");
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");
			select.addField("geoloc.rnga");
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addField("geoloc.coordsns");
			select.addField("geoloc.coordsns_dir");
			select.addField("geoloc.coordsew");
			select.addField("geoloc.coordsew_dir");
			select.addField("geoloc.county");
			select.addField("geoloc.topomap");
			select.addField("geoloc.cty");
			select.addField("geoloc.huc");
			select.addField("geoloc.elev");
			select.addField("geoloc.loc_type");
			select.addField("geoloc.accuracy");
			select.addField("geoloc.stream_num");
			select.addField("geoloc.str_mile");
			if (version >= VERSION_20040701) {
				select.addField("structure_decree_summary"
					+ ".dcr_rate_abs");
				select.addField("structure_decree_summary"
					+ ".dcr_rate_cond");
				select.addField("structure_decree_summary"
					+ ".dcr_rate_APEX_abs");
				select.addField("structure_decree_summary"
					+ ".dcr_rate_APEX_cond");
				select.addField("structure_decree_summary"
					+ ".dcr_vol_abs");
				select.addField("structure_decree_summary"
					+ ".dcr_vol_cond");
				select.addField("structure_decree_summary"
					+ ".dcr_vol_APEX_abs");
				select.addField("structure_decree_summary"
					+ ".dcr_vol_APEX_cond");
			}
			select.addField("irrig_summary_ts.land_use");
			select.addTable("structure");
			select.addInnerJoin("geoloc",
				"geoloc.geoloc_num = structure.geoloc_num");
			if (version >= VERSION_20040701) {
				select.addLeftJoin("structure_decree_summary",
					"structure_decree_summary.structure_num"
					+ " = structure.structure_num");
			}
			select.addInnerJoin("irrig_summary_ts",
				"irrig_summary_ts.structure_num"
				+ " = structure.structure_num");
			break;
		case __S_TRANSACT:
		case __S_TRANSACT_FOR_STRUCTURE_NUM:
			select = (DMISelectStatement)statement;
			select.addField("transact.trans_num");
			select.addField("transact.div");
			select.addField("transact.tab_trib");
			select.addField("transact.wd");
			select.addField("transact.[id]");
			select.addField("transact.wr_name");
			select.addField("transact.xwr_stream_no");
			select.addField("transact.wd_stream_name");
			select.addField("transact.xstrtype");
			select.addField("transact.pm");
			select.addField("transact.ts");
			if (!getDatabaseEngine().equalsIgnoreCase("Access")
			    && version >= VERSION_20040701) {
				select.addField("transact.tdir");
			}
			else if (getDatabaseEngine().equalsIgnoreCase("Access")
			    && version > VERSION_20040701) {
				select.addField("transact.tdir");
			}			
			select.addField("transact.rng");
			if (!getDatabaseEngine().equalsIgnoreCase("Access")
			    && version >= VERSION_20040701) {
				select.addField("transact.rdir");
			}
			else if (getDatabaseEngine().equalsIgnoreCase("Access")
			    && version > VERSION_20040701) {
				select.addField("transact.rdir");
			}
			select.addField("transact.sec");
			select.addField("transact.seca");
			select.addField("transact.q160");
			select.addField("transact.q40");
			select.addField("transact.q10");
			select.addField("transact.cty");
			select.addField("transact.adj_date");
			select.addField("transact.padj_date");
			select.addField("transact.apro_date");
			select.addField("transact.admin_no");
			select.addField("transact.order_no");
			select.addField("transact.adj_type");
			select.addField("transact.[use]");
			select.addField("transact.rate_amt");
			select.addField("transact.vol_amt");
			select.addField("transact.status_type");
			select.addField("transact.transfer_type");
			select.addField("transact.assoc_type");
			select.addField("transact.aband");
			select.addField("transact.aug_role");
			select.addField("transact.prior_no");
			select.addField("transact.case_no");
			select.addField("transact.last_due_dil");
			select.addField("transact.action_comment");
			select.addField("transact.action_update");
			select.addField("transact.assoc_wd");
			select.addField("transact.assoc_id");
			select.addField("transact.plan_wd");
			select.addField("transact.plan_id");
			select.addField("transact.tran_wd");
			select.addField("transact.tran_id");
			select.addField("transact.right_num");
			select.addField("transact.wr_action_num");
			select.addField("transact.structure_num");
			select.addTable("transact");
			break;
		case __S_TSPRODUCT:
		case __S_TSPRODUCT_FOR_IDENTIFIER:
			select = (DMISelectStatement)statement;
			select.addField("tsproduct.TSProduct_num");
			select.addField("tsproduct.ProductGroup_num");
			select.addField("tsproduct.Identifier");
			select.addField("tsproduct.Name");
			select.addField("tsproduct.Comment");
			select.addField("tsproduct.User_num");
			select.addTable("tsproduct");
			break;
		case __W_TSPRODUCT_INSERT:
		case __W_TSPRODUCT_UPDATE:
			write = (DMIWriteStatement)statement;
			write.addField("ProductGroup_num");
			write.addField("Identifier");
			write.addField("Name");
			write.addField("Comment");
			write.addTable("tsproduct");
			break;
		case __S_TSPRODUCTPROPS:
			select = (DMISelectStatement)statement;
			select.addField("tsproductprops.TSProduct_num");
			select.addField("tsproductprops.Property");
			select.addField("tsproductprops.Sequence");
			select.addField("tsproductprops.Val");
			select.addTable("tsproductprops");
			break;
		case __W_TSPRODUCTPROPS:
			write = (DMIWriteStatement)statement;
			write.addField("TSProduct_num");
			write.addField("Property");
			write.addField("Value");
			write.addField("Sequence");
			write.addTable("tsproductprops");
			break;
		case __S_UNPERMITTED_WELLS:
			select = (DMISelectStatement)statement;
			select.addField("unpermitted_wells.structure_num");
			select.addField("unpermitted_wells.apinumber");
			select.addField("unpermitted_wells.oiloper");
			select.addField("unpermitted_wells.aquifer1");
			select.addField("unpermitted_wells.aquifer2");
			select.addField("unpermitted_wells.tperf");
			select.addField("unpermitted_wells.bperf");
			select.addField("unpermitted_wells.depth");
			select.addField("unpermitted_wells.elev");
			select.addField("unpermitted_wells.comment");
			select.addField("unpermitted_wells.usgs_id");
			select.addField("unpermitted_wells.local_well_num");
			select.addField("unpermitted_wells.usbr_id");
			select.addField("unpermitted_wells.sp_coord_n");
			select.addField("unpermitted_wells.sp_coord_e");
			select.addField("unpermitted_wells.usgs_net");
			select.addTable("unpermitted_wells");
			break;
		case __S_UNPERMITTED_WELL_STRUCT_MEAS_TYPE_VIEW:
			select = (DMISelectStatement)statement;
			select.addField("structure.div");
			select.addField("structure.wd");
			select.addField("structure.id");
			select.addField("structure.str_name");
			select.addField("geoloc.pm");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addField("struct_meas_type.start_year");
			select.addField("struct_meas_type.end_year");
			select.addField("unpermitted_wells.structure_num");
			select.addField("unpermitted_wells.usgs_id");
			select.addField("unpermitted_wells.usbr_id");
			select.addTable("structure");
			select.addInnerJoin("geoloc",
				"geoloc.geoloc_num = structure.geoloc_num");
			select.addInnerJoin("struct_meas_type",
				"struct_meas_type.structure_num"
				+ " = structure.structure_num");
			select.addInnerJoin("unpermitted_wells",
				"structure.structure_num" 
				+ " = unpermitted_wells.structure_num");
			break;
		case __S_USE:
			select = (DMISelectStatement)statement;
			select.addField("[use].xuse");
			select.addField("[use].[use]");
			select.addField("[use].use_def");
			select.addField("[use].ok_for_wr");
			select.addField("[use].rpt_code");
			select.addTable("[use]");
			break;
		case __S_USER_PREFERENCES:
			select = (DMISelectStatement)statement;
			select.addField("user_preferences.user_num");
			select.addField("user_preferences.preference");
			select.addField("user_preferences.pref_value");
			if (version < VERSION_19990305) {
				select.addField("user_preferences.application");
			}
			select.addTable("user_preferences");
			select.addTable("user_security");
			select.addWhereClause("user_preferences.user_num "
				+ "= user_security.user_num");
			break;
		case __S_USER_SECURITY:
		case __S_USER_SECURITY_FOR_USER_NUM:
			select = (DMISelectStatement)statement;
			select.addField("user_security.user_num");
			select.addField("user_security.login");
			select.addField("user_security.password");
			select.addField("user_security.permissions");
			select.addField("user_security.user_name");
			if (version >= VERSION_19990305) {
				select.addField("user_security.application");
				select.addField("user_security.team_num");
				select.addField("user_security.supervisor");
			}
			select.addTable("user_security");
			break;
		case __S_WATER_DISTRICT:
		case __S_WATER_DISTRICT_BY_DIV:
			select = (DMISelectStatement)statement;
			select.addField("water_district.div");
			select.addField("water_district.wd");
			select.addField("water_district.wd_name");
			select.addTable("water_district");
			break;
		case __S_WATER_DIVISION:
			select = (DMISelectStatement)statement;
			select.addField("water_division.div");
			select.addField("water_division.div_name");
			select.addTable("water_division");
			break;
		case __S_STRUCTURE_WD_WATER:
			select = (DMISelectStatement)statement;
			select.addField("wd_water.wdwater_num");
			select.addField("wd_water.wd");
			select.addField("wd_water.strno");
			select.addField("wd_water.strname");
			select.addField("wd_water.admingrp");
			select.addField("wd_water.strtribto");
			select.addField("wd_water.strmile");
			select.addField("structure.structure_num");
			select.addField("structure.div");
			select.addField("structure.id");
			select.addTable("wd_water");
			select.addTable("structure");
			select.addWhereClause("wd_water.wdwater_num "
				+ "= structure.wdwater_num");
			break;			
		case __S_WD_WATER_NO_STRUCTURE:
			select = (DMISelectStatement)statement;
			select.addField("wd_water.wdwater_num");
			select.addField("wd_water.wd");
			select.addField("wd_water.strno");
			select.addField("wd_water.strname");
			select.addField("wd_water.admingrp");
			select.addField("wd_water.strtribto");
			select.addField("wd_water.strmile");
			select.addTable("wd_water");
			break;
		case __S_WELL_APPLICATION:
		case __S_WELL_APPLICATION_GEOLOC:
			select = (DMISelectStatement)statement;
			select.addField("well_application.well_app_num");
			select.addField("well_application.structure_num");
			select.addField("well_application.gw_controller_num");
			select.addField("well_application.subdiv_num");
			select.addField("well_application.receipt");
			select.addField("well_application.pyield");
			select.addField("well_application.pdepth");
			select.addField("well_application.pacreft");
			select.addField("well_application.[user]");
			select.addField("well_application.case_no");
			select.addField("well_application.elev");
			select.addField("well_application.area_irr");
			select.addField("well_application.irr_meas");
			select.addField("well_application.comment");
			select.addField("well_application.wellxno");
			select.addField("well_application.wellxsuf");
			select.addField("well_application.wellxrpl");
			select.addField("well_application.well_name");
			select.addField("well_application.subdiv_name");
			select.addField("well_application.filing");
			select.addField("well_application.lot");
			select.addField("well_application.block");
			select.addField("well_application.parcel_size");
			select.addField("well_application.parcel_no");
			select.addField("well_application.aquifer1");
			select.addField("well_application.aquifer2");
			select.addField("well_application.use1");
			select.addField("well_application.use2");
			select.addField("well_application.use3");
			select.addField("well_application.driller_lic");
			select.addField("well_application.pump_lic");
			select.addField("well_application.actcode");
			select.addField("well_application.actdate");
			select.addField("well_application.statcode");
			select.addField("well_application.statdate");
			select.addField("well_application.trancode");
			select.addField("well_application.trandate");
			select.addField("well_application.permit_type_num");
			select.addField("well_application.permitno");
			select.addField("well_application.permitsuf");
			select.addField("well_application.permitrpl");
			select.addField("well_application.engineer");
			select.addField("well_application.statute");
			select.addField("well_application.tperf");
			select.addField("well_application.bperf");
			select.addField("well_application.abreq");
			select.addField("well_application.meter");
			select.addField("well_application.log");
			select.addField("well_application.md");
			select.addField("well_application.basin");
			select.addField("well_application.valid_permit");
			select.addField("well_application.npdate");
			select.addField("well_application.exdate");
			select.addField("well_application.noticedate");
			select.addField("well_application.yield");
			select.addField("well_application.acreft");
			select.addField("well_application.depth");
			select.addField("well_application.[level]");
			select.addField("well_application.qual");
			select.addField("well_application.well_type");
			select.addField("well_application.valid_struc");
			select.addField("well_application.pidate");
			select.addField("well_application.wadate");
			select.addField("well_application.sadate");
			select.addField("well_application.sbudate");
			select.addField("well_application.abrdate");
			select.addField("well_application.abcodate");
			select.addField("well_application.nwcdate");
			select.addField("well_application.nbudate");
			select.addField("well_application.wcdate");
			select.addField("well_application.pcdate");
			/*
			select.addField("well_application.xref_location");
			select.addField("well_application.xref_city");
			select.addField("well_application.xref_cty");
			select.addField("well_application.xref_owner_name");
			*/
			select.addField("well_application.div");
			select.addField("well_application.wd");
			select.addTable("well_application");
			select.addTable("geoloc");
			select.addWhereClause("well_application.geoloc_num "
				+ "= geoloc.geoloc_num");
			if (sqlNumber == __S_WELL_APPLICATION) {
				break;
			}
			select.addField("geoloc.geoloc_num");
			select.addField("geoloc.utm_x");
			select.addField("geoloc.utm_y");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("geoloc.pm");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");
			select.addField("geoloc.sec");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			break;
		case __S_WELL_APPLICATION_VIEW:
			boolean access = false;
			if (getDatabaseEngine().equalsIgnoreCase("Access")) {
				access = true;
			}
			select = (DMISelectStatement)statement;
			select.addField("well_application.receipt");
			select.addField("geoloc.div");
			select.addField("geoloc.cty");
			select.addField("well_application.permitno");
			select.addField("well_application.permitsuf");
			select.addField("well_application.permitrpl");
			if (access) {
				select.addField("well_application.actdate");
			}
			else {
				select.addField("CONVERT(nvarchar(10),"
					+ " well_application" 
					+ ".actdate, 101) AS actdate");
			}
			select.addField("well_application.actcode");
			select.addField("well_application.wd");
			select.addField("well_application.basin");
			select.addField("well_application.md");
			select.addField("rolodex.full_name");
			select.addField("rolodex.address1");
			select.addField("rolodex.address2");
			select.addField("rolodex.city");
			select.addField("rolodex.st");
			select.addField("rolodex.zip");
			select.addField("contact.phone_number");
			select.addField("geoloc.pm");
			select.addField("geoloc.rng");
			select.addField("geoloc.rnga");
			select.addField("geoloc.rdir");
			select.addField("geoloc.ts");
			select.addField("geoloc.tsa");
			select.addField("geoloc.tdir");
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addField("geoloc.coordsns");
			select.addField("geoloc.coordsns_dir");
			select.addField("geoloc.coordsew");
			select.addField("geoloc.coordsew_dir");
			select.addField("geoloc.utm_x");
			select.addField("geoloc.utm_y");
			select.addField("geoloc.latdecdeg");
			select.addField("geoloc.longdecdeg");
			select.addField("ref_loc_accuracy.[description] AS "
				+ "loc_source");
			select.addField("well_application.aquifer1");
			select.addField("well_application.aquifer2");
			select.addField("well_application.subdiv_name");
			select.addField("well_application.lot");
			select.addField("well_application.block");
			select.addField("well_application.filing");
			select.addField("well_application.engineer");
			select.addField("well_application.well_name");
			select.addField("well_application.use1");
			select.addField("well_application.use2");
			select.addField("well_application.use3");
			select.addField("well_application.driller_lic");
			select.addField("well_application.pump_lic");
	
			if (access) {
				select.addField("well_application.pidate");
				select.addField("well_application.statute");
				select.addField("well_application.statcode");
				select.addField("well_application.statdate");
				select.addField("well_application.npdate");
				select.addField("well_application.wadate");
				select.addField("well_application.trancode");
				select.addField("well_application.trandate");
				select.addField("well_application.sadate");
				select.addField("well_application.sbudate");
				select.addField("well_application.exdate");
				select.addField("well_application.abrdate");
				select.addField("well_application.abcodate");
			}
			else {
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".pidate, 101) AS pidate");
				select.addField("well_application.statute");
				select.addField("well_application.statcode");
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".statdate, 101) as statdate");
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".npdate, 101) as npdate");
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".wadate, 101) as wadate");
				select.addField("well_application.trancode");
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".trandate, 101) as trandate");
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".sadate, 101) as sadate");
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".sbudate, 101) as sbudate");
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".exdate, 101) as exdate");
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".abrdate, 101) as abrdate");
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".abcodate, 101) as abcodate");
			}
			select.addField("well_application.abreq");
			select.addField("well_application.acreft");
			select.addField("well_application.tperf");
			select.addField("well_application.bperf");
			select.addField("well_application.case_no");
			select.addField("well_application.yield");
			select.addField("well_application.depth");
			select.addField("well_application.level");
			select.addField("well_application.elev");
			select.addField("well_application.area_irr");
			select.addField("well_application.comment");
			select.addField("well_application.meter");
			select.addField("well_application.wellxno");
			select.addField("well_application.wellxsuf");
			select.addField("well_application.wellxrpl");
			if (access) {
				select.addField("well_application.nwcdate");
				select.addField("well_application.nbudate");
				select.addField("well_application.wcdate");
				select.addField("well_application.pcdate");
			}
			else {
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".nwcdate, 101) as nwcdate");
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".nbudate, 101) as nbudate");
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".wcdate, 101) as wcdate");
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".pcdate, 101) as pcdate");
			}
			select.addField("well_application.[log]");
			select.addField("well_application.qual");
			select.addField("well_application.[user] AS user1");
			select.addField("well_application.pyield");
			select.addField("well_application.pdepth");
			select.addField("well_application.pacreft");
			select.addField("well_application.well_type");
			select.addField("well_application.valid_permit");
			select.addField("well_application.parcel_size");
			if (access) {
				select.addField("well_application.noticedate");
			}
			else {
				select.addField("CONVERT(nvarchar(10), "
					+ "well_application"
					+ ".noticedate, 101) as noticedate");
			}
			select.addTable("well_application");
			select.addInnerJoin("geoloc", 
				"geoloc.geoloc_num "
				+ "= well_application.geoloc_num");
			select.addInnerJoin("well_app_rolodex",
				"well_app_rolodex.well_app_num "
				+ "= well_application.well_app_num");
			select.addInnerJoin("rolodex",
				"rolodex.rolodex_num "
				+ "= well_app_rolodex.rolodex_num");
			select.addInnerJoin("contact",
				"contact.rolodex_num = rolodex.rolodex_num");
			select.addLeftJoin("ref_loc_accuracy",
				"ref_loc_accuracy.loc_accuracy_num "
				+ "= geoloc.accuracy");
			break;
		case __S_WELL_MEAS:
			select = (DMISelectStatement)statement;
			select.addField("well_meas.meas_date");
			select.addField("well_meas.wat_level");
			select.addField("structure.structure_num");
			select.addField("well_meas.meas_num");
			select.addField("structure.wd");
			select.addField("structure.[id]");
			select.addField("structure.str_name");
			select.addField("geoloc.pm");
			select.addField("geoloc.ts");
			select.addField("geoloc.tdir");
			select.addField("geoloc.rng");
			select.addField("geoloc.rdir");
			select.addField("geoloc.sec");
			select.addField("geoloc.seca");
			select.addField("geoloc.q160");
			select.addField("geoloc.q40");
			select.addField("geoloc.q10");
			select.addTable("well_meas");			
			select.addTable("structure");
			select.addTable("geoloc");
			select.addWhereClause("structure.structure_num "
				+ "= well_meas.structure_num");
			select.addWhereClause("structure.geoloc_num "
				+ "= geoloc.geoloc_num");
			break;
		case __S_WELLS:
			select = (DMISelectStatement)statement;
			select.addField("wells.well_id");
			select.addField("wells.div");
			select.addField("wells.wd");
			select.addField("wells.[id]");
			select.addField("wells.receipt");
			select.addField("wells.permitno");
			select.addField("wells.permitsuf");
			select.addField("wells.permitrpl");
			select.addField("wells.well_name");
			select.addField("wells.yield");
			select.addField("wells.perm_date");
			select.addField("wells.appr_date");
			select.addField("wells.tperf");
			select.addField("wells.bperf");
			select.addField("wells.depth");
			select.addField("wells.aquifer1");
			select.addField("wells.flag");
			select.addField("wells.use1");
			select.addField("wells.use2");
			select.addField("wells.use3");
			select.addField("wells.ditches_served");
			select.addTable("wells");
			break;
		case __S_WELLS_LAYER:
			select = (DMISelectStatement)statement;
			select.addField("wells.well_id");
			select.addField("wells.div");
			select.addField("wells.wd");
			select.addField("wells.[id]");
			select.addField("wells.receipt");
			select.addField("wells.permitno");
			select.addField("wells.permitsuf");
			select.addField("wells.permitrpl");
			select.addField("wells.well_name");
			select.addField("wells.yield");
			select.addField("wells.perm_date");
			select.addField("wells.appr_date");
			select.addField("wells.tperf");
			select.addField("wells.bperf");
			select.addField("wells.depth");
			select.addField("wells.aquifer1");
			select.addField("wells.flag");
			select.addField("wells.use1");
			select.addField("wells.use2");
			select.addField("wells.use3");
			if (version >= VERSION_20000706) {
				select.addField("well_to_layer.layer");
				select.addField("well_to_layer.layer_per");
				select.addField("well_to_layer.est_id");
				select.addWhereClause("wells.well_id "
					+ "= well_to_layer.well_id");
				select.addField("wells.ditches_served");
			}
			else {
				select.addField("layers.layer");
				select.addField("layers.layer_per");
				select.addField("layers.est_id");
				select.addWhereClause("wells.well_id "
					+ "= layers.well_id");
			}
			select.addTable("wells");
			if (version >= VERSION_20000706) {
				select.addTable("well_to_layer");
			}
			else {
				select.addTable("layers");
			}
			break;
		case __S_WELLS_PARCEL:
			select = (DMISelectStatement)statement;
			select.addField("wells.well_id");
			select.addField("wells.div");
			select.addField("wells.wd");
			select.addField("wells.[id]");
			select.addField("wells.receipt");
			select.addField("wells.permitno");
			select.addField("wells.permitsuf");
			select.addField("wells.permitrpl");
			select.addField("wells.well_name");
			select.addField("wells.yield");
			select.addField("wells.perm_date");
			select.addField("wells.appr_date");
			select.addField("wells.tperf");
			select.addField("wells.bperf");
			select.addField("wells.depth");
			select.addField("wells.aquifer1");
			select.addField("wells.flag");
			select.addField("wells.use1");
			select.addField("wells.use2");
			select.addField("wells.use3");
			select.addField("well_to_parcel.parcel");
			select.addField("well_to_parcel.class");
			select.addField("well_to_parcel.distance");
			if (version >= VERSION_20000706) {
				select.addField("well_to_parcel."
					 + "prorated_yield");
				select.addField("well_to_parcel.percent_yield");
			}
			select.addTable("wells");
			if (version >= VERSION_20000706) {
				select.addTable("well_to_parcel");
			}
			else {
				select.addTable("well_parcel");
			}
			if (version >= VERSION_20040701) {
				select.addField("well_to_parcel.div");
				select.addField("well_to_parcel.cal_year");
				select.addField("well_to_parcel.parcel_id");
			}
			select.addWhereClause("wells.well_id "
				+ "= well_to_parcel.well_id");
			break;
		case __S_WELLS_STRUCTURE:
			select = (DMISelectStatement)statement;
			select.addField("wells.well_id");
			select.addField("wells.div");
			select.addField("wells.wd");
			select.addField("wells.[id]");
			select.addField("wells.receipt");
			select.addField("wells.permitno");
			select.addField("wells.permitsuf");
			select.addField("wells.permitrpl");
			select.addField("wells.well_name");
			select.addField("wells.yield");
			select.addField("wells.perm_date");
			select.addField("wells.appr_date");
			select.addField("wells.tperf");
			select.addField("wells.bperf");
			select.addField("wells.depth");
			select.addField("wells.aquifer1");
			select.addField("wells.flag");
			select.addField("wells.use1");
			select.addField("wells.use2");
			select.addField("wells.use3");
			if (version >= VERSION_20000706) {
				select.addField("well_to_structure."
					+ "structure_num");
				select.addField("well_to_structure.parcel");
				select.addField("well_to_structure.ditch_cov");
				select.addField("well_to_structure.str_wd");
				select.addField("well_to_structure.str_id");
				select.addWhereClause("wells.well_id "
					+ "= well_to_structure.well_id");
				select.addField("wells.ditches_served");
				select.addField("well_to_structure.ditch_id");
				select.addField("well_to_structure.cal_year");
				select.addField("well_to_structure.parcel_id");
			}
			else {
				select.addField("structure_to_well."
					+ "structure_num");
				select.addField("structure_to_well.parcel");
				select.addField("structure_to_well.ditch_cov");
				select.addField("structure_to_well.str_wd");
				select.addField("structure_to_well.str_id");
				select.addWhereClause("wells.well_id "
					+ "= structure_to_well.well_id");
			}		
			select.addTable("wells");
			if (version >= VERSION_20000706) {
				select.addTable("well_to_structure");
			}
			else {
				select.addTable("structure_to_well");
			}
			break;
		case __S_WELLS_PARCEL_STRUCTURE:
			select = (DMISelectStatement)statement;
			select.addField("wells.well_id");
			select.addField("wells.div");
			select.addField("wells.wd");
			select.addField("wells.[id]");
			select.addField("wells.receipt");
			select.addField("wells.permitno");
			select.addField("wells.permitsuf");
			select.addField("wells.permitrpl");
			select.addField("wells.well_name");
			select.addField("wells.yield");
			select.addField("wells.perm_date");
			select.addField("wells.appr_date");
			select.addField("wells.tperf");
			select.addField("wells.bperf");
			select.addField("wells.depth");
			select.addField("wells.aquifer1");
			select.addField("wells.flag");
			select.addField("wells.use1");
			select.addField("wells.use2");
			select.addField("wells.use3");
			select.addField("well_to_parcel.parcel");
			select.addField("well_to_parcel.class");
			select.addField("well_to_parcel.distance");
			select.addWhereClause("wells.well_id "
				+ "= well_to_parcel.well_id");
			if (version >= VERSION_20000706) {
				select.addField("well_to_parcel."
					+ "prorated_yield");
				select.addField("well_to_parcel.percent_yield");
				if (version >= VERSION_20040701) {
					select.addField("well_to_parcel.div");
					select.addField(
					"well_to_parcel.cal_year");
					select.addField(
					"well_to_parcel.parcel_id");
				}
				select.addField("well_to_structure."
					+ "structure_num");
				select.addField("well_to_structure.parcel");
				select.addField("well_to_structure.ditch_cov");
				select.addField("well_to_structure.str_wd");
				select.addField("well_to_structure.str_id");
				select.addWhereClause("wells.well_id "
					+ "= well_to_structure.well_id");
				select.addWhereClause("well_to_parcel.parcel = "
					+ "well_to_structure.parcel");

				select.addField("wells.ditches_served");
				select.addField("well_to_structure.ditch_id");
			}
			else {
				select.addField("structure_to_well."
					+ "structure_num");
				select.addField("structure_to_well.parcel");
				select.addField("structure_to_well.ditch_cov");
				select.addField("structure_to_well.str_wd");
				select.addField("structure_to_well.str_id");
				select.addWhereClause("wells.well_id "
					+ "= structure_to_well.well_id");
				select.addWhereClause("well_to_parcel.parcel = "
					+ "structure_to_well.parcel");	
			}
			select.addTable("wells");
			if (version >= VERSION_20000706) {
				select.addTable("well_to_parcel");
				select.addTable("well_to_structure");
			}
			else {
				select.addTable("well_parcel");
				select.addTable("structure_to_well");
			}
			break;			
		case __S_WIS_COMMENTS_FOR_WIS_NUM_SET_DATE:
			select = (DMISelectStatement)statement;
			select.addField("wis_comments.wis_num");
			select.addField("wis_comments.set_date");
			select.addField("wis_comments.archive_date");
			select.addField("wis_comments.comment");
			select.addTable("wis_comments");
			break;
		case __W_WIS_COMMENTS:
			write = (DMIWriteStatement)statement;
			write.addField("wis_num");
			write.addField("set_date");
			write.addField("archive_date");
			write.addField("comment");
			write.addTable("wis_comments");
			break;
		case __S_WIS_DAILY_WC:
			select = (DMISelectStatement)statement;
			select.addField("wis_daily_wc.meas_num");
			select.addField("wis_daily_wc.structure_num");
			select.addField("wis_daily_wc.quality");
			select.addField("wis_daily_wc.cal_year");
			select.addField("wis_daily_wc.cal_mon");
			select.addField("wis_daily_wc.irr_year");
			select.addField("wis_daily_wc.irr_mon");
			select.addField("wis_daily_wc.wis_num");
			select.addField("wis_daily_wc.wis_column");
			select.addField("wis_daily_wc.wis_dailywc_num");
			select.addField("wis_daily_wc.amt1");
			select.addField("wis_daily_wc.obs1");
			select.addField("wis_daily_wc.amt2");
			select.addField("wis_daily_wc.obs2");
			select.addField("wis_daily_wc.amt3");
			select.addField("wis_daily_wc.obs3");
			select.addField("wis_daily_wc.amt4");
			select.addField("wis_daily_wc.obs4");
			select.addField("wis_daily_wc.amt5");
			select.addField("wis_daily_wc.obs5");
			select.addField("wis_daily_wc.amt6");
			select.addField("wis_daily_wc.obs6");
			select.addField("wis_daily_wc.amt7");
			select.addField("wis_daily_wc.obs7");
			select.addField("wis_daily_wc.amt8");
			select.addField("wis_daily_wc.obs8");
			select.addField("wis_daily_wc.amt9");
			select.addField("wis_daily_wc.obs9");
			select.addField("wis_daily_wc.amt10");
			select.addField("wis_daily_wc.obs10");
			select.addField("wis_daily_wc.amt11");
			select.addField("wis_daily_wc.obs11");
			select.addField("wis_daily_wc.amt12");
			select.addField("wis_daily_wc.obs12");
			select.addField("wis_daily_wc.amt13");
			select.addField("wis_daily_wc.obs13");
			select.addField("wis_daily_wc.amt14");
			select.addField("wis_daily_wc.obs14");
			select.addField("wis_daily_wc.amt15");
			select.addField("wis_daily_wc.obs15");
			select.addField("wis_daily_wc.amt16");
			select.addField("wis_daily_wc.obs16");
			select.addField("wis_daily_wc.amt17");
			select.addField("wis_daily_wc.obs17");
			select.addField("wis_daily_wc.amt18");
			select.addField("wis_daily_wc.obs18");
			select.addField("wis_daily_wc.amt19");
			select.addField("wis_daily_wc.obs19");
			select.addField("wis_daily_wc.amt20");
			select.addField("wis_daily_wc.obs20");
			select.addField("wis_daily_wc.amt21");
			select.addField("wis_daily_wc.obs21");
			select.addField("wis_daily_wc.amt22");
			select.addField("wis_daily_wc.obs22");
			select.addField("wis_daily_wc.amt23");
			select.addField("wis_daily_wc.obs23");
			select.addField("wis_daily_wc.amt24");
			select.addField("wis_daily_wc.obs24");
			select.addField("wis_daily_wc.amt25");
			select.addField("wis_daily_wc.obs25");
			select.addField("wis_daily_wc.amt26");
			select.addField("wis_daily_wc.obs26");
			select.addField("wis_daily_wc.amt27");
			select.addField("wis_daily_wc.obs27");
			select.addField("wis_daily_wc.amt28");
			select.addField("wis_daily_wc.obs28");
			select.addField("wis_daily_wc.amt29");
			select.addField("wis_daily_wc.obs29");
			select.addField("wis_daily_wc.amt30");
			select.addField("wis_daily_wc.obs30");
			select.addField("wis_daily_wc.amt31");
			select.addField("wis_daily_wc.obs31");
			select.addField("wis_daily_wc.unit");
			select.addField("wis_daily_wc.func");
			select.addField("wis_daily_wc.div");
			select.addField("wis_daily_wc.wd");
			select.addField("wis_daily_wc.[id]");
			select.addField("wis_daily_wc.s");
			select.addField("wis_daily_wc.f");
			select.addField("wis_daily_wc.u");
			select.addField("wis_daily_wc.t");
			select.addTable("wis_daily_wc");
			break;				
		case __W_WIS_DAILY_WC:
			write = (DMIWriteStatement)statement;
			write.addField("meas_num");
			write.addField("structure_num");
			write.addField("quality");
			write.addField("cal_year");
			write.addField("cal_mon");
			write.addField("irr_year");
			write.addField("irr_mon");
			write.addField("wis_num");
			write.addField("wis_column");
			write.addField("wis_dailywc_num");
			write.addField("amt1");
			write.addField("obs1");
			write.addField("amt2");
			write.addField("obs2");
			write.addField("amt3");
			write.addField("obs3");
			write.addField("amt4");
			write.addField("obs4");
			write.addField("amt5");
			write.addField("obs5");
			write.addField("amt6");
			write.addField("obs6");
			write.addField("amt7");
			write.addField("obs7");
			write.addField("amt8");
			write.addField("obs8");
			write.addField("amt9");
			write.addField("obs9");
			write.addField("amt10");
			write.addField("obs10");
			write.addField("amt11");
			write.addField("obs11");
			write.addField("amt12");
			write.addField("obs12");
			write.addField("amt13");
			write.addField("obs13");
			write.addField("amt14");
			write.addField("obs14");
			write.addField("amt15");
			write.addField("obs15");
			write.addField("amt16");
			write.addField("obs16");
			write.addField("amt17");
			write.addField("obs17");
			write.addField("amt18");
			write.addField("obs18");
			write.addField("amt19");
			write.addField("obs19");
			write.addField("amt20");
			write.addField("obs20");
			write.addField("amt21");
			write.addField("obs21");
			write.addField("amt22");
			write.addField("obs22");
			write.addField("amt23");
			write.addField("obs23");
			write.addField("amt24");
			write.addField("obs24");
			write.addField("amt25");
			write.addField("obs25");
			write.addField("amt26");
			write.addField("obs26");
			write.addField("amt27");
			write.addField("obs27");
			write.addField("amt28");
			write.addField("obs28");
			write.addField("amt29");
			write.addField("obs29");
			write.addField("amt30");
			write.addField("obs30");
			write.addField("amt31");
			write.addField("obs31");
			write.addField("unit");
			write.addField("func");
			write.addField("div");
			write.addField("wd");
			write.addField("[id]");
			write.addField("s");
			write.addField("f");
			write.addField("u");
			write.addField("t");
			write.addTable("wis_daily_wc");			
			break;							
		case __S_WIS_DATA:
		case __S_WIS_DATA_FOR_WIS_NUM_SET_DATE:
			select = (DMISelectStatement)statement;
			select.addField("wis_data.wis_num");
			select.addField("wis_data.wis_row");
			select.addField("wis_data.set_date");
			select.addField("wis_data.point_flow");
			select.addField("wis_data.nat_flow");
			select.addField("wis_data.delivery_flow");
			select.addField("wis_data.gain");
			select.addField("wis_data.trib_natural");
			select.addField("wis_data.trib_delivery");
			select.addField("wis_data.priority_divr");
			select.addField("wis_data.delivery_divr");
			select.addField("wis_data.release");
			select.addField("wis_data.comment");
			if (version >= VERSION_19990305) {
				select.addField("wis_data.dry_river");
			}
			select.addTable("wis_data");
			break;
		case __W_WIS_DATA:
			write = (DMIWriteStatement)statement;
			write.addField("wis_num");
			write.addField("wis_row");
			write.addField("set_date");
			write.addField("point_flow");
			write.addField("nat_flow");
			write.addField("delivery_flow");
			write.addField("gain");
			write.addField("trib_natural");
			write.addField("trib_delivery");
			write.addField("priority_divr");
			write.addField("delivery_divr");
			write.addField("release");
			write.addField("comment");
			if (version >= VERSION_19990305) {
				write.addField("dry_river");
			}
			write.addTable("wis_data");
			break;
		case __S_WIS_FORMAT:
			select = (DMISelectStatement)statement;
			select.addField("wis_format.wis_num");
			select.addField("wis_format.wis_row");
			select.addField("wis_format.row_label");
			select.addField("wis_format.row_type");
			select.addField("wis_format.known_point");
			select.addField("wis_format.wdwater_num");
			select.addField("wis_format.wdwater_link");
			select.addField("wis_format.str_mile");
			select.addField("wis_format.structure_num");
			select.addField("wis_format.station_num");
			select.addField("wis_format.identifier");
			select.addField("wis_format.gain_factor");
			select.addTable("wis_format");
			break;
		case __W_WIS_FORMAT:
			write = (DMIWriteStatement)statement;
			write.addField("wis_num");
			write.addField("wis_row");
			write.addField("row_label");
			write.addField("row_type");
			write.addField("known_point");
			write.addField("wdwater_num");
			write.addField("wdwater_link");
			write.addField("str_mile");
			write.addField("structure_num");
			write.addField("station_num");
			write.addField("identifier");
			write.addField("gain_factor");
			write.addTable("wis_format");
			break;			
		case __S_WIS_FORMULA:
			select = (DMISelectStatement)statement;
			select.addField("wis_formula.wis_num");
			select.addField("wis_formula.wis_row");
			select.addField("wis_formula.[column]");
			select.addField("wis_formula.formula");
			select.addField("wis_formula.formulastring");
			select.addTable("wis_formula");
			break;
		case __W_WIS_FORMULA:
			write = (DMIWriteStatement)statement;
			write.addField("wis_num");
			write.addField("wis_row");
			write.addField("[column]");
			write.addField("formula");
			write.addField("formulastring");
			write.addTable("wis_formula");
			break;			
		case __S_WIS_IMPORT:
			select = (DMISelectStatement)statement;
			select.addField("wis_import.wis_num");
			select.addField("wis_import.wis_row");
			select.addField("wis_import.[column]");
			select.addField("wis_import.end_time");
			select.addField("wis_import.time_offset");
			select.addField("wis_import.meas_num");
			select.addField("wis_import.import_method");
			select.addField("wis_import.import_wis_num");
			select.addField("wis_import.import_identifier");
			select.addField("wis_import.import_column");
			select.addField("wis_import.import_meas_desc");
			select.addTable("wis_import");
			break;
		case __W_WIS_IMPORT:
			write = (DMIWriteStatement)statement;
			write.addField("wis_num");
			write.addField("wis_row");
			write.addField("[column]");
			write.addField("end_time");
			write.addField("time_offset");
			write.addField("meas_num");
			write.addField("import_method");
			write.addField("import_wis_num");
			write.addField("import_identifier");
			write.addField("import_column");
			write.addField("import_meas_desc");
			write.addTable("wis_import");
			break;			
		case __S_WIS_DIAGRAM_DATA:
			select = (DMISelectStatement)statement;
			select.addField("wis_diagram_data.wis_num");
			select.addField("wis_diagram_data.id");
			select.addField("wis_diagram_data.type");
			select.addField("wis_diagram_data.props");
			select.addTable("wis_diagram_data");
			break;
		case __W_WIS_DIAGRAM_DATA:
			write = (DMIWriteStatement)statement;
			write.addField("wis_num");
			write.addField("id");
			write.addField("type");
			write.addField("props");
			write.addTable("wis_diagram_data");
			break;
		default:
			Message.printWarning (2, "HydroBaseDMI.buildSQL",
			"Unknown statement code: " + sqlNumber);
			break;
	}
}

// C METHODS

/**
Checks to see if a stored procedure can be used for the given statement.  If
so, the statement object is modified with the definition of the stored procedure
to be executed, and true is return.  If a stored procedure cannot be used
for this statement, false is returned and no changes are made to the 
statement.
@param statement the statement that might be set up as a stored procedure.
@param sqlNumber the int value that refers to the specific statement being
executed, the same value as used by buildSQL().
@return true if the statement can be set up as a stored procedure.  Otherwise, 
return false.
@throws Exception if there is any error in reading data from the database
while querying stored procedure information.
*/
private boolean canSetUpStoredProcedure(DMIStatement statement, int sqlNumber) 
throws Exception {
	boolean debug = false;
	if (IOUtil.testing() && debug) {
		Message.printStatus(2, "", "Checking to see if SQLNumber " 
			+ sqlNumber + " has an SP (" + __useSP + ")");
	}
			
	if (!__useSP) {
		if (Message.isDebugOn) {
			Message.printDebug(30, 
				"HydroBaseDMI.canSetUpStoredProcedure",
				"Cannot use stored procedures with this "
				+ "database.");
		}
		return false;
	}

	String name = null;

	// Look up the name of the stored procedure that maps to the specified
	// sqlNumber value.  

	switch (sqlNumber) {
		case __S_AQUIFER:
			name = "usp_CDSS_refAquifer_Sel";
			break;
		case __S_AREA_CAP:
			name = "usp_CDSS_AreaCap_Sel_By_Structure_num";
			break;
		case __S_CALLS:
			name = "usp_CDSS_Calls_Sel_By_DateWDID";
			break;
		case __S_CALLS_EDIT_SP:
			name = "usp_CDSS_Calls_Edit_Sel_By_StartEndDate";
			break;
		case __S_CALLS_SP:
			name = "usp_CDSS_Calls_Sel_By_StartEndDate";
			break;			
		case __S_CONTACT:
			name = "usp_CDSS_Contact_Sel_By_Rolodex_num";
			break;
		case __S_REF_COUNTY:
			name = "usp_CDSS_refCounty_Sel";
			break;
		case __S_COURTCASE_FOR_STRUCTURE_NUM:
			name = "usp_CDSS_CourtCase_Sel_By_Structure_num";
			break;
		case __S_CROP_REF:
			name = "usp_CDSS_refCrop_Sel";
			break;
		case __S_CROPCHAR_DISTINCT:
			name = "usp_CDSS_Cropchar_Sel_Distinct";
			break;
		case __S_CU_COEFF:
			name = "usp_CDSS_CUCoeff_Sel";
			break;
		case __S_CU_BLANEY_CRIDDLE_DISTINCT:
			name = "usp_CDSS_CUBlaneyCriddle_Sel_Distinct";
			break;
		case __S_CU_METHOD:
			name = "usp_CDSS_CUMethod_Sel";
			break;
		case __S_CU_METHOD_DISTINCT:
			name = "usp_CDSS_CUMethod_Sel_Distinct";
			break;
		case __S_DAM:
			name = "usp_CDSS_Dam_Sel_By_Structure_num";
			break;
		case __S_DAM_INSPECTION:
			name = "usp_CDSS_DamInspection_Sel_By_Structure_num";
			break;
		case __S_DAM_OUTLET:
			name = "usp_CDSS_DamOutlet_Sel_By_Structure_num";
			break;
		case __S_DAM_SPILLWAY:
			name = "usp_CDSS_DamSpillway_Sel_By_Structure_num";
			break;
		case __S_DBVERSION:
			name = "usp_CDSS_DBVersion_Sel";
			break;
		case __S_DBVERSION_FOR_VERSION_TYPE:
			name = "usp_CDSS_DBVersion_Sel_ByVersionType";
			break;
		case __S_DEVELOPER_FLEX_CODES:
			name = "usp_Developer_FLEX_codes";
			break;
		case __S_DIVERSION_COMMENT:
			name = "usp_CDSS_DiversionComment_Sel_By_Meas_num";
			break;
		case __S_DIVERSION_COMMENT_FOR_STRUCTURE_NUM:
			name = "usp_CDSS_DiversionComment_Sel_By_Structure_num";
			break;
		case __S_EMERGENCY_PLAN:
			name= "usp_CDSS_EmergencyPlan_Sel_By_Structure_num";
			break;
		case __S_EQUIPMENT:
			name = "usp_CDSS_Equipment_Sel_By_Structure_num";
			break;
		case __S_GENERAL_COMMENT:
			name="usp_CDSS_GeneralComment_Sel_By_Structure_num";
			break;
		case __S_GEOLOC:
			name = "usp_CDSS_Geoloc_Sel_By_Geoloc_num";
			break;
		case __S_GEOPHLOGS:
			if (getDatabaseVersion() < VERSION_20050701) {
				return false;
			}
			else {
				name = "usp_CDSS_Geophlogs_Sel";
			}
			break;
		case __S_LOC_TYPE:
			name = "usp_CDSS_refLocType_Sel";
			break;
		case __S_MAPFILE:
			name = "usp_CDSS_Mapfile_Sel_By_Structure_num";
			break;
		case __S_MEAS_TYPE_DISTINCT:
			name = "usp_CDSS_MeasType_Sel_Distinct";
			break;
		case __S_PARCEL_USE_TS_DISTINCT:
			name = "usp_CDSS_ParcelUseTS_CalYear_Distinct";
			break;
		case __S_PARCEL_USE_TS_STRUCTURE_TO_PARCEL_JOIN:
			name = 
		   "usp_CDSS_ParcelUseTSStructureToParcel_Sel_By_Structure_num";
			break;
		case __S_PARCEL_USE_TS_STRUCTURE_TO_PARCEL_JOIN_FOR_CAL_YEAR:
			name = 
		   "usp_CDSS_ParcelUseTSStructureToParcel_Sel_By_StructureNumCalYear";
			break;
		case __S_PERSON_DETAILS:
			name = "usp_CDSS_PersonDetails_Sel_By_Structure_num";
			break;
		case __S_RESERVOIR_FOR_STRUCTURE_NUM:
			name =
			     "usp_CDSS_StructureReservoir_Sel_By_Structure_num";
			break;
		case __S_RESERVOIR:
			name = "usp_CDSS_StructureReservoir_Sel_By_WDID";
			break;
		case __S_ROLODEX_FOR_ROLODEX_NUM:
			name = "usp_CDSS_Rolodex_Sel_By_Rolodex_num";
			break;
		case __S_ROLODEX_FOR_STRUCTURE_NUM:
			name = "usp_CDSS_Rolodex_Sel_By_Structure_num";
			break;
		case __S_STREAM_FOR_STREAM_NUM:
			name = "usp_CDSS_Stream_Sel_By_Stream_num";
			break;
		case __S_STREAM_FOR_WD:
			name = "usp_CDSS_Stream_Sel_By_WD";
			break;
		case __S_STREAM_FOR_WD_STR_TRIB_TO:
			name = "usp_CDSS_Stream_Sel_By_WD_Str_trib_to";
			break;
		case __S_STR_TYPE:
			name = "usp_CDSS_refStructureType_Sel";
			break;
		case __S_STRUCT_MEAS_TYPE_DISTINCT_2:
			name = "usp_CDSS_StructMeasType_Sel_Distinct";
			break;
		case __S_STRUCTURE_AKA:
			name = "usp_CDSS_StructureAKA_Sel_By_Structure_num";
			break;
		case __S_STRUCTURE_DISTINCT_WD:
			name = "usp_CDSS_Structure_Sel_WD_Distinct";
			break;
		case __S_MF_REACH:
			name = "usp_CDSS_StructureMFReach_Sel_By_Structure_num";
			break;
		case __S_REF_CIU:
			name = "usp_CDSS_refCIU_Sel";
			break;
		case __S_SMALL_DAM:
			name= "usp_CDSS_StructureSmallDam_Sel_By_Structure_num";
			break;
		case __S_TSPRODUCT_MAX_TSPRODUCT_NUM:
			name = "usp_CDSS_TSProduct_Sel_Max_TSProduct_num";
			break;
		case __S_TSPRODUCTPROPS:
			name="usp_CDSS_TSProductProps_Sel_By_TSProduct_num";
			break;
		case __S_USE:
			name = "usp_CDSS_refUse_Sel";
			break;
		case __S_USER_PREFERENCES:
			name = "usp_CDSS_UserPreferences_Sel_By_User_num";
			break;
		case __S_USER_SECURITY:
			name = 
		      "usp_CDSS_UserSecurity_Sel_By_Login_Password_Application";
			break;
		case __S_USER_SECURITY_FOR_USER_NUM:
			name = "usp_CDSS_UserSecurity_Sel_By_User_num";
			break;
		case __S_WATER_DISTRICT:
			name = "usp_CDSS_refWaterDistrict_Sel";
			break;
		case __S_WATER_DISTRICT_BY_DIV:
			name = "usp_CDSS_refWaterDistrict_Sel_Div";
			break;
		case __S_WATER_DIVISION:
			name = "usp_CDSS_refWaterDivision_Sel";
			break;
		case __S_WELL_MEAS:
			if (getDatabaseVersion() < VERSION_20050701) {
				return false;
			}
			else {
				name = "usp_CDSS_WellMeas";
			}
			break;
		case __S_WIS_DIAGRAM_DATA:
			name = "usp_CDSS_WISDiagramData_Sel_By_Wis_num";
			break;
		case __S_WIS_FORMULA:
			name = "usp_CDSS_WISFormula_Sel_By_Wis_num";
			break;
		case __S_WIS_IMPORT:
			name = "usp_CDSS_WISImport_Sel_By_Wis_num";
			break;

		case __D_WIS_SHEET_NAME:
			name ="usp_CDSS_WISSheetName_Del_By_Name_EffectiveDate";
			break;
		case __D_TSPRODUCT:
			name = "usp_CDSS_TSProduct_Del_By_TSProduct_num";
			break;
		case __D_TSPRODUCTPROPS:
			name = "usp_CDSS_TSProductProps_Del_By_TSProduct_num";
			break;
		case __D_WIS_DATA_1:
			name = "usp_CDSS_WIS_Del_By_Wis_num";
			break;
		case __D_WIS_DATA_2:
			name = "usp_CDSS_WIS_Del_By_Wis_numSet_date";
			break;			
		case __D_WIS_DAILY_WC:
			name = "usp_CDSS_WISDailyWC_Del";
			break;
		case __D_WIS_DATA:
			name = "usp_CDSS_WIS_Del_By_Wis_numSet_date";
			break;
		case __D_WIS_DIAGRAM_DATA:
			name = "usp_CDSS_WISDiagramData_Del_By_Wis_numID";
			break;
		case __D_WIS_DIAGRAM_DATA_FOR_WIS_NUM:
			name = "usp_CDSS_WISDiagramData_Del_By_Wis_num";
			break;
		case __D_WIS_FORMAT:
			name = "usp_CDSS_WISFormat_Del_By_Wis_num";
			break;
		case __D_WIS_FORMULA:
			name = "usp_CDSS_WISFormula_Del_By_Wis_num";
			break;
		case __D_WIS_IMPORT:
			name = "usp_CDSS_WISImport_Del_By_Wis_num";
			break;

		case __W_CALLS:
			name = "usp_CDSS_Calls_Upd";
			break;
		case __W_CALLS_2:
			name = "usp_CDSS_Calls_Archive_Date_Upd";
			break;
		case __W_CALLS_3:
			name = "usp_CDSS_Calls_ReleaseComments_Upd";
			break;
		case __W_CALLS_4:
			name = "usp_CDSS_Calls_Deleted_Upd";
			break;
		case __W_CALLS_5:
			name = "usp_CDSS_Calls_ReleaseComments_ArchiveDate_Upd";
			break;
		case __W_CALLS_6:
			name = "usp_CDSS_Calls_Ins";
			break;
		case __W_TSPRODUCT_2:
			name = "usp_CDSS_TSProduct_Identifier_Upd";
			break;
		case __W_TSPRODUCT_INSERT:
			name = "usp_CDSS_TSProduct_Ins";
			break;
		case __W_TSPRODUCT_UPDATE:
			name = "usp_CDSS_TSProduct_Upd";
			break;
		case __W_TSPRODUCTPROPS:
			name = "usp_CDSS_TSProductProps_InsUpd";
			break;
		case __W_USER_PREFERENCES_INSERT:
			name = "usp_CDSS_UserPreferences_Ins";
			break;
		case __W_USER_PREFERENCES_UPDATE:
			name = "usp_CDSS_UserPreferences_Upd";
			break;
		case __W_USER_SECURITY:
			name = "usp_CDSS_UserSecPw_Upd";
			break;
		case __W_USER_SECURITY_2:
			name = "usp_CDSS_UserSecurity_Ins";
			break;
		case __W_WIS_SHEET_NAME:
			name = "usp_CDSS_WISSheetName_Ins";
			break;
		case __W_WIS_SHEET_NAME_GAIN_METHOD:
			name = "usp_CDSS_WISSheetName_Upd";
			break;
		case __W_WIS_COMMENTS:
			name = "usp_CDSS_WISComments_Ins";
			break;
		case __W_WIS_DAILY_WC:
			name = "usp_CDSS_WISDailyWC_Ins";
			break;
		case __W_WIS_DATA:
			name = "usp_CDSS_WISData_Ins";
			break;
		case __W_WIS_FORMAT:
			name = "usp_CDSS_WISFormat_Ins";
			break;
		case __W_WIS_FORMULA:
			name = "usp_CDSS_WISFormula_Ins";
			break;
		case __W_WIS_IMPORT:
			name = "usp_CDSS_WISImport_Ins";
			break;
		case __W_WIS_DIAGRAM_DATA:
			name = "usp_CDSS_WISDiagramData_Ins";
			break;
		default:
			return false;
	}

	if (IOUtil.testing() && debug) {
		Message.printStatus(2, "", "Trying to create stored procedure '"
			+ name + "'");
	}

	// Look up the definition of the stored procedure (stored in a
	// DMIStoredProcedureData object) in the hashtable.  This allows
	// repeated calls to the same stored procedure to re-used stored
	// procedure meta data without requerying the database.

	DMIStoredProcedureData data = 
		(DMIStoredProcedureData)__storedProcedureHashtable.get(name);
	
	if (data != null) {
		// If a data object was found, set up the data in the statement
		// below and return true
	}
	else if (data == null 
		&& DMIUtil.databaseHasStoredProcedure(this, name)) {
		// If no data object was found, but the stored procedure is
		// defined in the database then build the data object for the
		// stored procedure and then store it in the hashtable.
		data = new DMIStoredProcedureData(this, name);
		__storedProcedureHashtable.put(name, data);
	}
	else {
		// If no data object was found and the stored procedure is not
		// defined in the database, then use the original DMI code.
		// Return false to buildSQL() so it knows to continue executing.
		if (IOUtil.testing()) {
			Message.printStatus(2, 
				"HydroBaseDMI.canSetUpStoredProcedure",
				"No stored procedure defined in database "
				+ "for SQL#: " + sqlNumber);
		}

		if (Message.isDebugOn) {
			Message.printDebug(30, 
				"HydroBaseDMI.canSetUpStoredProcedure",
				"No stored procedure defined in database "
				+ "for SQL#: " + sqlNumber);
		}		
		return false;
	}

	if (Message.isDebugOn) {
		Message.printDebug(30, 
			"HydroBaseDMI.canSetUpStoredProcedure",
			"Stored procedure '" + name + "' found and will "
			+ "be used.");
	}	

	if (IOUtil.testing() && debug) {
		DMIUtil.dumpProcedureInfo(this, name);
	}

	// Set the data object in the statement.  Doing so will set up the
	// statement as a stored procedure statement.

	statement.setStoredProcedureData(data);
	return true;
}

/**
Checks whether the currently logged-in user can write to the database.  Users
with the default login name (typically "guest") cannot save, unless they
are logged in to a local database (Access).  Otherwise, the user security
permissions are checked to see if the user has no permissions.  If the user
has no permissions, then false is returned.  Otherwise, true is returned.  <p>
<b>Note:</b> This doesn't check the permissions a user may have for a specific
water district, it only checks if the user is allowed to write data to the
database.
@return true if the user can save, false if they cannot.
*/
public boolean canWriteToDatabase() {
	// Local database users can ALWAYS write
	if (__userSecurityPermissions.equals(__NO_PERMISSIONS)) {
		if (getDatabaseEngine().equals("Access")) {
			return true;
		}
		return false;
	}
	else {
		// remote users cannot save if they are guests.
		if (!getUserLogin().equals(
			SelectHydroBaseJDialog.getDefaultLogin())) {
			return true;
		}
	}	
	return false;
}

/**
Checks to see if query strings should be printed at Debug level 30 and if so,
prints the given string.
@param s the String to possibly print, if the settings are correct.
*/
private void checkSecurityAndPrint(String s) {
	if (!__printQueryStrings) {
		return;
	}
	Message.printDebug(30, "DMIQuery", s);
}

/**
Overrides the base class close() in order to offer more capabilities for closing
for stored procedure connections.  If not a stored procedure connection, 
super.close() is called and the method returns.  Otherwise, the Statements 
created by all the stored procedures are closed and all connections to the
database from existing SPs are closed and then super.close() is called last.
*/
public void close() 
throws java.sql.SQLException {
	if (!__useSP) {
		super.close();
		return;
	}

	java.sql.CallableStatement cs = null;
	if (__uspFlexStoredProcedureData != null) {
		cs = __uspFlexStoredProcedureData.getCallableStatement();
		cs.close();
	}

	java.util.Enumeration e = __storedProcedureHashtable.keys();
	DMIStoredProcedureData data = null;
	while (e.hasMoreElements()) {
		data = (DMIStoredProcedureData)
			__storedProcedureHashtable.get((String)e.nextElement());
		cs = data.getCallableStatement();
		cs.close();
	}

	super.close();
}

/**
Closes a ResultSet from a stored procedure query.  Note that in the base DMI 
class there is another version of closeResultSet without the 'select' parameter
passed in.  This is only done for non-SP connections.  This version ensures that
the SP's Statement object is not closed, and thus the SP can be re-used
efficiently.
@param rs the ResultSet to be closed.
@param select the DMIStatement that was executed.
*/
public static void closeResultSet(ResultSet rs, DMIStatement select) 
throws java.sql.SQLException {
	if (rs != null) {
		rs.close();
		rs = null;
	}
}

/**
Converts a where clause with a county in it into a where clause that can be
used with Access databaes.<p>
This has to be done to accomodate counties with MS Access databases -- in all
other cases, counties can be queried as strings, but in Access it must be
queried as a number.
@param where clause to convert
@return the converted where clause
*/
public String convertCounty(String where) {
	if (!getDatabaseEngine().equalsIgnoreCase("Access")) {
		return where;
	}
	
	String rd = getRightIdDelim();
	String ld = getLeftIdDelim();
	
	String s = "";
	
	if (where.indexOf(ld + "cty" + rd) > -1) {
		int index = where.indexOf("=");
		s = where.substring(0, index) + "=";
	
		String rest = where.substring(index+1);
		rest = StringUtil.replaceString(rest, "'", "");
		s += rest;
	}
	else {
		return where;
	}

	return s;
}

// D METHODS

/**
Deletes records from the TSProduct and TSProductProps tables for the TSProduct
with the specified identifier and the user with the specified user_num.<p>
<b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_TSProduct_Del_By_TSProduct_num</li>
</ul>
@param identifier the identifier String of the TSProduct in the database.
@param user_num the user_num of the user who owns the TSProduct in the database.
@return a 3-element array.  The first element contains the number of records
deleted from the TSProduct table.  The second element contains the number of 
records deleted from the TSProductProps table.  The third element contains the
total number of records deleted.
*/
public int[] deleteTSProductForIdentifier(String identifier, int user_num) 
throws Exception {
	DMIDeleteStatement del1 = new DMIDeleteStatement(this);
	int[] deleted = new int[3];

	HydroBase_TSProduct tsp = readTSProductForIdentifier(identifier, 
		user_num);
	if (tsp == null) {
		deleted[0] = 0;
		deleted[1] = 0;
		deleted[2] = 0;
		return deleted;
	}
	
	int tsproduct_num = tsp.getTSProduct_num();	
			
	if (__useSP) {
		canSetUpStoredProcedure(del1, __D_TSPRODUCT);
		del1.addWhereClause("tsproduct_num = " + tsproduct_num);
		deleted[0] = dmiDelete(del1);
		deleted[1] = 0;
		deleted[2] = deleted[1] + deleted[0];
		return deleted;		
	}
	else {
		int propsCount = deleteTSProductPropsForTSProduct_num(
			tsproduct_num);
	
		String sql = "DELETE FROM tsproduct WHERE "
			+ "tsproduct.identifier = '"
			+ identifier + "' and tsproduct.user_num = " 
			+ user_num;
		deleted[0] = dmiDelete(sql);
		deleted[1] = propsCount;
		deleted[2] = deleted[0] + deleted[1];
	
		return deleted;
	}
}

/**
Deletes records from the TSProductProps tables for the the tsproduct with the
specified TSProduct_num.<p>
<b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_TSProductProps_Del_By_TSProduct_num(bigint @tsproduct_num)</li>
</ul>	
@param tsproduct_num the TSProduct_num of the records to delete.
@return the number of records to be deleted.
*/
public int deleteTSProductPropsForTSProduct_num(int tsproduct_num) 
throws Exception {
	DMIDeleteStatement del = new DMIDeleteStatement(this);
	if (canSetUpStoredProcedure(del, __D_TSPRODUCTPROPS)) {
		del.addWhereClause("TSProductProps.TSProduct_num = "
			+ tsproduct_num);
		return dmiDelete(del);
	}
		
	String sql = "DELETE FROM TSProductProps WHERE "
		+ "TSProductProps.TSProduct_num = " + tsproduct_num;
	return dmiDelete(sql);
}

/**
Deletes all the matching records from wis_comments.
This method is used by:<ul>
<li>HydroBase_GUI_WISBuilder.getRecentFormatWISNum()</li>
<li>HydroBase_GUI_LoadWIS.deleteClicked()</li>
</ul><p>
@param wis_num wis_num of the records to delete
@return the number of records deleted.
*/
public int deleteWISCommentsForWis_num(int wis_num) 
throws Exception {
	DMIDeleteStatement del = new DMIDeleteStatement(this);
	if (canSetUpStoredProcedure(del, __D_WIS_COMMENTS_FOR_WIS_NUM)) {
		del.addWhereClause("wis_comments.wis_num = " + wis_num);
		return dmiDelete(del);
	}
	String sql = "DELETE FROM wis_comments WHERE wis_comments.wis_num = "
		+ wis_num;
	return dmiDelete(sql);
}

/**
Deletes all the matching records from wis_daily_wc.
This method is used by:<ul>
<li>HydroBase_GUI_WIS.saveDiversionCoding()</li>
</ul><p>
<b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISDailyWC_Del_By_Wis_num_Wis_column_WD_ID_Cal_year_Cal_mon(
bigint @wis_num, varchar @wis_column, int @wd, bigint @id, int @cal_year,
int @cal_mon)</li>
</ul>
@param wis_num wis_num of records to delete
@param wis_column wis_column of records to delete
@param wd wd of records to delete
@param id id of records to delete
@param cal_year cal_year of records to delete
@param cal_mon cal_mon of records to delete
@return the number of recods deleted
@throws Exception if an error occurs.
*/
public int deleteWISDailyWC(int wis_num, String wis_column, int wd, int id, 
int cal_year, int cal_mon) 
throws Exception {
	DMIDeleteStatement del = new DMIDeleteStatement(this);
	if (__useSP) {
		canSetUpStoredProcedure(del, __D_WIS_DAILY_WC);
		del.addWhereClause("wis_dail_wc.wis_num = " + wis_num);
		del.addWhereClause("wis_dail_wc.wis_column = '" + wis_column
			+ "'");
		del.addWhereClause("wis_dail_wc.wd = " + wd);
		del.addWhereClause("wis_dail_wc.id = " + id);
		del.addWhereClause("wis_dail_wc.cal_year = " + cal_year);
		del.addWhereClause("wis_dail_wc.cal_mon = " + cal_mon);
		return dmiDelete(del);
	}
	else {
		String sql = "DELETE FROM wis_daily_wc WHERE"
			+ " wis_num = " + wis_num + " AND "
			+ " wis_column = '" + wis_column + "'" + " AND "
			+ " wd = " + wd + " AND "
			+ " id = " + id + " AND "
			+ " cal_year = " + cal_year + " AND "
			+ " cal_mon = " + cal_mon;
		return dmiDelete(sql);
	}
}

/**
Deletes all matching records from wis_format.
This method is used by:<ul>
<li>HydroBase_GUI_WISBuilder.archiveData()</li></ul><p>
<b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISFormat_Del_By_Wis_num(bigint @wis_num)</li>
</ul>
@param wis_num wis_num of the records to delete.
@return the number of records deleted.
@throws Exception if an error occurs.
*/
public int deleteWISFormatForWis_num(int wis_num) 
throws Exception {
	DMIDeleteStatement del = new DMIDeleteStatement(this);
	if (canSetUpStoredProcedure(del, __D_WIS_FORMAT)) {
		del.addWhereClause("wis_num = " + wis_num);
		return dmiDelete(del);
	}
	else {
		String sql = "DELETE FROM wis_format WHERE wis_format.wis_num ="
			+ wis_num;
	
		return dmiDelete(sql);
	}
}

/**
Deletes all matching records from wis_formula.
This method is used by: <ul>
<li>HydroBase_GUI_WISBuilder.archiveData()</li>
</ul><p>
<b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISFormula_Del_By_Wis_num(bigint @wis_num)</li>
</ul>
@param wis_num the wis_num of the records to delete
@return the number of records deleted
@throws Exception if an error occurs
*/
public int deleteWISFormulaForWis_num(int wis_num)
throws Exception {
	DMIDeleteStatement del = new DMIDeleteStatement(this);
	if (canSetUpStoredProcedure(del, __D_WIS_FORMULA)) {
		del.addWhereClause("wis_num = " + wis_num);
		return dmiDelete(del);
	}
	String sql = "DELETE FROM wis_formula WHERE wis_formula.wis_num = "
		+ wis_num;
	return dmiDelete(sql);
}

/**
Deletes all matching records from wis_daily_wc,
wis_diagram_data, wis_formula, wis_import, wis_format, wis_sheet_name.  
This method is used by:<ul>
<li>HydroBase_GUI_LoadWIS</li>
</ul><p>
<b>Stored Procedure</b><p>
The stored procedures that correspond to this query is:<ul>
<li>usp_CDSS_WIS_Del_By_Wis_num</li>
<li>usp_CDSS_WIS_Del_By_Wis_numSet_date</li>
</ul>
@param wis_num wis_num of the records to delete
@return the number of records deleted.
*/
public int deleteWISForWis_num(int wis_num)
throws Exception {
	if (__useSP) {
		DMIDeleteStatement del = new DMIDeleteStatement(this);
		int total = 0;
		if (canSetUpStoredProcedure(del, __D_WIS_DATA_1)) {
			del.addWhereClause("wis_num = " + wis_num);
			total += dmiDelete(del);
		}
		else {
			throw new Exception(
				"Unable to set up stored procedure.");
		}
		return total;
	}
	else {
		int total = deleteWISFormatForWis_num(wis_num);
		total += deleteWISImportForWis_num(wis_num);
		total += deleteWISFormulaForWis_num(wis_num);
		String sql = 
			"DELETE FROM wis_daily_wc WHERE wis_num = " + wis_num;
		total += dmiWrite(sql);			
		total += deleteWISCommentsForWis_num(wis_num);
		total += deleteWISDiagramDataForWis_num(wis_num);
		total += deleteWISSheetNameForWis_num(wis_num);
		return total;
	}
}

/**
Deletes all matching records from wis_comments, wis_data.
This method is used by:<ul>
<li>HydroBase_GUI_LoadWIS</li>
</ul><p>
<b>Stored Procedure</b><p>
The stored procedures that correspond to this query is:<ul>
<li>usp_CDSS_WIS_Del_By_Wis_numSet_date</li>
</ul>
@param wis_num wis_num of the records to delete
@param set_date set_date of the records to delete
@return the number of records deleted.
*/
public int deleteWISForWis_numSet_date(int wis_num, DateTime set_date) 
throws Exception {
	if (__useSP) {
		DMIDeleteStatement del = new DMIDeleteStatement(this);
		if (canSetUpStoredProcedure(del, __D_WIS_DATA_2)) {
			del.addWhereClause("wis_num = " + wis_num);
			del.addWhereClause("set_date = " 
				+ DMIUtil.formatDateTime(this, set_date,false));
			return dmiDelete(del);
		}
		else {
			throw new Exception(
				"Unable to set up stored procedure.");
		}
	}
	else {
		int total = 0;
		String date = DMIUtil.formatDateTime(this, set_date);
		String sql = "DELETE FROM wis_comments WHERE " 
			+ "wis_comments.wis_num = " + wis_num 
			+ " AND wis_comments.set_date = " + date;
		total += dmiDelete(sql);
		
		sql = "DELETE FROM wis_data WHERE " 
			+ "wis_data.wis_num = " + wis_num 
			+ " AND wis_data.set_date = " + date;
		total += dmiDelete(sql);		
		return total;
	}
}

/**
Deletes all matching records from wis_import.
</ul><p>
<b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISImport_Del_By_Wis_num(bigint @wis_num)</li>
</ul>
@param wis_num wis_num of the records to delete
@return the number of records deleted
@throws Exception if an error occurs.
*/
public int deleteWISImportForWis_num(int wis_num) 
throws Exception {
	DMIDeleteStatement del = new DMIDeleteStatement(this);
	if (canSetUpStoredProcedure(del, __D_WIS_IMPORT)) {
		del.addWhereClause("wis_num = " + wis_num);
		return dmiDelete(del);
	}
	else {
		String sql = "DELETE FROM wis_import WHERE wis_import.wis_num ="
			+ wis_num;
		return dmiDelete(sql);
	}
}

/**
Deletes all matching records from wis_diagram_data.
<b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISDiagramData_Del_By_Wis_num</li>
</ul>
@param wis_num wis_num of the records to delete
@return the number of records deleted.
@throws Exception if an error occurs.
*/
public int deleteWISDiagramDataForWis_num(int wis_num) 
throws Exception {
	DMIDeleteStatement del = new DMIDeleteStatement(this);
	if (canSetUpStoredProcedure(del, __D_WIS_DIAGRAM_DATA_FOR_WIS_NUM)) {
		del.addWhereClause("wis_num = " + wis_num);
		return dmiDelete(del);
	}
	String sql = "DELETE FROM wis_diagram_data WHERE "
		+ "wis_diagram_data.wis_num = " + wis_num;
	return dmiDelete(sql);
}

/**
Deletes all matching records from wis_diagram_data.
<b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISDiagramData_Del_By_Wis_num_ID</li>
</ul>
@param wis_num wis_num of the records to delete
@param id the id of the records to delete
@return the number of records deleted.
@throws Exception if an error occurs.
*/
public int deleteWISDiagramDataForWis_numID(int wis_num, String id) 
throws Exception {
	DMIDeleteStatement del = new DMIDeleteStatement(this);
	if (canSetUpStoredProcedure(del, __D_WIS_DIAGRAM_DATA)) {
		del.addWhereClause("wis_num = " + wis_num);
		del.addWhereClause("id = '" + id + "'");
		return dmiDelete(del);
	}

	String sql = "DELETE FROM wis_diagram_data WHERE "
		+ "wis_diagram_data.wis_num = " + wis_num
		+ " AND wis_diagram_data.id = '" + id + "'";
	return dmiDelete(sql);
}

/**
Deletes all records from wis_sheet_name that have the given sheet name and
effective date.
@param sheteName the name of the sheet to delete.
@param effectiveDate the effective date of the sheet to delete.
@return the number of deleted records.
@throws Exception if an error occurs.
*/
public int deleteWISSheetNameForSheet_nameEffectiveDate(String sheetName,
DateTime effectiveDate) 
throws Exception {
	DMIDeleteStatement del = new DMIDeleteStatement(this);
	if (canSetUpStoredProcedure(del, __D_WIS_SHEET_NAME)) {
		del.addWhereClause("sheet_name = '" + sheetName + "'");
		del.addWhereClause("effective_date = " 
			+ DMIUtil.formatDateTime(this, effectiveDate));
		return dmiDelete(del);
	}
	else {
		return dmiDelete("DELETE FROM Sheet_Name where sheet_Name = '" 
			+ sheetName + "' AND effective_date = " 
			+ DMIUtil.formatDateTime(this, effectiveDate));
	}
}
	
/**
Deletes all matching records from wis_sheet_name.
</ul>
<p><b>Stored Procedure</b><p>
This doesn't used stored procedures.
@param wis_num the wis_num for which to delete sheet_name records.
@return the number of records deleted
@throws Exception if an error occurs.
@deprecated don't use this!
*/
private int deleteWISSheetNameForWis_num(int wis_num) 
throws Exception {
	String table = "wis_sheet_name";
	if (getDatabaseVersion() <= VERSION_20040701) {
		table = "sheet_name";
	}

	String sql = "DELETE FROM " + table + " WHERE " + table + ".wis_num "
		+ "= " + wis_num;
	return dmiDelete(sql);
}

/**
Determine the database version by examining the table structure for the
database.  See the is VersionXXX methods for more information on versioning.
*/
public void determineDatabaseVersion() {
	// Default until more checks are added...
	String routine = "HydroBaseDMI.determineDatabaseVersion";
	boolean version_found = false;
	long version = VERSION_UNKNOWN;
	try {
		// VERSION_20070525
		if (isVersionAtLeast(VERSION_20070525)) {
			version = VERSION_20070525;
		}
		// VERSION_20070502
		else if (isVersionAtLeast(VERSION_20070502)) {
			version = VERSION_20070502;
		}
		// VERSION_20070416
		else if (isVersionAtLeast(VERSION_20070416)) {
			version = VERSION_20070416;
		}
		// VERSION_20061003
		else if (isVersionAtLeast(VERSION_20061003)) {
			version = VERSION_20061003;
		}
		// VERSION_20051115
		else if (isVersionAtLeast(VERSION_20051115)) {
			version = VERSION_20051115;
		}
		// VERSION_20050701
		else if (isVersionAtLeast(VERSION_20050701)) {
			version = VERSION_20050701;
		}
		// VERSION_20050501
		else if (isVersionAtLeast(VERSION_20050501)) {
			version = VERSION_20050501;
		}
		// VERSION_20040701
		else if (isVersionAtLeast(VERSION_20040701)) {
			version = VERSION_20040701;
		}
		// VERSION_20030701
//		else if (isVersionAtLeast(VERSION_20030701)) {
//			version = VERSION_20030701;
//		}
		// VERSION_20010326
		else if (isVersionAtLeast(VERSION_20010326)) {
			version = VERSION_20010326;
		}
		// VERSION_20000706
		else if (isVersionAtLeast(VERSION_20000706)) {
			version = VERSION_20000706;
		}
		// VERSION_20000427
		else if (isVersionAtLeast(VERSION_20000427)) {
			version = VERSION_20000427;
		}
		// VERSION_20000301
		else if (isVersionAtLeast(VERSION_20000301)) {
			version = VERSION_20000301;
		}
		// VERSION_19990305
		else if (isVersionAtLeast(VERSION_19990305)) {
			version = VERSION_19990305;
		}
		// VERSION_19990202
		else if (isVersionAtLeast(VERSION_19990202)) {
			version = VERSION_19990202;
		}
		// VERSION_19980428
		else if (isVersionAtLeast(VERSION_19980428)) {
			version = VERSION_19980428;
		}
		// VERSION_19970501
		else if (isVersionAtLeast(VERSION_19970501)) {
			version = VERSION_19970501;
		}
		
		if (version != VERSION_UNKNOWN) {
			version_found = true;
		}
	}
	catch (Exception e) {
		Message.printWarning (2, routine, e);
	}
	// Default case -- latest version
	if (!version_found) {
		setDatabaseVersion ( VERSION_20010326);
	}

	setDatabaseVersion (version);

	Message.printStatus (2, routine,
		"HydroBase version determined to be at least " 
		+ getDatabaseVersion());
}

/**
Executes a delete and returns the result.  This overrides the normal dmiDelete()
in order /hat for stored procedures when testing the string that can be
pasted into the Query Analyzer can be printed.
@param q the DMIDeleteStatement to execute.
@return a ResultSet of records.
*/
public int dmiDelete(DMIDeleteStatement q)
throws java.sql.SQLException {
	if (__useSP) {
		if (IOUtil.testing()) {
			Message.printStatus(2, "", "" 
				+ q.createStoredProcedureString());
		}
		checkSecurityAndPrint(q.createStoredProcedureString());
	}
	else {
		if (IOUtil.testing()) {
			Message.printStatus(2, "", "" + q.toString());
		}
		checkSecurityAndPrint(q.toString());
	}

	return super.dmiDelete(q);
}

/**
Executes a query and returns the result.  This overrides the normal dmiSelect()
in order that for stored procedures when testing the string that can be
pasted into the Query Analyzer can be printed.
@param q the DMISelectStatement to execute.
@return a ResultSet of records.
*/
public ResultSet dmiSelect(DMISelectStatement q)
throws java.sql.SQLException {
	if (__useSP) {
		__lastStatement = q;
		if (IOUtil.testing()) {
			Message.printStatus(2, "", "" 
				+ q.createStoredProcedureString());
		}
		checkSecurityAndPrint(q.createStoredProcedureString());
	}
	else {
		if (IOUtil.testing()) {
			Message.printStatus(2, "", "" + q.toString());
		}
		checkSecurityAndPrint(q.toString());
	}	

	return super.dmiSelect(q);
}

/**
Executes a write and returns the result.  This overrides the normal dmiWrite()
in order that for stored procedures when testing the string that can be
pasted into the Query Analyzer can be printed.
@param q the DMIWriteStatement to execute.
@return a ResultSet of records.
*/
public int dmiWrite(DMIWriteStatement q, int type)
throws Exception {
	if (__useSP) {
		if (IOUtil.testing()) {
			Message.printStatus(2, "", "" 
				+ q.createStoredProcedureString());
		}
		checkSecurityAndPrint(q.createStoredProcedureString());
	}
	else {
		if (IOUtil.testing()) {
			Message.printStatus(2, "", "" + q.toString());
		}
		checkSecurityAndPrint(q.toString());
	}

	return super.dmiWrite(q, type);
}

// E METHODS
// F METHODS

/**
Cleans up member variables.
@throws Throwable if there is an error.
*/
protected void finalize() 
throws Throwable {
	__storedProcedureHashtable = null;
	__viewNumbers = null;
	__prefsProps = null;
	__userSecurityPermissions = null;
	__CountyRef_Vector = null;
	__BlaneyCriddleCUMethod_Vector = null;
	__CropcharCUMethod_Vector = null;
	__CropRef_Vector = null;
	__HUC_Vector = null;
	__LocTypes_Vector = null;
	__MeasType_Vector = null;
	__RefCIU_Vector = null;
	__StrTypes_Vector = null;
	__StructMeasType_Vector = null;
	__UseTypes_Vector = null;
	__WaterDistricts_Vector = null;
	__WaterDistrictsByDiv_Vector = null;
	__WaterDistrictsFromStructures_Vector = null;
	__WaterDivisions_Vector = null;
	__WISStructures_Vector = null;
	super.finalize();
}

// G METHODS

/**
Returns this DMI's annotation providers.
@return this DMI's annotation providers.
*/
public Vector getAnnotationProviderChoices() {	
	return __providers;
}

/**
Returns the global aquifer data.
@return the global aquifer data.
*/
public Vector getAquiferRef() {	
	String routine = "getAquiferRef";
	if (__AquiferRef_Vector == null) {
		try {
			__AquiferRef_Vector = readAquiferRefList();
		}
		catch ( Exception e) {
			Message.printWarning ( 2, routine,
			"Unable to read Aquifer_Ref data.");
			Message.printWarning ( 2, routine, e);
		}
		if (__AquiferRef_Vector == null) {
			__AquiferRef_Vector = new Vector();
		}
	}

	return __AquiferRef_Vector;
}

/**
Returns the global BlaneyCriddleCUMethod data, containing a list of distinct
CU method descriptions from the cu_blaney_criddle table.
This is used by StateDMI.
@return the global BlaneyCriddleCUMethod data.
*/
public Vector getBlaneyCriddleCUMethod() {
	String routine = "getBlaneyCriddleCUMethod";
	if (__BlaneyCriddleCUMethod_Vector == null) { 
		try {
			__BlaneyCriddleCUMethod_Vector =
				readCUBlaneyCriddleListForMethodDesc ( null, 
				true);
		}
		catch ( Exception e) {
			Message.printWarning ( 2, routine,
			"Unable to read BlaneyCriddle CU_method data.");
			Message.printWarning ( 2, routine, e);
		}
		if (__BlaneyCriddleCUMethod_Vector == null) {
			__BlaneyCriddleCUMethod_Vector = new Vector();
		}
	}

	return __BlaneyCriddleCUMethod_Vector;
}

/**
Returns the Vector of global CIU reference data.
@return the Vector of global CIU reference data.
*/
public Vector getCIUVector() {
	String routine = "getCIUVector";
	if (__RefCIU_Vector == null) {
		try {
			__RefCIU_Vector = readRefCIUList();
		}
		catch (Exception e) {
			Message.printWarning ( 2, routine,
				"Unable to read ref_ciu data.");
			Message.printWarning ( 2, routine, e);
		}
		if (__RefCIU_Vector == null) {
			__RefCIU_Vector = new Vector();
		}
	}

	return __RefCIU_Vector;
}

/**
Returns the global CountyRef data.
This is used by StateDMI.
@return the global CountyRef data.
*/
public Vector getCountyRef() {	
	String routine = "getCountyRef";
	if (__CountyRef_Vector == null) {
		try {
			__CountyRef_Vector = readCountyRefList();
		}
		catch ( Exception e) {
			Message.printWarning ( 2, routine,
			"Unable to read County_Ref data.");
			Message.printWarning ( 2, routine, e);
		}
		if (__CountyRef_Vector == null) {
			__CountyRef_Vector = new Vector();
		}
	}

	return __CountyRef_Vector;
}

/**
Returns the global CropcharCUMethod data, containing a list of distinct
CU method descriptions from the cropchar table.
This is used by StateDMI.
@return the global CropcharCUMethod data.
*/
public Vector getCropcharCUMethod() {
	String routine = "GetCropcharCUMethod";
	if (__CropcharCUMethod_Vector == null) {
		try {
			__CropcharCUMethod_Vector 
				= readCropcharListForMethodDesc(null, true);
		}
		catch ( Exception e) {
			Message.printWarning ( 2, routine,
			"Unable to read Cropchar CU_method data.");
			Message.printWarning ( 2, routine, e);
		}
		if (__CropcharCUMethod_Vector == null) {
			__CropcharCUMethod_Vector = new Vector();
		}
	}

	return __CropcharCUMethod_Vector;
}

/**
Returns the global CropRef data.
This is used by StateDMI.
@return the global CropRef data.
*/
public Vector getCropRef() {
	String routine = "getCropRef";
	if (__CropRef_Vector == null) {
		try {
			__CropRef_Vector = readCropRefList();
		}
		catch ( Exception e) {
			Message.printWarning ( 2, routine,
			"Unable to read Crop_Ref data.");
			Message.printWarning ( 2, routine, e);
		}
		if (__CropRef_Vector == null) {
			__CropRef_Vector = new Vector();
		}
	}

	return __CropRef_Vector;
}

/**
Returns the database properties, suitable for display in a dialog for 
information about the connection.
@return the database properties, such as:
<ul>
<li>database host</li>
<li>odbc data source name</li>
<li>database version</li>
<li>program that is running the database</li>
<li>list of water districts available</li>
<li>database revision history</li>
</ul>
*/
public Vector getDatabaseProperties () {
	Vector v = new Vector();
	v.add("HydroBase Database Host: " + getDatabaseServer());
	if (getODBCName() != null) {
		v.add("ODBC Data Source Name:  " +
		getODBCName());	
	}
	else {
		v.add (
		"ODBC Data Source Name:  HydroBase (internally defined)");
	}
	v.add("Database design version appears to be: " +
		getDatabaseVersion());
	if (__useSP) {
		v.add("Database does use stored procedures.");
	}
	else {	v.add("Database does not use stored procedures.");
	}
	v.add("");

	if (__providers.size() == 0) {
		v.add("No time series product annotation " +
		"provider choices available.");
	}
	else {
		v.add("Time series product annotation provider choices:");
		for (int i = 0; i < __providers.size(); i++) {
			v.add("   " + __providers.elementAt(i));
		}
	}

	v.add("");
	v.add("The database used by " + IOUtil.getProgramName() +
		" appears to include the following water");
	v.add("districts, based on the structure information in the" +
		" database");
	v.add ("(transbasin structures are not reflected in the list):");
	v.add("");
	
	HydroBase_WaterDistrict hbwd;
	Vector waterDistricts = getWaterDistricts();
	int size = waterDistricts.size();
	for (int i = 0; i < size; i++) {
		hbwd = (HydroBase_WaterDistrict)waterDistricts
			.elementAt(i);
		v.add("   " + hbwd.getWD() + " - " + hbwd.getWd_name());
	}

	v.add("");
	v.add("Database history (most recent at top):");
	v.add("");
	try {
		Vector v2 = readDBVersionListForVersionType ( null);
		size = 0;
		if (v2 != null) {
			size = v2.size();
		}
		HydroBase_DBVersion ver = null;
		DateTime dt;
		for ( int i = 0; i < size; i++) {
			ver = (HydroBase_DBVersion)v2.elementAt(i);
			dt = new DateTime ( ver.getVersion_date());
			v.add("" +
				dt.toString(DateTime.FORMAT_YYYY_MM_DD) + " " +
				ver.getVersion_comment());
		}
	}
	catch ( Exception e) {
		v.add("Cannot determine.");
		Message.printWarning ( 2, "", e);
	}

	return v;
}

/**
Returns the name of the DMI in a format suitable for use in dialogs or window
titles.  In this case, returns "HydroBase".  Method is from TSProductDMI.
@return the name of the DMI ("HydroBase").
*/
public String getDMIName() {
	return "HydroBase";
}

/**
Returns the global HUC data. <p>
Called by:<ul>
<li>StateDMI</li>
<li>TSTool</li>
</ul>
@return the global HUC data.
*/
public Vector getHUC() {
	if (__HUC_Vector == null) {
		__HUC_Vector = new Vector();
	}

	return __HUC_Vector;
}

/**
Return a string containing information about the latest version information
in the database, suitable for output.
@return a String of the form
"HydroBase.db_version:  design version: YYYYMMDD  last data change: YYYYMMDD". 
*/
public String getLatestVersionString() {
	if ((__design_version <= 0) && (__data_version <= 0)) {
		// Have not already determined the versions so query...
		try {
			if (__useSP) {
				// do nothing -- stored procedure should be
				// available
			}
			else if (!DMIUtil.databaseHasTable(this, "db_version")){
				return "Unable to determine database version " 
					+ "(no db_version table in HydroBase).";
			}
		}
		catch (Exception e) {
			return "Unable to determine database version.";
		}
		// Else, check the version...
		try {
			Vector results =
				readDBVersionListForVersionType("design");
			if (results == null) {
				return "Unable to determine database version.";
			}
			if (results.size() == 0) {
				return "Unable to determine database version.";
			}
			__design_version = ((HydroBase_DBVersion)
				results.elementAt(0)).getVersion_id();
		}
		catch (Exception e) {
			return "Unable to determine database version.";
		}
		try {
			Vector results =readDBVersionListForVersionType("data");
			if (results == null) {
				return "Unable to determine database version.";
			}
			if (results.size() == 0) {
				return "Unable to determine database version.";
			}
			__data_version = ((HydroBase_DBVersion)
				results.elementAt(0)).getVersion_id();
		}
		catch (Exception e) {
			return "Unable to determine database version.";
		}
	}
	return "HydroBase.db_version:  design version: " + __design_version +
		"  last data change: " + __data_version;
}

/**
Returns the location type description that matches a given location type.
This uses global data stored in internal Vectors and read from the database
when a connection is made to the database.
@param locationType A location type string from the loc_type table.
@return The location type description given a location type (abbreviation) or
" " if none matched.
*/
public String getLocationTypeDescription(String locationType) {
	HydroBase_LocType locType;
	Vector locTypes = getLocTypesVector();
	int size = locTypes.size();

	for (int i = 0; i < size; i++) {
		locType = (HydroBase_LocType)(locTypes.elementAt(i));
		if (locType.getLoc_type().equals(locationType)) {
			return locType.getLoc_type_desc();
		}
	}
	return " ";
}

public Vector getLocTypesVector() {
	String routine = "getLocTypesVector";
	if (__LocTypes_Vector == null) {
		try {
			__LocTypes_Vector = readLocTypeList();
		} 
		catch (Exception e) {
			Message.printWarning ( 2, routine,
				"Unable to read LocTypes data.");
			Message.printWarning ( 2, routine, e);
		}
		if (__LocTypes_Vector == null) {
			__LocTypes_Vector = new Vector();
		}
	}
	
	return __LocTypes_Vector;
}

/**
Returns the global distinct MeasType data.
@return the global distinct MeasType data.
*/
public Vector getMeasType() {
	String routine = "getMeasType";
	if (__MeasType_Vector == null) {
		try {
			__MeasType_Vector = readMeasTypeDistinctList();
		}
		catch (Exception e) {
			Message.printWarning ( 2, routine,
				"Unable to read distinct MeasType data.");
			Message.printWarning ( 2, routine, e);
		}
	
		if (__MeasType_Vector == null) {
			__MeasType_Vector = new Vector();
		}
	}

	return __MeasType_Vector;
}

/**
Returns the corresponding property value (i.e., user preference value) for
the given key. <p>
It is imperative to type the String variable exactly as in appears in the 
User_preference table, otherwise the search will fail. <p>
Preference values are stored in an internal proplist when a user logs in
to the database.
@param variable lookup keyword
@return the corresponding value or "NONE" if not found.
*/
public String getPreferenceValue(String variable) {
	String function = "HydroBaseDMI.getPreferenceValue";
	int dl = 20;

	String value = null;
	try {
		value = __prefsProps.getValue(variable).trim();
		if (Message.isDebugOn) {
			Message.printDebug(dl, function,
				"Located user preference: " + variable
				+ " value is " + value);
		}
	}
	catch (Exception e) {
		value = "NONE";
		Message.printDebug(dl, function,
			"Unable to locate user preference: " + variable
			+ " set to default value of " + value);
		return value;
	}

        return value;
}

/**
Returns the Vector of structure types stored in global data.
@return the Vector of structure types stored in global data.
*/
public Vector getStrTypesVector() {
	String routine = "getStrTypesVector";
	if (__StrTypes_Vector == null) {
		try {
			__StrTypes_Vector = readStrTypeList();
		}
		catch (Exception e) {
			Message.printWarning ( 2, routine,
				"Unable to read StrTypes data.");
			Message.printWarning ( 2, routine, e);
		}
		if (__StrTypes_Vector == null) {
			__StrTypes_Vector = new Vector();
		}
	}
	
	return __StrTypes_Vector;
}

/**
Returns the global distinct StructMeasType data.
@return the global distinct StructMeasType data.
*/
public Vector getStructMeasType () {
	String routine = "getStructMeasType";
	if (__StructMeasType_Vector == null) {
		try {
			__StructMeasType_Vector 
				= readStructMeasTypeDistinctList();
		}
		catch (Exception e) {
			Message.printWarning ( 2, routine,
				"Unable to read distinct StructMeasType data.");
			Message.printWarning ( 2, routine, e);
		}
		if (__StructMeasType_Vector == null) {
			__StructMeasType_Vector = new Vector();
		}
	}

	return __StructMeasType_Vector;
}

/**
Returns the structure type description that matches a given structure type
abbreviation.  Data is read from internal Vectors that are populated when
a user logs into the database.
@param structureType A structure type string from the str_type table.
@return The structure type description given a structure type (abbreviation) or
" " if none matched.
*/
public String getStructureTypeDescription (String structureType) {
	HydroBase_StrType strType;
	Vector strTypes = getStrTypesVector();
	int size = strTypes.size();

	for (int i = 0; i < size; i++) {
		strType = (HydroBase_StrType)(strTypes.elementAt(i));
		if (strType.getStr_type().equals(structureType)) {
			return  strType.getStr_type_desc();
		}
	}
	return " ";
}

/**
Returns the __userNum for the currently-logged-in user.
@return the __userNum for the currently-loggin-in user.
*/
public int getUserNum() {
	return __userNum;
}

/**
Returns the global __UseTypes_Vector data.
@return the __UseTypes_Vector.
*/
public Vector getUseTypes() {
	String routine = "getUseTypes";
	if (__UseTypes_Vector == null) {
		try {
			__UseTypes_Vector = readUseList();
		}
		catch (Exception e) {
			Message.printWarning ( 2, routine,
				"Unable to read UseTypes data.");
			Message.printWarning ( 2, routine, e);
		}
		if (__UseTypes_Vector == null) {
			__UseTypes_Vector = new Vector();
		}
	}
	
	return __UseTypes_Vector;
}

/**
Create comments about the database suitable to include in any file header.
The strings do not have "#" at the front.
This method is used by software that writes output files using data that were
read from HydroBase.
@return an array of strings, each of which is a line that can be used in a
file header to document the database version.
*/
public String[] getVersionComments() 
throws Exception {
	String [] v = new String[9];
	v[0] = "";
	v[1] = "-------------------------------------------------------" +
		"----------------------";
	if (getJDBCODBC()) {
		// Database server...
		v[2] = "HydroBase database is: " +
			getDatabaseName() + " on " + getDatabaseServer();
	}
	else {
		// Connection is ODBC...
		v[2] = "HydroBase ODBC DSN is: " + getODBCName();
	}
	v[3] = getLatestVersionString();
	v[4] = "HydroBase table structure for software is at least " +
		getDatabaseVersion();
	v[5] = "HydroBase input name is \"" + getInputName() + "\".";
	if ( __useSP ) {
		v[6] = "Stored procedures are being used.";
	}
	else {	v[6] = "Stored procedures are not being used.";
	}
	v[7] = "------------------------------------------------------" +
		"-----------------------";
	v[8] = "";
	return v;
}

/**
Looks up a view with a given name in the view name to view number hashtable.
If the view name cannot be found, an exception will be thrown.  Otherwise,
the internal number of the view used by SPFlex will be returned.
@param viewName the name of the view to look up in the view name to view number
hashtable.
@return the internal number of the view used by the SPFlex stored procedure.
@throws Exception if the view name cannot be found in the hash table.
*/
private String getViewNumber(String viewName) 
throws Exception {
	String s = (String)(__viewNumbers.get(viewName));
	if (s == null) {
		throw new Exception("View '" + viewName + "' could not be "
			+ "found in the view-to-number lookup.");
	}
	return s;
}

/**
This function  examines choice component argument and builds the
where clause for the selected division/district.
@param choice the SimpleJComboBox to use when building the where clause.
@param table the table with which the where clause will be used.
@param displayWarning boolean flag for diplaying or supressing the dialog 
warnings
@param checkData boolean flag to for checking on Water District before adding 
to the return Vector(note: this flag is needed by HBSyncWizardGUI which needs
to query the remote database and the check is setup for the local database)
@return a Vector which contains the built where clause string.
@throws Exception if an error occurs.
*/
public String[] getWaterDistrictWhereClause(SimpleJComboBox choice,
String table, boolean displayWarning, boolean checkData)
throws Exception {
	String function = "HydroBaseGUI.getDistrictWhereClause()";
	Vector whereClauses = new Vector();

	String[] ret = new String[2];

        // add where clause for wd
	String select = choice.getSelected().trim();
	if (select == null && displayWarning) {
		Message.printWarning(1, function,
			"You must first select a Division or District.");
		return null;
	}

	boolean hasData = false;
	Vector notFound = new Vector();

	String sp = null;

	// the following is only for post-20050701 SP databases
	if (select.equals(HydroBase_GUI_Util._ALL_DIVISIONS)) {
		ret[0] = "div > -1";
		ret[1] = HydroBase_GUI_Util._ALL_DIVISIONS;
		return ret;
	}

	if (select.equals(HydroBase_GUI_Util._DIVISION_8)) {
		ret[0] = "div = 8";
		ret[1] = HydroBase_GUI_Util._DIVISION_8;
		return ret;
	}

	if (select.startsWith("Division")) {
		String s = select.substring(8);
		int index = s.indexOf(":");
		s = s.substring(0, index);
		sp = "Div " + s;
		index = choice.getSelectedIndex()+ 1;
		while (index <  choice.getItemCount()) {
			String otherSelect = (choice.getItem(index)).trim();
			if (otherSelect.startsWith("Division")
			    || otherSelect.equals(
			    HydroBase_GUI_Util._ALL_DIVISIONS)) {
				break;
			}

			String wd=HydroBase_WaterDistrict.parseWD(otherSelect);
			if (	!checkData || 
				isWaterDistrictAvailable(wd)) {
				hasData = true;
				if (table == null) {
					whereClauses.add("wd = " + wd);
				}
				else {
					whereClauses.add(table 
						+ ".wd = " + wd);
				}
			}
			else {
				notFound.add(otherSelect);
			}
			index++;
		}
	}
	else {
	        String wd = HydroBase_WaterDistrict.parseWD(select);
		sp = "wd " + wd;
		if (!checkData || isWaterDistrictAvailable(wd)) {
			hasData = true;
				if (table == null) {
					whereClauses.add("wd = " + wd);
				}
				else {
					whereClauses.add(table 
						+ ".wd = " + wd);
				}
		}
		else {
			notFound.add(select);
		}
	}

	if (!hasData) {
		String items = "";
		for (int i = 0; i < notFound.size(); i++) {
			items += ("\n   " +(String)notFound.elementAt(i));
		}

		if (displayWarning) {
			Message.printWarning(1, function, 
				"Information for water"
	 			+ " district(s):" + items
				+ "\nis not available in the database.");
		}

		return null;
	}

        String or = DMIUtil.getOrClause(whereClauses);
	ret[0] = or;
	ret[1] = sp;

	return ret;
}

/**
Returns the water district name given the integer identifier, or an empty
string if unknown.  Data is read from the global data.
@param wd the wd of the water district for which to return the name 
@return the water district name given the integer identifier or an empty
string ("") if unknown.
*/
public String getWaterDistrictName ( int wd )
throws Exception {
	Vector waterDistricts = getWaterDistricts();
	// If the global data are available, use it....
	int size = 0;
	if (waterDistricts != null) {
		size = waterDistricts.size();

	}
	HydroBase_WaterDistrict hwd;
	for ( int i = 0; i < size; i++) {
		hwd = (HydroBase_WaterDistrict)waterDistricts.elementAt(i);
		if (hwd.getWD() == wd) {
			return hwd.getWd_name();
		}
	}
	return "";
}

/**
Return the global list of water districts objects, sorted by water district
number.
@return the global list of water districts objects.
*/
public Vector getWaterDistricts() {
	String routine = "getWaterDistricts";
	if (__WaterDistricts_Vector == null) {
		try {
			__WaterDistricts_Vector = readWaterDistrictList(false);
		}
		catch (Exception e) {
			Message.printWarning ( 2, routine,
				"Unable to read WaterDistrict data.");
			Message.printWarning ( 2, routine, e);
		}
		if (__WaterDistricts_Vector == null) {
			__WaterDistricts_Vector = new Vector();
		}
	}

	return __WaterDistricts_Vector;
}

public Vector getWaterDistrictsByDiv() {
	String routine = "getWaterDistrictsByDiv";
	if (__WaterDistrictsByDiv_Vector == null) {
		// read the water district by div data
		try {
			__WaterDistrictsByDiv_Vector = readWaterDistrictList(
				true);
		}
		catch (Exception e) {
			Message.printWarning ( 2, routine,
				"Unable to read WaterDistrict data.");
			Message.printWarning ( 2, routine, e);
		}
		if (__WaterDistrictsByDiv_Vector == null) {
			__WaterDistrictsByDiv_Vector = new Vector();
		}
	}
	return __WaterDistrictsByDiv_Vector;
}

public Vector getWaterDistrictsFromStructures() {
	String routine = "getWaterDistrictsFromStructures";
	if (__WaterDistrictsFromStructures_Vector == null) {
		// read the water district by div data
		try {
			__WaterDistrictsFromStructures_Vector = 
				readStructureDistinctWDList();
		}
		catch (Exception e) {
			Message.printWarning ( 2, routine,
				"Unable to read WaterDistrict data.");
			Message.printWarning ( 2, routine, e);
		}
		if (__WaterDistrictsFromStructures_Vector == null) {
			__WaterDistrictsFromStructures_Vector = new Vector();
		}
	}
	return __WaterDistrictsFromStructures_Vector;
}

/**
Return the global list of water division objects, sorted by water division
number.
@return the global list of water division objects.
*/
public Vector getWaterDivisions() {
	String routine = "getWaterDivisions";
	if (__WaterDivisions_Vector == null) {
		try {
			__WaterDivisions_Vector = readWaterDivisionList();
		}
		catch (Exception e) {
			Message.printWarning ( 2, routine,
				"Unable to read water division data.");
			Message.printWarning ( 2, routine, e);
		}
		if (__WaterDivisions_Vector == null) {
			__WaterDivisions_Vector = new Vector();
		}
	}

	return __WaterDivisions_Vector;
}

/**
Returns the Vector of WIS Structures stored in global data.
@return the Vector of Wis Structures.
*/
public Vector getWISStructuresVector() {
	return __WISStructures_Vector;
}

// H METHODS

/**
Determines if the user has permissions for the specified wd by searching for it 
in the user's water district permission string.
@param wd the water district for which to check permissions.
@return returns true if the current user has permission, false otherwise.
*/
public boolean hasPermission(int wd) {
	return hasPermission("" + wd);
}

/**
Determines if the user has permissions for the specified wd by searching for it 
in the user's water district permission string.
@param s type of permission to check for.
@return returns true if the current user has permission, false otherwise.
*/
public boolean hasPermission(String s) {
	if (!canWriteToDatabase()) {
		return false;
	}
	else if (__userSecurityPermissions.equals(__ALL_PERMISSIONS)) {
		return true;
	}
	Vector v = StringUtil.breakStringList(__userSecurityPermissions, ",",0);
	int size = v.size();
	for (int i = 0; i < size; i++) {
		if (((String)v.elementAt(i)).trim().equals(s)) {
			return true;
		}
	}
	return false;
}

// I METHODS

/**
Returns whether the currently-logged-in user is the guest user.
@return whether the currently-logged-in user is the guest user.
*/
public boolean isGuestLoggedIn() {
	return __isGuest;
}

/**
Returns whether the database contains tables, etc that match the indicated
version.
@param version See VERSION_* definitions.
@return true if the database contains tables, etc., that match the indicated
version.
@throws Exception if there is an error determining the version (e.g.,
unable to get database meta data).
*/
public boolean isVersionAtLeast(long version)
throws Exception {
	String routine = "HydroBaseDMI.isVersionAtLeast";

	if (Message.isDebugOn) {
		Message.printDebug(5, routine,
			"Checking to see if database version is at least " 
			+ version);
	}

	if (version == VERSION_20070525 ) {
		return isVersion20070525();
	}
	else if (version == VERSION_20070502) {
		return isVersion20070502();
	}
	else if (version == VERSION_20070416) {
		return isVersion20070416();
	}
	else if (version == VERSION_20061003) {
		return isVersion20061003();
	}
	else if (version == VERSION_20051115) {
		return isVersion20051115();
	}
	else if (version == VERSION_20050701) {
		return isVersion20050701();
	}
	else if (version == VERSION_20050501) {
		return isVersion20050501() ;
	}
	else if (version == VERSION_20040701) {
		return isVersion20040701();
	}
	else if (version == VERSION_20030701) {
		return isVersion20030701();
	}
	else if (version == VERSION_20010326) {
		return isVersion20010326();
	}
	else if (version == VERSION_20000706) {
		return isVersion20000706();
	}
	else if (version == VERSION_20000427) {
		return isVersion20000427();
	}
	else if (version == VERSION_20000301) {
		return isVersion20000301();
	}
	else if (version == VERSION_19990305) {
		return isVersion19990305();
	}
	else if (version == VERSION_19990202) {
		return isVersion19990202();
	}
	else if (version == VERSION_19980428) {
		return isVersion19980428();
	}
	else if (version == VERSION_19970501) {
		return isVersion19970501();
	}
	else {
		// Unknown version...
		Message.printWarning(2, routine, "Unknown HydroBase database version: " + version );
		return false;
	}
}

/**
Check the database version to see if it matches the original HydroBase
design.  This is generally the fall back.  For now, just see if the
database contains a geoloc, structure, and station table.  Later can add more
constraints if it looks like people are corrupting the databases.
<p>
<ul>
<li>	Has a "geoloc" table.</li>
<li>	Has a "structure" table.</li>
<li>	Has a "station" table.</li>
</ul>
@return true if the version matches the 1997-05-01 version.
*/
public boolean isVersion19970501()
throws Exception {
	String routine = "HydroBaseDMI.isVersion19970501";
	int dl = 5;

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Checking for geoloc, structure, station tables.");
	}
	
	if (!DMIUtil.databaseHasTable(this, "structure")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine, "structure "
				+ "table not found: not 19970501 version");
		}
		return false;
	}
	
	if (!DMIUtil.databaseHasTable(this, "geoloc")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine, "geoloc "
				+ "table not found: not 19970501 version");
		}
		return false;
	}
	
	if (!DMIUtil.databaseHasTable(this, "station")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine, "station "
				+ "table not found: not 19970501 version");
		}
		return false;
	}
	
	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Database is at least 19970501 version");
	}

	return true;
}

/**
Check the database version to see if it matches the databases built on
1998-04-28.  The database version is verified if the following are
true (don't check all the 1998-04-28 conditions):
<p>
<ul>
<li>	Has a "struct_meas_type" table.</li>
</ul>
@return true if the version matches the 1998-04-28 version.
*/
public boolean isVersion19980428()
throws Exception {
	String routine = "HydroBaseDMI.isVersion19980428";
	int dl = 5;

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Checking for struct_meas_type table");
	}
	
	if (!DMIUtil.databaseHasTable(this, "struct_meas_type")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine, "struct_meas_type "
				+ "table not found: not 19980428 version");
		}
		return false;
	}
	
	if (Message.isDebugOn) {
		Message.printDebug(dl, routine, "struct_meas_type "
			+ "table found: is at least 19980428 version");
	}
	
	return true;
}

/**
Check the database version to see if it matches the changes for the 1999-02-02
database release.  The database version is verified if the following are
true (don't check all the 1999-02-02 conditions):
<p>
<ul>
<li>	Has the <i>irrig_summary</i> table.</li>
<li>	The <i>irrig_time_series</i> table has <i>wd</i> and <i>id</i>
	columns.</li>
</ul>
@return true if the version matches the 1999-02-02 version.
*/
public boolean isVersion19990202()
throws Exception {
	String routine = "HydroBaseDMI.isVersion19990202";
	int dl = 5;

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Checking for irrig_summary table.  "
			+ "Checking for irrig_time_series.wd and "
			+ "irrig_time_series.[id]");
	}
	
	if (!DMIUtil.databaseHasTable(this, "irrig_summary")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine, "irrig_summary "
				+ "table not found: not 19990202 version");
		}
		return false;
	}
	
	if (!DMIUtil.databaseTableHasColumn(this, "irrig_time_series", "wd")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"irrig_time_series.wd not found: " 
				+ "not 19990202 version");
		}
		return false;
	}
	
	if (!DMIUtil.databaseTableHasColumn(this, "irrig_time_series", "id")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"irrig_time_series.id not found: "
				+ "not 19990202 version");
		}
		return false;
	}

	// Satisfied all the criteria...

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Database is at least 19990202 version");
	}

	return true;
}

/**
Check the database version to see if it matches the changes noted in the
1999-03-05 memorandum.  The database version is verified if the following are
true (don't check all the 1999-03-05 conditions):
<p>
<ul>
<li>	"contact" table has a "phone_ext" column.</li>
<li>	"county_ref" table has an "abbrev" column.</li>
<li>	"geoloc" table has a "utm_x" column.</li>
<li>	"person_details" table has a "priority" column.</li>
<li>	"rolodex" table has a "lic_no" column.</li>
<li>	"station" table has a "transbsn" column.</li>
<li>	"structure" table has a "transbsn" column.</li>
<li>	"user_security" table has an "application" column.</li>
</ul>
@return true if the version matches the 1999-03-05 version.
*/
public boolean isVersion19990305 ()
throws Exception {
	String routine = "HydroBaseDMI.isVersion19990305";
	int dl = 5;
	
	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Checking for contact.phone_ext.\n"
			+ "Checking for county_ref.abbrev.\n"
			+ "Checking for geoloc.utm_x.\n"
			+ "Checking for person_details.priority.\n"
			+ "Checking for rolodex.lic_no.\n" 
			+ "Checking for station.transbsn.\n" 
			+ "Checking for structure.transbsn.\n" 
			+ "Checking for user_security.application.");
	}
	
	if (!DMIUtil.databaseTableHasColumn(this, "contact", "phone_ext")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"contact.phone_ext not found: not 19990305 "
				+ "version");
		}
		return false;
	}
	
	if (!DMIUtil.databaseTableHasColumn(this, "county_ref","abbrev")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"county_ref.abbrev not found: not 19990305 "
				+ "version");
		}
		return false;
	}
	
	if (!DMIUtil.databaseTableHasColumn(this, "geoloc", "utm_x")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"geoloc.utm_x not found: not 19990305 version");
		}
		return false;
	}
	
	if (!DMIUtil.databaseTableHasColumn(this, "person_details", 
		"priority")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"person_details.priority not found: "
				+ "not 19990305 version");
		}
		return false;
	}
	
	if (!DMIUtil.databaseTableHasColumn(this, "rolodex", "lic_no")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"rolodex.lic_no not found: not 19990305 "
				+ "version");
		}
		return false;
	}
	
	if (!DMIUtil.databaseTableHasColumn(this, "station", "transbsn")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"station.transbsn not found: not 19990305 "
				+ "version");
		}
		return false;
	}
	
	if (!DMIUtil.databaseTableHasColumn(this, "structure", "transbsn")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"structure.transbsn not found: not 19990305 "
				+ "version");
		}
		return false;
	}
	
	if (!DMIUtil.databaseTableHasColumn(this, "user_security", 
	    "application")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"user_security.application not found: "
				+ "not 19990305 version");
		}
		return false;
	}

	// Satisfied all the criteria...

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Database is at least 19990305 version");
	}

	return true;
}

/**
Check the database version to see if it matches the changes noted in db_version
between 1999-03-05 and 2000-03-01.
The database version is verified if the following are
true (don't check all the conditions in db_version):
<p>
<ul>
<li>	"geoloc" table has a "elevation" column.</li>
<li>	has well_application and struct_to_well tables
	(however, these are not checked because they may not always be linked
	in).
<li>
</ul>
@return true if the version matches the 2000-03-01 version.
*/
public boolean isVersion20000301 ()
throws Exception {
	String routine = "HydroBaseDMI.isVersion20000301";
	int dl = 5;
	
	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Checking for geoloc.elevation.");
	}
	
	if (!DMIUtil.databaseTableHasColumn(this, "geoloc", "elevation")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"geoloc.elevation not found: not 20000301 "
				+ "version");
		}
		return false;
	}

	// Satisfied all the criteria...

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Database is at least 20000301 version");
	}
	
	return true;
}

/**
Check the database version to see if it matches the 2000-04-27 database,
which includes minor struct_to_well changes from the previous.
The database version is verified if the following are true:
<p>
<ul>
<li>	"struct_to_well" table has a "unique_ditch" column.</li>
</ul>
This version also has "method_desc" added to the cropchar table
@return true if the version matches the 2000-04-27 version.
*/
public boolean isVersion20000427 ()
throws Exception {
	String routine = "HydroBaseDMI.isVersion20000427";
	int dl = 5;
	
	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
		"Checking for struct_to_well.unique_ditch.");
	}
	
	if (!DMIUtil.databaseTableHasColumn(this, "struct_to_well", 
	    "unique_ditch")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"struct_to_well.unique_ditch not found: "
				+ "not 20000427 version");
		}
		return false;
	}

	// Satisfied all the criteria...

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Database is at least 20000427 version");
	}

	return true;
}

/**
Check the database version to see if it matches the 2000-07-06 database.
The 2000-07-06 database includes the following changes:
<ul>
<li>	structure_to_well is changed to well_to_structure
<li>	well_parcels is changed to well_to_parcel
<li>	layers is changed to well_to_layer
</ul>
The database version is verified if the following are true:
<p>
<ul>
<li>	"well_to_structure" table exists.</li>
</ul>
@return true if the version matches the 2000-07-06 version.
*/
public boolean isVersion20000706 ()
throws Exception {
	String routine = "HydroBaseDMI.isVersion20000706";
	int dl = 5;
	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
		"Checking for well_to_structure table.");
	}
	if (!DMIUtil.databaseHasTable(this, "well_to_structure")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
			"well_to_structure table not found: " +
			"not 20000706 version");
		}
		return false;
	}

	// Satisfied all the criteria...

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Database is at least 20000706 version");
	}
	
	return true;
}

/**
Check the database version to see if it matches the 2003-07-01 database.
The 2003-07-01 database includes the following change:
<ul>
<li>	"str_type" table exists.</li>
</ul>
@return true if the version matches the 2003-07-01 version.
*/
public boolean isVersion20030701 ()
throws Exception {
	String routine = "HydroBaseDMI.isVersion20030701";
	int dl = 5;

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Checking for str_type table.");
	}
	
	if (!DMIUtil.databaseHasTable(this, "str_type")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"str_type table not found: "
				+ "not 20030701 version");
		}
		return false;
	}

	// Satisfied all the criteria...

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Database is at least 20030701 version");
	}

	return true;
}

/**
Check the database version to see if it matches the 2001-03-26 database.
The 2001-03-26 database includes the following change:
<ul>
<li>	geoloc.elev is present (used to be geoloc.elevation in RTi version)
</ul>
The database version is verified if the following is true:
<p>
<ul>
<li>	"geoloc.elev" field exists.</li>
</ul>
@return true if the version matches the 2001-03-26 version.
*/
public boolean isVersion20010326 ()
throws Exception {
	String routine = "HydroBaseDMI.isVersion20010326";
	int dl = 5;
	
	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Checking for well_to_structure table.");
	}
	
	if (!DMIUtil.databaseTableHasColumn(this, "geoloc", "elev")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"geoloc.elev field not found: "
				+ "not 20010326 version");
		}
		return false;
	}

	// Satisfied all the criteria...

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Database is at least 20010326 version");
	}
	
	return true;
}

/**
Check the database version to see if it matches the 2004-07-01 database.
The 2004-07-01 database includes the following change:
<ul>
<li>	"Agricultural_NASS_Crop_stats" table exists.</li>
</ul>
@return true if the version matches the 2004-07-01 version.
*/
public boolean isVersion20040701 ()
throws Exception {
	String routine = "HydroBaseDMI.isVersion20040701";
	int dl = 5;

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Checking for Agricultural_NASS_Crop_stats table.");
	}
	
	if (!DMIUtil.databaseHasTable(this, "Agricultural_NASS_Crop_stats")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
			"Agricultural_NASS_Crop_stats table not found: "
			+ "not 20040701 version");
		}
		return false;
	}

	// Satisfied all the criteria...

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Database is at least 20040701 version");
	}

	return true;
}

/**
Check the database version to see if it matches the 2005-05-01 database.
The 2005-05-01 database includes the following change:<p>
<ul>
<li>usp_CDSS_refCounty_Sel stored procedure can be set up.</li>
</ul><p>
This method will also return true if the ref_county table can be found.  This
means it is the Access database version.
@return true if the version matches the 2005-05-01 version.
*/
public boolean isVersion20050501 ()
throws Exception {
	String routine = "HydroBaseDMI.isVersion20050501";
	int dl = 5;

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Checking to see if stored procedures are available.");
	}

	DMISelectStatement q = new DMISelectStatement(this);
	if (canSetUpStoredProcedure(q, __S_REF_COUNTY)) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"Stored procedure could be set up.");
		}
		// any stored procedure availability (at current)
		// means it's the latest database available
		return true;
	}

	// Stored procedures aren't available, but perhaps it's the 
	// Access version.

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Checking for ref_county table.");
	}
	
	if (!DMIUtil.databaseHasTable(this, "ref_county")) {
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"ref_county table not found: not 20050501 "
				+ "version");
		}
		return false;
	}

	// Satisfied all the criteria...

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Database is at least 20050501 version");
	}

	return true;
}

/**
Check the database version to see if it matches the 2005-07-01 database.
The 2005-07-01 database includes the following change:<p>
<ul>
<li>usp_CDSS_Geophlogs_Sel stored procedure available</li>
</ul><p>
Alternately, the volcanics table is checked for the structure_num field.  If 
found, this is the final Access version.
@return true if the version matches the 2005-07-01 version.
*/
public boolean isVersion20050701 ()
throws Exception {
	String routine = "HydroBaseDMI.isVersion20050701";
	int dl = 5;

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Checking to see if usp_CDSS_Geophlogs_Sel stored "
				+ "procedure is available.");
	}

	if (!DMIUtil.databaseHasStoredProcedure(this,"usp_CDSS_Geophlogs_Sel")){
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"Stored procedure was not found.");
		}
		return false;
	}

	// the following is for non-SP databases

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Checking for volvanics.structure_num field.");
	}

	if (DMIUtil.databaseTableHasColumn(this, "volcanics", "structure_num")){
		if (Message.isDebugOn) {
			Message.printDebug(dl, routine,
				"volcanics.structure_num found: "
				+ "not 20050701 version");
		}
		return false;
	}

	// Satisfied all the criteria...

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Database is at least 20050701 version");
	}

	return true;
}

/**
Check the database version to see if it matches the 2005-11-15 database.
The 2005-11-15 database includes the following change:<p>
<ul>
<li>The ResultSet generated for the 
vw_CDSS_GroundWaterWellsGroundWaterWellsMeasType view has the DSS_aquifer1
field</li>
</ul><p>
@return true if the version matches the 2005-11-15 version.
*/
public boolean isVersion20051115 ()
throws Exception {
	String routine = "HydroBaseDMI.isVersion20050701";
	int dl = 5;

	if (!DMIUtil.databaseHasStoredProcedure(this, "usp_Flex")) {
		// A non-SP database.  It is definitely not this version.
		return false;
	}

	if (Message.isDebugOn) {
		Message.printDebug(dl, routine,
			"Checking to see if "
			+ "vw_CDSS_GroundWaterWellsGroundWaterWellsMeasType "
			+ "has the DSS_aquifer1 field.");
	}

	String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(null, 
		null);

	// Construct search parameters that will never return a record.  The
	// following will query for all records where identifier is null 
	// AND identifier is not null.
	String[] triplet = new String[3];
	triplet[0] = "identifier";
	triplet[1] = "NL";
	triplet[2] = "1";
	HydroBase_GUI_Util.addTriplet(parameters, triplet);
	triplet = new String[3];
	triplet[0] = "identifier";
	triplet[1] = "NN";
	triplet[2] = "1";
	HydroBase_GUI_Util.addTriplet(parameters, triplet);
	
	// NOTE:
	// The view number hashtable has not been set up by the time this
	// method is called automatically in super.open() to determine the
	// version.  Thus, the view number associated internally in the 
	// database with the view ("78") is passed in as a number String,
	// rather than as a name.
	HydroBase_GUI_Util.fillSPParameters(parameters, "78", 83, null);
	ResultSet rs = runSPFlex(parameters);
	boolean hasField = DMIUtil.resultSetHasColumn(rs, "DSS_aquifer1");
	closeResultSet(rs, __lastStatement);

	return hasField;
}

/**
Check the database version to see if it matches the 2006-10-03 database.
The 2006-10-03 database includes the following change:<p>
<ul>
<li>The view vw_CDSS_CUPopulation was added.</li>
</ul><p>
@return true if the version matches the 2006-10-03 version.
*/
public boolean isVersion20061003 ()
throws Exception {
	// Checking for a view is treated like checking for a table...
	if ( DMIUtil.databaseHasTable(this,"vw_CDSS_CUPopulation")) {
		return true;
	}
	return false;
}

/**
Check the database version to see if it matches the 2007-04-16 database,
which includes the following changes:<p>
<ul>
<li>The stored procedure usp_CDSS_ParcelUseTSStructureToParcel_Sel_By_StructureNumCalYear was added.</li>
</ul><p>
@return true if the version matches the 2007-04-16 version.
*/
private boolean isVersion20070416 ()
throws Exception {
	String routine = "HydroBaseDMI.isVersion20070416";
	if (!DMIUtil.databaseHasStoredProcedure(this,"usp_CDSS_ParcelUseTSStructureToParcel_Sel_By_StructureNumCalYear")){
		if (Message.isDebugOn) {
			Message.printDebug(10, routine,
				"Stored procedure " +
				"usp_CDSS_ParcelUseTSStructureToParcel_Sel_By_StructureNumCalYear " +
				" was not found.");
		}
		return false;
	}

	return true;
}

/**
Check the database version to see if it matches the 2007-05-02 database,
which includes the following changes:<p>
<ul>
<li>The view vw_CDSS_DailyAdminFlow was added.</li>
<li>The view number for vw_CDSS_DailyAdminFlow is available in the internal
view lookup table in HydroBase.</li>
</ul><p>
@return true if the version matches the 2007-05-02 version.
*/
private boolean isVersion20070502 ()
throws Exception {
	String routine = "HydroBaseDMI.isVersion20070502";
	// Checking for a view is treated like checking for a table...
	if ( !DMIUtil.databaseHasTable(this,"vw_CDSS_DailyAdminFlow") ) {
		if ( Message.isDebugOn ) {
			Message.printDebug ( 1, routine,
				"HydroBase does not have view vw_CDSS_DailyAdminFlow - not version 20070502");
		}
		return false;
	}
	/* TODO SAM 2007-05-11 Need to get this to work.  Need to pass
	'CDSS' as the only parameter to the stored procedure.
	if ( !isViewNumberAvailable ( "113" ) ) {
		if ( Message.isDebugOn ) {
			Message.printDebug ( 1, routine,
				"HydroBase does not have view 113 - not version 20070502");
		}
		return false;
	}
	*/

	return true;
}

/**
Check the database version to see if it matches the 2007-05-25 database,
which includes the following changes:<p>
<ul>
<li>The view vw_CDSS_WellsWellToParcel includes the yield_apex column.</li>
</ul><p>
@return true if the version matches the 2007-05-02 version.
*/
private boolean isVersion20070525 ()
throws Exception {
	String routine = "HydroBaseDMI.isVersion20070525";
	if (!DMIUtil.databaseTableHasColumn(this, "vw_CDSS_WellsWellToParcel", "yield_apex")) {
		if (Message.isDebugOn) {
			Message.printDebug(30, routine,
				"vw_CDSS_WellsWellToParcel does not have yield_apex: "
				+ "not 20070525 version");
		}
		return false;
	}

	return true;
}

/**
Determine whether a view number is available in HydroBase for use with its SPFLEX
features.  The usp_Developer_FLEX_codes stored procedure is executed and
the "View Code" column is checked for the requested number.
@param view View number as a String (later may allow view name).
*/
private boolean isViewNumberAvailable ( String view )
{	int view_int = -1;
    if ( StringUtil.isInteger(view) ) {
		// Checking the view number
		view_int = StringUtil.atoi ( view );
	}
    boolean found_view = false;	// Whether view is found
	DMISelectStatement q = new DMISelectStatement(this);
	try {
		if (canSetUpStoredProcedure(q,__S_DEVELOPER_FLEX_CODES)) {
			ResultSet rs = dmiSelect(q);
			int i = 0;
			while (rs.next()) {
				// First column is view code.
				i = rs.getInt(1);
				if (!rs.wasNull()) {
					if ( view_int == i ) {
						found_view = true;
						break;
					}
				}
			}
			closeResultSet(rs, __lastStatement);
			return found_view;
		}
		else {
			return false;			
		}
	}
	catch (Exception e) {
		Message.printWarning(2, "HydroBaseDMI.isViewNumberAvailable", e);
		return false;
	}
}

/**
Returns true if the water district is available in HydroBase, as determined 
by which water districts were returned from a distrinct query on 
the HydroBase_Structures list.
@param num int Water district number.
@return true If the water district is available. This is determined
by which water districts were returned from a distinct query on the
HydroBase_Structures list.
*/
public boolean isWaterDistrictAvailable(int num) {
	return isWaterDistrictAvailable(new Integer(num));
}

/**
Returns whether the specified water district is available in HydroBase, as 
determined by which water disricts were returned from a distinct query on the 
HydroBase_Structures list.
@param num String Water district number.
@return true If the water district is available. This is determined
by which water districts were returned from a distinct query on the
HydroBase_Structures list.
*/
public boolean isWaterDistrictAvailable(String num) {
	num.trim();
	return isWaterDistrictAvailable(new Integer(num));
}

/**
Returns whether the specified water district is available, as determined by 
which water districts were returned from a distinct query on the 
HydroBase_Structures list.
@param num Water district number.
@return true If the water district is available. This is determined
by which water districts were returned from a distinct query on the
HydroBase_Structures list.
*/
public boolean isWaterDistrictAvailable(Integer num) {
	Vector v = getWaterDistrictsFromStructures();
	int size = v.size();

	for (int i = 0; i < size; i++) {
		if (num.equals((Integer)v.elementAt(i))) {
			return true;
		}
	}
	return false;
}

// J METHODS
// K METHODS
// L METHODS

/**
Returns the county name associated with the given county id in the 
__CountyRef_Vector, using global data.
@param countyID the number for which to return the county name.
@return the county name associated with the given county id.
*/
public String lookupCountyName(int countyID) {
	Vector v = getCountyRef();
	if (v == null) {
		return null;
	}
	HydroBase_CountyRef c = null;
	for (int i = 0; i < v.size(); i++) {
		c = (HydroBase_CountyRef)v.elementAt(i);
		if (c.getCty() == countyID) {
			return c.getCounty();
		}
	}
	return null;
}

/**
Returns the description for a CIU given the CIU code.
@param code the CIU code that matches a code within ref_ciu.
@return the description that matches the code, or null if none could be 
found.
*/
public String lookupCIUDescription(String code) {
	HydroBase_RefCIU ref = null;
	Vector refCIU = getCIUVector();
	int size = refCIU.size();
	for (int i = 0; i < size; i++) {
		ref = (HydroBase_RefCIU)refCIU.elementAt(i);
		if (ref.getCode().equalsIgnoreCase(code)) {
			return ref.getDescription();
		}
	}
	return null;
}

/**
This function returns a String array of the time interval specified in the 
user's preferences.  The values are read from the internal preferences data
read for the user when they logged in.<p>
NOTE: position 0 in the returned array corresponds to the 'FROM' time.<p>
Position 1 in the returned array correponds to the the 'TO' time.
@return an array of the time interval. 
*/
public String[] lookupInterval() {
	String[]        interval;       // interval to return
        DateTime tsDate;
	String		property = null;

        // initialize variables
        interval = new String[2];

        // if 'PastFlag' = 1 then we need to calculate the interval based on the
        // the system time and the 'PastValue' preference
	property = getPreferenceValue("Time.PastFlag");
	if ((property == null) || property.equals("NONE")) {
		property = "1";
		setPreferenceValue ( "Time.PastFlag", property);
	}
	else {
		property = property.trim();
	}
	if (property.equals("1")) {
                tsDate = new DateTime( DateTime.DATE_CURRENT |
				DateTime.PRECISION_MINUTE);

                // the 'TO' interval is built according to the local machine
		// time
		interval[1] =tsDate.toString(DateTime.FORMAT_YYYY_MM_DD_HH_mm);

                // the 'FROM' interval is built according to the local machine
		// time minus the 'PastValue' preference
		String past_value = getPreferenceValue("Time.PastValue");
		if ((past_value == null) || past_value.equals("NONE")) {
			// Default to 24 hours...
			past_value = "24";
			setPreferenceValue ( "Time.PastValue", past_value);
		}
                int pastHours = Integer.parseInt( past_value);
                tsDate.addHour( - pastHours);
		interval[0]=tsDate.toString( DateTime.FORMAT_YYYY_MM_DD_HH_mm);
        } 

        else {
		// otherwise the interval based is based on the 'IntervalStart'
		// and 'IntervalEnd' preferences.
		// It is unlikely that these values are not set if the main
		// flag is but if either are not set, default to current time
		// and current time - 24 hours.
		String end = getPreferenceValue("Time.IntervalEnd");
		if ((end == null) || end.equals("NONE")) {
			tsDate = new DateTime( DateTime.DATE_CURRENT |
					DateTime.PRECISION_MINUTE);

			end =tsDate.toString(DateTime.FORMAT_YYYY_MM_DD_HH_mm);
			setPreferenceValue ( "Time.IntervalEnd", end);
		}
		String start = getPreferenceValue("Time.IntervalStart");
		if ((start == null) || start.equals("NONE")) {
			tsDate = new DateTime( DateTime.DATE_CURRENT |
					DateTime.PRECISION_MINUTE);
			tsDate.addHour ( -24);
			start=tsDate.toString(DateTime.FORMAT_YYYY_MM_DD_HH_mm);
			setPreferenceValue ( "Time.IntervalStart", start);
		}
		interval[0] = HydroBase_GUI_Util.getUserDate( start);
                interval[1] = HydroBase_GUI_Util.getUserDate( end);
        }                              

	tsDate = null;
	property = null;
        return interval;
}

/**
Returns the use type definition that matches the given xuse type, using global
data.
@param xuse the xuse type for which to return the use definition.
@return the use type definition for the given xuse.
@throws Exception if an error occurs.
*/
public String lookupUseDefinitionForXUse(String xuse) 
throws Exception {
	HydroBase_Use u = null;
	Vector useTypes = getUseTypes();
	int size = useTypes.size();
	for (int i = 0; i < size; i++) {
		u = (HydroBase_Use)useTypes.elementAt(i);
		if (u.getXuse().equalsIgnoreCase(xuse)) {
			return u.getUse_def();
		}
	}
	return null;
}

/**
Returns the use type definition that matches the given use type, using global
data.
@param use the use type for which to return the use definition.
@return the use type definition for the given use.
@throws Exception if an error occurs.
*/
public String lookupUseDefinitionForUse(String use) 
throws Exception {
	HydroBase_Use u = null;
	Vector useTypes = getUseTypes();
	int size = useTypes.size();
	for (int i = 0; i < size; i++) {
		u = (HydroBase_Use)useTypes.elementAt(i);
		if (u.getUse().equalsIgnoreCase(use)) {
			return u.getUse_def();
		}
	}
	return null;
}

/**
Returns the list of all water districts given a division using global data.
@param div Division of interest.
@return The list of all water districts given a division.
@throws Exception if an error occurs.
*/
public Vector lookupWaterDistrictsForDivision(int div)
throws Exception {
	HydroBase_WaterDistrict w;
	Vector waterDistrictsByDiv = getWaterDistrictsByDiv();
	int size = waterDistrictsByDiv.size();
	Vector waterDistricts = new Vector();	
	for (int i = 0; i < size; i++) {
		w = (HydroBase_WaterDistrict)
			waterDistrictsByDiv.elementAt(i);
		if (w.getDiv() == div) {
			// Add to the list...
			waterDistricts.add(w);
		}
	}
	return waterDistricts;
}

/**
Returns the water district value associated with a wd using global data.
@param wd the water district for which to return full data
@return the water district value associated with a wd num
@throws Exception if an error occurs.
*/
public HydroBase_WaterDistrict lookupWaterDistrictForWD(int wd)
throws Exception {
	HydroBase_WaterDistrict w;
	Vector waterDistrictsByDiv = getWaterDistrictsByDiv();
	int size = waterDistrictsByDiv.size();
	for (int i = 0; i < size; i++) {
		w = (HydroBase_WaterDistrict)
			waterDistrictsByDiv.elementAt(i);
		if (w.getWD() == wd) {
			return w;
		}
	}
	return null;
}

/**
Returns the water division for a district using global data, or -1 if not found.
@param district the district for which to return the water division.
@return the water division for a district, or -1 if not found.
@throws Exception if an error occurs.
*/
public int lookupWaterDivisionForDistrict(int district)
throws Exception {
	HydroBase_WaterDistrict w;		
	Vector waterDistrictsByDiv = getWaterDistrictsByDiv();
	int size = waterDistrictsByDiv.size();
	for (int i = 0; i < size; i++) {
		w = (HydroBase_WaterDistrict)
			waterDistrictsByDiv.elementAt(i);
		if (w.getWD() == district) {
			return w.getDiv();
		}
	}
	return -1;
}

// M METHODS
// N METHODS
// O METHODS

/**
Called when the DMI is opened.  This overrides the superclass DMI so that for
stored procedure databases the view numbers hashtable can be set up.  
super.open() is called first in this method, prior to any other setup.
*/
public void open() 
throws Exception, java.sql.SQLException {
	if (__localPorts == null) {
		super.open();
	}
	else {
		try {
			super.open();
		}
		catch (Throwable t) {
			setPort(__localPorts[1]);
			super.open();
		}
	}
	if (__useSP) {
		setupViewNumbersHashtable();
	}
}

// P METHODS

/**
Returns whether the property associated with the given keyword has been 
changed in the current session.
@return true if the property has changed, false otherwise.
*/
public boolean preferenceIsModified(String keyword) {
	if (__prefsProps.getProp(keyword) == null 
		|| __prefsProps.getProp(keyword).getHowSet() == 
		Prop.SET_AT_RUNTIME_BY_USER) {
		return true;
	}
	return false;
}

/**
Returns false.  From TSProductAnnotationProvider.
*/
public boolean provides(String name) {
	return false;
}

// Q METHODS
// R METHODS

/**
Read the HydroBase agricultural_CASS_crop_stats table.<p>
This method is used by:<ul>
<li>readTimeSeries()</li>
</ul>
<b>Stored Procedures</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_AgriculturalCASSCropStats_Distinct</li>
<li>vw_CDSS_AgriculturalCASSCropStats</li></ul><p>
@param panel the panel with the query constraints.  If null, it will not be 
used.
@param county The county for the query - specify null or blank to ignore.
@param commodity The commodity for the query - specify null or blank to ignore.
@param practice The practice for the query - specify null or blank to ignore.
@param req_date1 If not null, specify the start date for the query.  Will be
ignored for distinct queries.
@param req_date2 If not null, specify the end date for the query.  Will be
ignored for distinct queries.
@param distinct if set to true, then only data for distinct
state/county/commodity/practice records will be returned.
@return a Vector of HydroBase_Agstats.
@throws Exception if an error occurs.
*/
public Vector readAgriculturalCASSCropStatsList(InputFilter_JPanel panel,
String county, String commodity, String practice, DateTime req_date1, 
DateTime req_date2, boolean distinct) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			panel, null);

		String[] triplet = null;
		if (county != null && county.length() > 0) {
			triplet = new String[3];
			triplet[0] = "county";
			triplet[1] = "MA";
			triplet[2] = county;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (commodity != null && commodity.length() > 0) {
			triplet = new String[3];
			triplet[0] = "commodity";
			triplet[1] = "MA";
			triplet[2] = commodity;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (practice != null && practice.length() > 0) {
			triplet = new String[3];
			triplet[0] = "practice";
			triplet[1] = "MA";
			triplet[2] = practice;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (!distinct && req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (!distinct && req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "LE";
			triplet[2] = "" + req_date2.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (distinct) {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber(
				"vw_CDSS_AgriculturalCASSCropStats_Distinct"), 
				2, null);
			ResultSet rs = runSPFlex(parameters);
			Vector v = toAgriculturalCASSCropStatsSPList(rs, true);
			closeResultSet(rs, __lastStatement);
			return v;					
		}
		else {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber(
				"vw_CDSS_AgriculturalCASSCropStats"), 
				1, null);
			ResultSet rs = runSPFlex(parameters);
			Vector v = toAgriculturalCASSCropStatsSPList(rs, false);
			closeResultSet(rs, __lastStatement);
			return v;					
		}		
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		if (distinct) {
			buildSQL(q, __S_AGRICULTURAL_CASS_CROP_STATS_DISTINCT);
			q.selectDistinct(true);
		}
		else {
			buildSQL(q, __S_AGRICULTURAL_CASS_CROP_STATS);
		}
		Vector wheres 
			= HydroBase_GUI_Util.getWhereClausesFromInputFilter(
			this, panel);		
		if (wheres != null) {
			// Use what was given...
			q.addWhereClauses(wheres);
		}
		if ((county != null) && (county.length() != 0)) {
			q.addWhereClause(
				"agricultural_CASS_crop_stats.county = '" +
				county + "'");
		}
		if ((commodity != null) && (commodity.length() != 0)) {
			q.addWhereClause(
				"agricultural_CASS_crop_stats.commodity = '"+
				commodity + "'");
		}
		if ((practice != null) && (practice.length() != 0)) {
			q.addWhereClause(
				"agricultural_CASS_crop_stats.practice = '" +
				practice + "'");
		} 
		if (!distinct && req_date1 != null) {
			q.addWhereClause(	
				"agricultural_CASS_crop_stats.cal_year >=" +
				req_date1.getYear());
		}
		if (!distinct && req_date2 != null) {
			q.addWhereClause(
				"agricultural_CASS_crop_stats.cal_year <=" +
				req_date2.getYear());
		}
		// Default...
		q.addOrderByClause("agricultural_CASS_crop_stats.st");
		q.addOrderByClause(
			"agricultural_CASS_crop_stats.county");
		q.addOrderByClause(
			"agricultural_CASS_crop_stats.commodity");
		q.addOrderByClause(
			"agricultural_CASS_crop_stats.practice");
		if (!distinct) {
			q.addOrderByClause(
			       "agricultural_CASS_crop_stats.cal_year");
		}
		
		ResultSet rs = dmiSelect(q);
		Vector v = toAgriculturalCASSCropStatsList(rs, distinct);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the HydroBase agricultural_CASS_livestock_stats table.<p>
This method is used by:<ul>
<li>readTimeSeries()</li>
</ul>
<b>Stored Procedures</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_AgriculturalCASSLivestockStats_Distinct</li>
<li>vw_CDSS_AgriculturalCASSLivestockStats</li></ul><p>
@param panel the panel with the query constraints.  If null, it will not be 
used.
@param county The county for the query - specify null or blank to ignore.
@param commodity The commodity for the query - specify null or blank to ignore.
@param type The livestock type for the query - specify null or blank to ignore.
@param req_date1 If not null, specify the start date for the query.  Will be
ignored for distinct queries.
@param req_date2 If not null, specify the end date for the query.  Will be
ignored for distinct queries.
@param distinct if set to true, then only data for distinct
state/county/commodity/type records will be returned.
@return a Vector of HydroBase_Agstats.
@throws Exception if an error occurs.
*/
public Vector readAgriculturalCASSLivestockStatsList(InputFilter_JPanel panel,
String county, String commodity, String type, DateTime req_date1, 
DateTime req_date2, boolean distinct ) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			panel, null);

		String[] triplet = null;
		if (county != null && county.length() > 0) {
			triplet = new String[3];
			triplet[0] = "county";
			triplet[1] = "MA";
			triplet[2] = county;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (commodity != null && commodity.length() > 0) {
			triplet = new String[3];
			triplet[0] = "commodity";
			triplet[1] = "MA";
			triplet[2] = commodity;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (type != null && type.length() > 0) {
			triplet = new String[3];
			triplet[0] = "type";
			triplet[1] = "MA";
			triplet[2] = type;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (!distinct && req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (!distinct && req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "LE";
			triplet[2] = "" + req_date2.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (distinct) {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber(
				"vw_CDSS_AgriculturalCASSLivestockStats_Distinct"), 
				111, null);
			ResultSet rs = runSPFlex(parameters);
			Vector v = toAgriculturalCASSLivestockStatsSPList(rs,
				true);
			closeResultSet(rs, __lastStatement);
			return v;					
		}
		else {	// For time series, order by distinct fields + year...
			// This is the default inside the HydroBase view.
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber(
				"vw_CDSS_AgriculturalCASSLivestockStats"), 
				-999, null);
			ResultSet rs = runSPFlex(parameters);
			Vector v = toAgriculturalCASSLivestockStatsSPList(rs,
				false);
			closeResultSet(rs, __lastStatement);
			return v;					
		}		
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		if (distinct) {
			buildSQL(q, __S_AGRICULTURAL_CASS_LIVESTOCK_STATS_DISTINCT);
			q.selectDistinct(true);
		}
		else {
			buildSQL(q, 
				__S_AGRICULTURAL_CASS_LIVESTOCK_STATS);
		}
		Vector wheres 
			= HydroBase_GUI_Util.getWhereClausesFromInputFilter(
			this, panel);		
		if (wheres != null) {
			// Use what was given...
			q.addWhereClauses(wheres);
		}
		if ((county != null) && (county.length() != 0)) {
			q.addWhereClause(
				"agricultural_CASS_livestock_stats.county = '" +
				county + "'");
		}
		if ((commodity != null) && (commodity.length() != 0)) {
			q.addWhereClause(
				"agricultural_CASS_livestock_stats.commodity = '"+
				commodity + "'");
		}
		if ((type != null) && (type.length() != 0)) {
			q.addWhereClause(
				"agricultural_CASS_livestock_stats.type = '" +
				type + "'");
		} 
		if (!distinct && req_date1 != null) {
			q.addWhereClause(	
				"agricultural_CASS_livestock_stats.cal_year >=" +
				req_date1.getYear());
		}
		if (!distinct && req_date2 != null) {
			q.addWhereClause(
				"agricultural_CASS_livestock_stats.cal_year <=" +
				req_date2.getYear());
		}
		// Default...
		q.addOrderByClause("agricultural_CASS_livestock_stats.st");
		q.addOrderByClause(
			"agricultural_CASS_livestock_stats.county");
		q.addOrderByClause(
			"agricultural_CASS_livestock_stats.commodity");
		q.addOrderByClause(
			"agricultural_CASS_livestock_stats.practice");
		if (!distinct) {
			q.addOrderByClause(
			       "agricultural_CASS_livestock_stats.cal_year");
		}
		
		ResultSet rs = dmiSelect(q);
		Vector v = toAgriculturalCASSLivestockStatsList(rs, distinct);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the HydroBase agricultural_NASS_crop_stats table.<p>
This method is used by:<ul>
<li>readTimeSeries()</li>
</ul>
The where clauses and order by clauses are all dependent on the variables passed
in to the method.<p>
<b>Stored Procedures</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_AgriculturalNASSCropStats_Distinct</li>
<li>vw_CDSS_AgriculturalNASSCropStats</li></ul><p>
@param panel the panel with the query constraints.  If null, it will not be 
used.
@param county The county for the query - specify null or blank to ignore.
@param commodity The commodity for the query - specify null or blank to ignore.
@param req_date1 If not null, specify the start date for the query.  Ignored
if the query is distinct.
@param req_date2 If not null, specify the end date for the query.  Ignore if
the query is distinct.
@param distinct if set to true, then only data for distinct
state/county/commodity/practice records will be returned.
@return a Vector of HydroBase_Agstats.
@throws Exception if an error occurs.
*/
public Vector readAgriculturalNASSCropStatsList(InputFilter_JPanel panel,
String county, String commodity, DateTime req_date1, DateTime req_date2, 
boolean distinct) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			panel, null);

		String[] triplet = null;

		if (county != null && county.length() > 0) {
			triplet = new String[3];
			triplet[0] = "county";
			triplet[1] = "MA";
			triplet[2] = county;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (commodity != null && commodity.length() > 0) {
			triplet = new String[3];
			triplet[0] = "commodity";
			triplet[1] = "MA";
			triplet[2] = commodity;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (!distinct && req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (!distinct && req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "LE";
			triplet[2] = "" + req_date2.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (distinct) {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber(
				"vw_CDSS_AgriculturalNASSCropStats_Distinct"), 
				4, null);
			ResultSet rs = runSPFlex(parameters);
			Vector v = toAgriculturalNASSCropStatsSPList(rs, true);
			closeResultSet(rs, __lastStatement);
			return v;			
		}
		else {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber(
				"vw_CDSS_AgriculturalNASSCropStats"), 
				3, null);
			ResultSet rs = runSPFlex(parameters);
			Vector v = toAgriculturalNASSCropStatsSPList(rs, false);
			closeResultSet(rs, __lastStatement);
			return v;				
		}		
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		if (distinct) {
			buildSQL(q, __S_AGRICULTURAL_NASS_CROP_STATS_DISTINCT);
			q.selectDistinct(true);
		}
		else {
			buildSQL(q, __S_AGRICULTURAL_NASS_CROP_STATS);
		}
		Vector wheres 
			= HydroBase_GUI_Util.getWhereClausesFromInputFilter(
			this, panel);		
		if (wheres != null) {
			// Use what was given...
			q.addWhereClauses(wheres);
		}
		if ((county != null) && (county.length() != 0)) {
			q.addWhereClause(
				"agricultural_NASS_crop_stats.county = '" +
				county + "'");
		}
		if ((commodity != null) && (commodity.length() != 0)) {
			q.addWhereClause(
				"agricultural_NASS_crop_stats.commodity = '"+
				commodity + "'");
		}
		if (req_date1 != null) {
			q.addWhereClause(	
				"agricultural_NASS_crop_stats.cal_year >=" +
				req_date1.getYear());
		}
		if (req_date2 != null) {
			q.addWhereClause(
				"agricultural_NASS_crop_stats.cal_year <=" +
				req_date2.getYear());
		}
		q.addOrderByClause("agricultural_NASS_crop_stats.st");
		q.addOrderByClause(
			"agricultural_NASS_crop_stats.county");
		q.addOrderByClause(
			"agricultural_NASS_crop_stats.commodity");
		if (!distinct) {
			q.addOrderByClause(
			       "agricultural_NASS_crop_stats.cal_year");
		}
		else {
			// Use what was given...
			q.addOrderByClauses ( wheres);
		}
		
		ResultSet rs = dmiSelect(q);
		Vector v = toAgriculturalNASSCropStatsList(rs, distinct);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the AnnualAmt table for all data and use struct_meas_type
Order results by annual_amt.irr_year.<p>
This method is used by:<ul>
<li>readTimeSeries()</li>
<li>HydroBase_Report_StructureSummary.submitAnnualAmtQuery()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_Annual_Amt</li></ul>
@param meas_num struct_meas_type.meas_num for query.
@param req_date1 If not null, specify the start date for the query.
@param req_date2 If not null, specify the end date for the query.
@return a Vector of HydroBase_AnnualAmt objects.
@throws Exception if an error occurs.
*/
public Vector readAnnualAmtList(int meas_num, DateTime req_date1,
DateTime req_date2) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		String[] triplet = new String[3];
		triplet[0] = "meas_num";
		triplet[1] = "EQ";
		triplet[2] = "" + meas_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		if (req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "irr_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "irr_year";
			triplet[1] = "LE";
			triplet[2] = "" + (req_date2.getYear() + 1);
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Annual_Amt"), 5, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toAnnualAmtList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_ANNUAL_AMT);
		q.addWhereClause("annual_amt.meas_num = " + meas_num);
		// Appliation requests are in calendar year so make sure that 
		// the irrigation years span the requested calendar year.
		if (req_date1 != null) {
			q.addWhereClause("annual_amt.irr_year >=" +
				req_date1.getYear());
		}
		if (req_date2 != null) {
			q.addWhereClause("annual_amt.irr_year <=" +
				(req_date2.getYear() + 1));
		}
		q.addOrderByClause("annual_amt.irr_year");
		ResultSet rs = dmiSelect(q);
		Vector v = toAnnualAmtList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the annual_res table for all data.  Order results first by
annual_res.irr_year,
This is used by:<ul>
<li>readTimeSeries()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_Annual_Res</li></ul>
@param meas_num struct_meas_type.meas_num for query.
@param req_date1 If not null, specify the start date for the query.
@param req_date2 If not null, specify the end date for the query.
@return a Vector of HydroBase_ResEOM objects.
@throws Exception if an error occurs.
*/
public Vector readAnnualResList(int meas_num, DateTime req_date1,
DateTime req_date2) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		String[] triplet = new String[3];
		triplet[0] = "meas_num";
		triplet[1] = "EQ";
		triplet[2] = "" + meas_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		if (req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "irr_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "irr_year";
			triplet[1] = "LE";
			triplet[2] = "" + req_date2.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Annual_Res"), 6, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toAnnualResSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_ANNUAL_RES);
		q.addWhereClause("annual_res.meas_num = " + meas_num);
		if (req_date1 != null) {
			q.addWhereClause("irr_year >=" + req_date1.getYear());
		}
		if (req_date2 != null) {
			q.addWhereClause("irr_year <=" + req_date2.getYear());
		}
		q.addOrderByClause("annual_res.irr_year");
		ResultSet rs = dmiSelect(q);
		Vector v = toAnnualResList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the AnnualWC table for the specified meas_type.
Order results by annual_wc.irr_year.<p>
This method is used by:<ul>
<li>readTimeSeries()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_Annual_WC</li></ul>
@param meas_num struct_meas_type.meas_num for query.
@param req_date1 If not null, specify the start date for the query.
@param req_date2 If not null, specify the end date for the query.
@return a Vector of HydroBase_AnnualWC objects.
@throws Exception if an error occurs.
*/
public Vector readAnnualWCList(int meas_num, DateTime req_date1,
DateTime req_date2) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		String[] triplet = new String[3];
		triplet[0] = "meas_num";
		triplet[1] = "EQ";
		triplet[2] = "" + meas_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		if (req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "irr_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "irr_year";
			triplet[1] = "LE";
			triplet[2] = "" + (req_date2.getYear() + 1);
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Annual_WC"), 7, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toAnnualWCList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_ANNUAL_WC);
		q.addWhereClause("annual_wc.meas_num = " + meas_num);
		// Appliation requests are in calendar year so make sure 
		// that the irrigation years span the requested calendar year.
		if (req_date1 != null) {
			q.addWhereClause("annual_wc.irr_year >=" +
				req_date1.getYear());
		}
		if (req_date2 != null) {
			q.addWhereClause("annual_wc.irr_year <=" +
				(req_date2.getYear() + 1));
		}
		q.addOrderByClause("annual_wc.irr_year");
		ResultSet rs = dmiSelect(q);
		Vector v = toAnnualWCList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Reads all the Aquifer records from the database.
@return a Vector of HydroBase_Aquifer objects.
@throws Exception if an error occurs.
*/
public Vector readAquiferRefList() 
throws Exception {
	if (!__useSP) {
		return new Vector();
	}

	if (getDatabaseVersion() < VERSION_20051115) {
		return new Vector();
	}
	
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_AQUIFER);
	ResultSet rs = dmiSelect(q);
	Vector v = toAquiferList(rs);
	closeResultSet(rs, q);
	return v;
}

/**
Read the HydroBase Area_cap table for all data with the matching 
structure_num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_ReservoirData.submitAndDisplayAreaCapQuery</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_AreaCap_Sel_By_Structure_num</li>
</ul>
@return a Vector of HydroBase_Area_cap
@throws Exception if an error occurs.
*/
public Vector readAreaCapListForStructure_num(int structure_num)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_AREA_CAP);
	q.addWhereClause("area_cap.structure_num = " + structure_num);
	q.addOrderByClause("area_cap.volume");
	ResultSet rs = dmiSelect(q);
	Vector v = toAreaCapList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the HydroBase calls table and return a HydroBase_Calls object.<p>
This method is used by:<ul>
<li>HydroBase_GUI_CallsQuery.reactivateClicked()</li>
<li>HydroBase_GUI_CallsQuery.releaseCallClicked()</li>
</ul>
<p><b>Stored Procedures</b><p>
This uses the following view:<p><ul>
<li>vw_CDSS_Calls</li></ul>
@param where if non-null, a Vector of clauses to add to the where clauses.
@param order if non-null, a Vector of clauses to add to the order clauses.
@param distinct if true, then a distinct query will be done on calls.wdwater_num
@return a HydroBase_Calls object.
*/
public HydroBase_Calls readCallsForCall_num(int call_num) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		String[] triplet = new String[3];
		triplet[0] = "call_num";
		triplet[1] = "EQ";
		triplet[2] = "" + call_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Calls"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toCallsSPList(rs);
		closeResultSet(rs, __lastStatement);
		if (v == null || v.size() == 0) {
			return null;
		}
		else {
			return (HydroBase_Calls)v.elementAt(0);
		}
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_CALLS);
		q.addWhereClause("calls.call_num = " + call_num);
		ResultSet rs = dmiSelect(q);
		Vector v = toCallsList(rs, false);
		closeResultSet(rs);
		if (v == null || v.size() == 0) {
			return null;
		}
		else {
			return (HydroBase_Calls)v.elementAt(0);
		}
	}
}

/**
Read the HydroBase calls table and fill a Vector of HydroBase_Calls objects.<p>
This method is used by:<ul>
<li>HydroBase_GUI_CallsQuery.reactivateClicked()</li>
<li>HydroBase_GUI_CallsQuery.releaseCallClicked()</li>
</ul>
<p><b>Stored Procedures</b><p>
This uses the following view:<p><ul>
<li>vw_CDSS_Calls</li></ul>
@param divs a Vector of Strings, each of which is the number of a division.
@return a Vector of HydroBase_Calls objects.
*/
public Vector readCallsListForDiv(Vector divs, boolean distinct)
throws Exception {
	int size = divs.size();
	int size2 = -1;
	String s = null;
	Vector v = null;
	Vector results = new Vector();

	if (divs.size() == 7) {
		// all divisions are being queried
		return readCallsListForDiv(DMIUtil.MISSING_INT, distinct);
	}

	for (int i = 0; i < size; i++) {
		s = (String)divs.elementAt(i);
		v = readCallsListForDiv(StringUtil.atoi(s), distinct);
		size2 = v.size();
		for (int j = 0; j < size2; j++) {
			if (v.elementAt(j) != null) {
				results.add(v.elementAt(j));
			}
		}
	}

	return results;
}

/**
Read the HydroBase calls table and fill a Vector of HydroBase_Calls objects.<p>
This method is used by:<ul>
<li>HydroBase_GUI_CallsQuery.reactivateClicked()</li>
<li>HydroBase_GUI_CallsQuery.releaseCallClicked()</li>
</ul>
<p><b>Stored Procedures</b><p>
This uses the following view:<p><ul>
<li>vw_CDSS_Calls</li></ul>
@param div the div for which to query calls
@return a Vector of HydroBase_Calls objects.
*/
public Vector readCallsListForDiv(int div, boolean distinct)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = new String[3];
		if (!DMIUtil.isMissing(div)) {
			triplet[0] = "div";
			triplet[1] = "EQ";
			triplet[2] = "" + div;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
/*
2005-07-08
Doug said this is always included in the query
		triplet = new String[3];
		triplet[0] = "deleted";
		triplet[1] = "MA";
		triplet[2] = "N";
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
*/
		if (distinct) {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber("vw_CDSS_Calls_Distinct"), 0, 
				null);
		}
		else {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber("vw_CDSS_Calls"), 0, null);
		}
		ResultSet rs = runSPFlex(parameters);
		Vector v = null;
		if (distinct) {
			v = toCallsSPDistinctList(rs);
		}
		else {
			v = toCallsSPList(rs);
		}
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_CALLS);
		q.addWhereClause("calls.div = " + div);
		q.addWhereClause("calls.deleted LIKE 'N'");
		ResultSet rs = dmiSelect(q);
		Vector v = toCallsList(rs, false);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the HydroBase calls table and fill a Vector of HydroBase_Calls objects.<p>
This method is used by:<ul>
<li>HydroBase_GUI_CallsQuery.submitQuery()</li>
</ul>
<p><b>Stored Procedures</b><p>
This uses the following stored procedures:<p><ul>
<li>usp_CDSS_Calls_Sel_By_StartEndDate</li>
<li>usp_CDSS_Calls_Edit_Sel_By_StartEndDate</li></ul>
@param order either HydroBase_GUI_CallsQuery.CALLS or 
HydroBase_GUI_CallsQuery.EDIT_CALLS, which tells how to set up some where 
clauses.
@return a Vector of HydroBase_Calls objects.
*/
public Vector readCallsListForSetReleaseDates(DateTime startDate,
DateTime endDate, int mode) 
throws Exception {
	if (__useSP) {
		DMISelectStatement q = new DMISelectStatement(this);
		if (mode == HydroBase_GUI_CallsQuery.CALLS) {
			buildSQL(q, __S_CALLS_SP);
		}
		else if (mode == HydroBase_GUI_CallsQuery.EDIT_CALLS) {
			buildSQL(q, __S_CALLS_EDIT_SP);
		}
	        String start = DMIUtil.formatDateTime(this, startDate);
	       	String end = DMIUtil.formatDateTime(this, endDate);		

		q.addWhereClause("start_date = " + start);
		q.addWhereClause("end_date = " + end);

		ResultSet rs = dmiSelect(q);
		Vector v = toCallsSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_CALLS);			
	        String start = DMIUtil.formatDateTime(this, startDate);
	       	String end = DMIUtil.formatDateTime(this, endDate);
	
		if (mode == HydroBase_GUI_CallsQuery.CALLS) {
	 	        q.addWhereClause("((date_time_released >= " + start
	                        + " AND date_time_released <= " + end + ")" 
	                        + " OR "
	                        + "(date_time_set >= " + start
	                        + " AND date_time_set <= " + end + ")"
	                        + " OR "
	                        + "(date_time_set <= " + start
	                        + " AND date_time_released >= " + end + ")"
	                        + " OR "
	                        + "(date_time_set <= " + start 
	                        + " AND date_time_released is null))");
	        	q.addWhereClause("calls.deleted Like 'N'"); 
			q.addOrderByClause("date_time_set");
			q.addOrderByClause("date_time_released");
		}
		else if (mode == HydroBase_GUI_CallsQuery.EDIT_CALLS) {
			q.addWhereClause("((date_time_released >= " + start
	                        + " AND date_time_released <= " + end + ")" 
	                        + " OR "
	                        + "(date_time_set >= " + start
	                        + " AND date_time_set <= " + end + ")"
	                        + " OR "
	                        + "(date_time_set <= " + start
	                        + " AND date_time_released >= " + end + ")"
	                        + " OR "
	                        + " date_time_released is null)");
	        	q.addWhereClause("calls.deleted Like 'N'"); 
			q.addOrderByClause("date_time_released");
			q.addOrderByClause("date_time_set");
		}
	
		ResultSet rs = dmiSelect(q);
		Vector v = toCallsList(rs, false);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the HydroBase calls table and fill a Vector of HydroBase_Calls objects.<p>
This method is used by:<ul>
<li>HydroBase_Device_WISDiagram</li>
</ul>
<p><b>Stored Procedures</b><p>
@return a Vector of HydroBase_Calls objects.
*/
public Vector readCallsListForWISDiagram(int wd, int id, DateTime datetime)
throws Exception {
	DateTime dt = new DateTime(datetime);
	dt.setPrecision(DateTime.FORMAT_YYYY_MM_DD);
	if (__useSP) {
		String date = DMIUtil.formatDateTime(this, dt, false);
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_CALLS);
		q.addWhereClause("call_date = " + date + "");
		q.addWhereClause("wd = " + wd);
		q.addWhereClause("id = " + id);
		ResultSet rs = dmiSelect(q);
		Vector v = toCallsSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DateTime late = new DateTime(dt);
		late.setPrecision(DateTime.FORMAT_YYYY_MM_DD_HH_mm_SS);
		late.setHour(23);
		late.setMinute(59);
		late.setSecond(59);
		DateTime early = new DateTime(dt);
		early.setPrecision(DateTime.FORMAT_YYYY_MM_DD_HH_mm_SS);
		late.setHour(0);
		late.setMinute(0);
		late.setSecond(0);
		
		String lateS = DMIUtil.formatDateTime(this, late, true);
		String earlyS = DMIUtil.formatDateTime(this, early, true);
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_CALLS);
		q.addWhereClause("(date_time_set IS NOT NULL AND "
			+ "date_time_set < " + lateS + ")");
		q.addWhereClause("(date_time_released IS NULL OR "
			+ "date_time_released > " + earlyS + ")");
		q.addWhereClause("(deleted = 'N')");
		q.addWhereClause("wd = " + wd);
		q.addWhereClause("id = " + id);
		ResultSet rs = dmiSelect(q);
		Vector v = toCallsList(rs, false);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the HydroBase contact and rolodex tables and fill a Vector of 
HydroBase_Contact objects, and use person_details, for all contact records
that match the specified rolodex_num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_OwnerContact.submitAndDisplayContactQuery()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_Contact_Sel_By_Rolodex_num</li>
</ul>
@return a Vector of HydroBase_Contact objects.
@throws Exception if an error occurs.
*/
public Vector readContactListForRolodex_num(int rolodex_num)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_CONTACT);
	q.addWhereClause("contact.rolodex_num = " + rolodex_num);
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toContactSPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toContactList(rs);
		closeResultSet(rs);
	}
	return v;
}

/**
Read the HydroBase ref_county for all data.  Sort by the county name.<p>
This method is used by:<ul>
<li>HydroBaseDMI.readGlobalData()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_refCounty_Sel</li>
@return a Vector of HydroBase_CountyRef.
@throws Exception if an error occurs.
*/
public Vector readCountyRefList()
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_REF_COUNTY);
	String table = "ref_county";
	if (getDatabaseVersion() <= VERSION_20040701) {
		table = "county_ref";
	}	
	q.addOrderByClause(table + ".county");
	ResultSet rs = dmiSelect(q);
	Vector v = toCountyRefList (rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the HydroBase courtcase table for all data with the matching structure_num.
<p>
This method is used by:<ul>
<li>HydroBase_GUI_StructureMoreInfo.submitCourtCaseQuery()</li>
</ul>
<p><b>Stored Procedures</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_CourtCase_Sel_By_Structure_num</li>
</ul>
@return a Vector of HydroBase_CourtCase objects.
@throws Exception if an error occurs.
*/
public Vector readCourtCaseListForStructure_num(int structure_num)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_COURTCASE_FOR_STRUCTURE_NUM);
	q.addWhereClause("courtcase.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	// checked stored procedure
	Vector v = toCourtCaseList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the HydroBase cropchar table for the selected CU method (method_desc).
Sort by the crop name.<p>
This method is used by:<ul>
<li>HydroBaseDMI.readGlobalData()</li>
</ul>
<p><b>Stored Procedures</b><p>
The stored procedures that corresponds to this query is:<ul>
<li>usp_CDSS_Cropchar_Sel_Distinct</li>
</ul>
<b>NOTE:</b> This stored procedure is <i>only</i> used if distinct is true.  
If distinct is false, then the following view will be used:<p><ul>
<li>vw_CDSS_Cropchar</li></ul>
@param method_desc Cropchar.method_desc to query for, or null to query all
records.
@param distinct If specified as true, it is expected that "method_desc" is
null and the Vector that is returned will have the method_desc set to distinct
values.  if specified as false, perform a full query.
@return a Vector of HydroBase_CUCropchar.
@throws Exception if an error occurs.
*/
public Vector readCropcharListForMethodDesc(String method_desc,
boolean distinct)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	if (distinct) {
		buildSQL(q, __S_CROPCHAR_DISTINCT);
		q.selectDistinct(true);
		// Sort the methods...
		q.addOrderByClause("cropchar.method_desc");
		if (__useSP) {
			ResultSet rs = dmiSelect(q);
			Vector v = toCropcharDistinctSPList(rs);
			closeResultSet(rs, q);
			return v;	
		}
		else {
			ResultSet rs = dmiSelect(q);
			Vector v = toCropcharList(rs, distinct);
			closeResultSet(rs);
			return v;
		}
	}
	else {
		if (__useSP) {
			String[] parameters 
				= HydroBase_GUI_Util.getSPFlexParameters(
				null, null);
	
			String[] triplet = null;
	
			if (method_desc != null) {
				triplet = new String[3];
				triplet[0] = "method_desc";
				triplet[1] = "MA";
				triplet[2] = method_desc;
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);
			}

			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber("vw_CDSS_Cropchar"), 
				8, null);
			ResultSet rs = runSPFlex(parameters);
			Vector v = toCropcharSPList(rs);
			closeResultSet(rs, __lastStatement);
			return v;
		}
		else {
			if (method_desc != null) {
				buildSQL(q, __S_CROPCHAR_FOR_METHOD_DESC);
				q.addWhereClause("cropchar.method_desc='" 	
					+ method_desc + "'");
			}
			else {
				buildSQL(q, __S_CROPCHAR);
			}
			q.addOrderByClause("cropchar.cropname");
			ResultSet rs = dmiSelect(q);
			Vector v = toCropcharList(rs, distinct);
			closeResultSet(rs);
			return v;		
		}
	}
}

/**
Read the HydroBase cropchar table for all data where the length of season is 
greater than 0.  Sort by the crop name. <p>
This method is used by:<ul>
<li>HydroBase_GUI_OtherQuery.submitQuery()</li>
</ul>
<p><b>Stored Procedure</b><p>
This uses the following view:<p><ul>
<li>vw_CDSS_Cropchar</li></ul>
@return a Vector of HydroBase_CUCropchar.
@throws Exception if an error occurs.
*/
public Vector readCropcharList()
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		String[] triplet = new String[3];
		triplet[0] = "lengthofseason";
		triplet[1] = "GT";
		triplet[2] = "0";
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Cropchar"), 8, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toCropcharList(rs, false);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_CROPCHAR_FOR_LENGTHOFSEASON_GT_0);
		q.addWhereClause("cropchar.lengthofseason > 0");	
		q.addOrderByClause("cropchar.cropname");
		ResultSet rs = dmiSelect(q);
		Vector v = toCropcharList (rs, false);
		closeResultSet(rs);
		return v;
	}
}

/**
Reads crop growth information for the information in the InputFilter_JPanel.<p>
This method is called by:<ul>
<li>HydroBase_GUI_OtherQuery.submitQuery()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_CUBlaneyCriddle</li>
<li>vw_CDSS_CUModHargreaves</li>
<li>vw_CDSS_CUPenmanMonteith</li>
</ul>
@param method the method for which to read the crop growth list.  If '*', all
three queries are executed
@return an array of Vectors, one element for each query performed.
@throws Exception if there is an error reading the database.
*/
public Vector[] readCropGrowthList(InputFilter_JPanel panel, String method)
throws Exception {
	if (!__useSP) {
		return readCropGrowthList(method);
	}
	else {
		ResultSet rs = null;
		Vector[] varray = new Vector[3];

		boolean doAll = false;
		if (method.equals("*")) {
			doAll = true;
		}
		
		if (doAll || method.startsWith("BLANEY-CRIDDLE")) {
			String[] parameters 
				= HydroBase_GUI_Util.getSPFlexParameters(
				panel, null);
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber("vw_CDSS_CUBlaneyCriddle"), 
				44, null);
			rs = runSPFlex(parameters);
			varray[0] = toCUBlaneyCriddleSPList(rs);
		}
		if (doAll || method.startsWith("MODIFIED-HARGREAVES")) {
			String[] parameters 
				= HydroBase_GUI_Util.getSPFlexParameters(
				null, null);
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber("vw_CDSS_CUModHargreaves"), 
				45, null);
			rs = runSPFlex(parameters);
			varray[1] = toCUModHargreavesSPList(rs);
		}		
		if (doAll || method.startsWith("PENMAN-MONTEITH")) {
			String[] parameters 
				= HydroBase_GUI_Util.getSPFlexParameters(
				null, null);
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber("vw_CDSS_CUPenmanMonteith"), 
				46, null);
			rs = runSPFlex(parameters);
			varray[2] = toCUPenmanMonteithSPList(rs);
		}
		closeResultSet(rs, __lastStatement);
		return varray;
	}
}

/**
Reads crop growth information for the specified method.<p>
This method is called by:<ul>
<li>HydroBase_GUI_OtherQuery.submitQuery()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method will never be used with stored procedures --
See the InputFilter_JPanel method.<p>
The stored procedures that correspond to the queries are:<ul>
<li>usp_CDSS_CropGrowth_Sel_By_BlaneyCriddle_Method_desc</li>
<li>usp_CDSS_CropGrowth_Sel_By_BlaneyCriddle</li>
<li>usp_CDSS_CropGrowth_Sel_By_ModifiedHargreaves_Method_desc</li>
<li>usp_CDSS_CropGrowth_Sel_By_ModifiedHargreaves</li>
<li>usp_CDSS_CropGrowth_Sel_By_PenmanMonteith_Method_desc</li>
<li>usp_CDSS_CropGrowth_Sel_By_PenmanMonteith</li>
</ul>
<b>This method is only to be used with SQL connections.  No support for 
stored procedures or views, nor will there be in the near future.</b>
@param method the method for which to read the crop growth list.  If '*', all
three queries are executed
@return an array of Vectors, one element for each query performed.
@throws Exception if there is an error reading the database.
*/
public Vector[] readCropGrowthList(String method)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);

	long version = getDatabaseVersion();
	if (version < VERSION_20010326) {
		return null;
	}
	else {
		Vector[] vectors = new Vector[3];
		vectors[0] = vectors[1] = vectors[2] = null;
		ResultSet rs = null;
		boolean doAll = false;
		if (method.equals("*")) {
			doAll = true;
		}
		if (doAll || method.startsWith("BLANEY-CRIDDLE")) {
			if (!doAll) {
				q.addWhereClause("cu_method.method_desc = '" 
					+ method + "'");
				buildSQL(q, 
				      __S_CG_CU_BLANEY_CRIDDLE_FOR_METHOD_DESC);
			}
			else {
				buildSQL(q, __S_CG_CU_BLANEY_CRIDDLE);
			}
			q.addOrderByClause("cu_method.method_desc");
			q.addOrderByClause("crop.cropname");
			q.addOrderByClause("cu_blaney_criddle.curve_type");
			q.addOrderByClause("cu_blaney_criddle.curve_value");
			rs = dmiSelect(q);
			Vector v = toCUBlaneyCriddleList(rs, false);
			vectors[0] = v;
		}

		q = new DMISelectStatement(this);
		if (doAll || method.startsWith("MODIFIED-HARGREAVES")) {
			if (!doAll) {
				q.addWhereClause("cu_method.method_desc = '" 
					+ method + "'");
				buildSQL(q, 
				      __S_CG_CU_MOD_HARGREAVES_FOR_METHOD_DESC);
			}
			else {
				buildSQL(q, __S_CG_CU_MOD_HARGREAVES);
			}
			q.addOrderByClause("cu_method.method_desc");
			q.addOrderByClause("crop.cropname");
			rs = dmiSelect(q);
			Vector v = toCUModHargreavesList(rs);
			vectors[1] = v;
		}		

		q = new DMISelectStatement(this);
		if (doAll || method.startsWith("PENMAN-MONTEITH")) {
			if (!doAll) {
				q.addWhereClause("cu_method.method_desc = '" 
					+ method + "'");
				buildSQL(q, 
	    			     __S_CG_CU_PENMAN_MONTEITH_FOR_METHOD_DESC);
			}
			else {
				buildSQL(q, __S_CG_CU_PENMAN_MONTEITH);
			}
			q.addOrderByClause("cu_method.method_desc");
			q.addOrderByClause("crop.cropname");
			q.addOrderByClause("cu_penman_monteith.growthstage_no");
			q.addOrderByClause("cu_penman_monteith.curve_value");
			rs = dmiSelect(q);
			Vector v = toCUPenmanMonteithList(rs);
			vectors[2] = v;
		}
		return vectors;
	}
}

/**
Read the CropRef table for all data.<p>
This method is used by:<ul>
<li>HydroBaseDMI.readGlobalData()</li>
</ul>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_refCrop_Sel</li>
</ul>
@return a Vector of HydroBase_CropRef objects.
@throws Exception if an error occurs.
*/
public Vector readCropRefList() 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_CROP_REF);
	q.addOrderByClause("crop_ref.crop_desc");
	ResultSet rs = dmiSelect(q);
	Vector v = toCropRefList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read HydroBase crop and HydroBase cu_blaney_criddle for all data and use 
cu_method.<p>
This method is used by:<ul>
<li>HydroBaseDMI.readGlobalData()</li>
</ul>
<p><b>Stored Procedures</b><p>
The stored procedures that corresponds to this query is:<ul>
<li>usp_CDSS_CUBlaneyCriddle_Sel_Distinct</li>
</ul>
<b>NOTE:</b> This stored procedure is <i>only</i> used if distinct is true.  
If distinct is fale, then the following view will be used:<p><ul>
<li>vw_CDSS_CUBlaneyCriddle</li></ul>
@param method_desc CUMethod description from cu_method.method_desc.
@param distinct If specified as true, it is expected that "method_desc" is
null and the Vector that is returned will have the method_desc set to distinct
values.  if specified as false, perform a full query.
@return a Vector of HydroBase_CUPenmanMonteith.
@throws Exception if an error occurs.
*/
public Vector readCUBlaneyCriddleListForMethodDesc (	String method_desc,
							boolean distinct ) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	if (distinct) {
		buildSQL ( q, __S_CU_BLANEY_CRIDDLE_DISTINCT);
		q.selectDistinct ( true);
		q.addOrderByClause("cu_method.method_desc");
		if (__useSP) {
			ResultSet rs = dmiSelect(q);
			Vector v = toCUBlaneyCriddleDistinctSPList(rs);
			closeResultSet(rs, q);
			return v;
		}
		else {
			ResultSet rs = dmiSelect(q);
			Vector v = toCUBlaneyCriddleList(rs, distinct);
			closeResultSet(rs);
			return v;
		}
	}
	else {
		if (__useSP) {
			String[] parameters 
				= HydroBase_GUI_Util.getSPFlexParameters(
				null, null);
	
			String[] triplet = null;
	
			if (method_desc != null) {
				triplet = new String[3];
				triplet[0] = "method_desc";
				triplet[1] = "MA";
				triplet[2] = method_desc;
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);
			}

			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber("vw_CDSS_CUBlaneyCriddle"), 
				9, null);
			ResultSet rs = runSPFlex(parameters);
			Vector v = toCUBlaneyCriddleSPList(rs);
			closeResultSet(rs, __lastStatement);
			return v;
		}
		else {
			if (method_desc != null) {
				buildSQL(q, 
					__S_CU_BLANEY_CRIDDLE_FOR_METHOD_DESC);
				q.addWhereClause("cu_method.method_desc='" 
					+ method_desc + "'");
			}
			else {
				buildSQL(q, __S_CU_BLANEY_CRIDDLE);
			}
			q.addOrderByClause("crop.cropname");
			q.addOrderByClause("cu_blaney_criddle.curve_value");
			q.addOrderByClause("cu_method.method_desc");
			ResultSet rs = dmiSelect(q);
			Vector v = toCUBlaneyCriddleList(rs, distinct);
			closeResultSet(rs);
			return v;	
		}
	}
} 

/**
Read the HydroBase cu_coeff for all data.<p>
This method is used by:<ul>
<li>HydroBase_GUI_OtherQuery.submitQuery()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_CUCoeff_Sel</li>
</ul>
@return a Vector of HydroBase_CUCoeff
@throws Exception if an error occurs.
*/
public Vector readCUCoeffList() 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_CU_COEFF);
	q.addOrderByClause("cu_coeff.consuse");
	ResultSet rs = dmiSelect(q);
	Vector v = toCUCoeffList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the HydroBase cu_method for all data.  <p>
This method is used by:<ul>
<li>HydroBase_GUI_OtherQuery.dataTypeJComboBoxClicked()</li>
</ul>
<p><b>Stored Procedures</b><p>
The stored procedures that correspond to these queries are:<ul>
<li>usp_CDSS_CUMethod_Sel</li>
<li>usp_CDSS_CUMethod_Sel_Distinct</li>
</ul>
@param distinct if true a distinct list of the method_desc will be queried.
@return a Vector of HydroBase_CUMethod.
@throws Exception if an error occurs.
*/
public Vector readCUMethodList(boolean distinct)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	q.addOrderByClause("cu_method.method_desc");
	if (distinct) {
		buildSQL(q, __S_CU_METHOD_DISTINCT);
	}
	else {
		buildSQL(q, __S_CU_METHOD);
		q.addOrderByClause("cu_method.method_num");
	}
	ResultSet rs = dmiSelect(q);
	Vector v = toCUMethodList(rs, distinct);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the HydroBase CUPopulation table/view.<p>
This method is used by:<ul>
<li>readTimeSeries()</li>
</ul>
<b>Stored Procedures</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_CUPopulation_Distinct</li>
<li>vw_CDSS_CUPopulation</li></ul><p>
@param panel the panel with the query constraints.  If null, it will not be 
used.
@param area_type The area type for the query - specify null or blank to ignore.
@param area_name The area name for the query - specify null or blank to ignore.
@param pop_type The population type for the query - specify null or blank to
ignore.
@param req_date1 If not null, specify the start date for the query.  Will be
ignored for distinct queries.
@param req_date2 If not null, specify the end date for the query.  Will be
ignored for distinct queries.
@param distinct if set to true, then only data for distinct
area_type/area_name/pop_type records will be returned.
@return a Vector of HydroBase_CUPopulation.
@throws Exception if an error occurs.
*/
public Vector readCUPopulationList(InputFilter_JPanel panel,
String area_type, String area_name, String pop_type, DateTime req_date1, 
DateTime req_date2, boolean distinct) 
throws Exception {
	if ( !__useSP) {
		String routine = "HydroBaseDMI.readCUPopulationList";
		Message.printWarning ( 2, routine,
		"Only stored procedures are supported for CUPopulation." );
		throw new Exception (
		"Stored procedures must be used for CUPopulation" );
	}
	String[] parameters =HydroBase_GUI_Util.getSPFlexParameters(panel,null);

	String[] triplet = null;
	if ( area_type != null && area_type.length() > 0) {
		triplet = new String[3];
		triplet[0] = "area_type";
		triplet[1] = "MA";
		triplet[2] = area_type;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
	}
	if ( area_name != null && area_name.length() > 0) {
		triplet = new String[3];
		triplet[0] = "area_name";
		triplet[1] = "MA";
		triplet[2] = area_name;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
	}
	if ( pop_type != null && pop_type.length() > 0) {
		triplet = new String[3];
		triplet[0] = "pop_type";
		triplet[1] = "MA";
		triplet[2] = pop_type;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
	}
	if (!distinct && req_date1 != null) {
		triplet = new String[3];
		triplet[0] = "cal_year";
		triplet[1] = "GE";
		triplet[2] = "" + req_date1.getYear();
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
	}
	if (!distinct && req_date2 != null) {
		triplet = new String[3];
		triplet[0] = "cal_year";
		triplet[1] = "LE";
		triplet[2] = "" + req_date2.getYear();
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
	}

	// REVISIT SAM 2006-11-01
	// Replace the order by (0) with a value appropriate for the
	// CU Population data.
	if (distinct) {
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber(
			"vw_CDSS_CUPopulation_Distinct"), 112, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toCUPopulationList(rs, true);
		closeResultSet(rs, __lastStatement);
		return v;					
	}
	else {	// Order by everything, including cal_year (default in view on
		// database side)...
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber( "vw_CDSS_CUPopulation"), -999, null );
		ResultSet rs = runSPFlex(parameters);
		Vector v = toCUPopulationList(rs, false);
		closeResultSet(rs, __lastStatement);
		return v;					
	}		
}

/**
Read the daily_amt table for all data and use the struct_meas_type table in the
where clause.  Order results first by daily_amt.cal_year, cal_mon</P>.
This method is used by readTimeSeries().
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_DailyAmt</li></ul>
@param meas_num the struct_meas_type.meas_num key for this time series.
@param req_date1 If not null, specify the start date for the query.
@param req_date2 If not null, specify the end date for the query.
@return a Vector of HydroBase_DailyAmt objects.
@throws Exception if an error occurs.
*/
public Vector readDailyAmtList(int meas_num, DateTime req_date1,
DateTime req_date2) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		String[] triplet = new String[3];
		triplet[0] = "meas_num";
		triplet[1] = "EQ";
		triplet[2] = "" + meas_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		if (req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "LE";
			triplet[2] = "" + req_date2.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_DailyAmt"), 10, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toDailyAmtList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_DAILY_AMT);
		q.addWhereClause("daily_amt.meas_num=" + meas_num);
		if (req_date1 != null) {
			q.addWhereClause(
				"daily_amt.cal_year >=" + req_date1.getYear());
		}
		if (req_date2 != null) {
			q.addWhereClause(
				"daily_amt.cal_year <=" + req_date2.getYear());
		}
		q.addOrderByClause("daily_amt.cal_year");
		q.addOrderByClause("daily_amt.cal_mon");
		ResultSet rs = dmiSelect(q);
		Vector v = toDailyAmtList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
General function to read daily station time series tables.
Since all these queries share a lot of common aspects, they can all basically
be handled by one main read and one main to*() method.  Order results according
to cal_year and cal_mon_num.
@param sqlNumber the SQL select statement to execute, as follows:
<pre>
SQLNumber                  Description            Table             Field
__S_DAILY_MAX_T             Daily max temp.        daily_max_t       day*
__S_DAILY_MIN_T             Daily min temp.        daily_min_t       day*
__S_DAILY_FLOW              Daily avg flow         daily_flow        day*
__S_DAILY_EVAP              Daily evap.            daily_evap        day*
__S_DAILY_PCPN              Daily precip.          daily_pcpn        day*, flag*
__S_DAILY_SOLAR             Daily solar            daily_solar       day*
__S_DAILY_SNOW              Daily snow             daily_snow        day*
__S_DAILY_VP                Daily vapor pressure.  daily_vp          day*
__S_DAILY_WIND              Daily wind travel.     daily_wind        day*
</pre>
<b>Stored Procedures</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_DailyEVAP</li>
<li>vw_CDSS_DailyFlow</li>
<li>vw_CDSS_DailyMAXT</li>
<li>vw_CDSS_DailyMINT</li>
<li>vw_CDSS_DailyPcpn</li>
<li>vw_CDSS_DailySnow</li>
<li>vw_CDSS_DailySolar</li>
<li>vw_CDSS_DailyVP</li>
<li>vw_CDSS_DailyWind</li>
</ul>
@param meas_num the meas_type.meas_num key for this time series.
@param req_date1 If not null, specify the start date for the query.
@param req_date2 If not null, specify the end date for the query.
@return a Vector of HydroBase_X objects.
@throws Exception if an error occurs.
*/
protected Vector readDailyStationData(int sqlNumber, int meas_num,
DateTime req_date1, DateTime req_date2) 
throws Exception {
	if (__useSP) {
		String viewName = null;
		int orderNumber = -1;
		switch (sqlNumber) {
			case __S_DAILY_ADMIN_FLOW:
				viewName = "vw_CDSS_DailyAdminFlow";
				orderNumber = 113;
				break;
			case __S_DAILY_EVAP:
				viewName = "vw_CDSS_DailyEVAP";
				orderNumber = 64;
				break;
			case __S_DAILY_FLOW:
				viewName = "vw_CDSS_DailyFlow";
				orderNumber = 67;
				break;
			case __S_DAILY_MAX_T:
				viewName = "vw_CDSS_DailyMAXT";
				orderNumber = 62;
				break;
			case __S_DAILY_MIN_T:
				viewName = "vw_CDSS_DailyMINT";
				orderNumber = 61;
				break;
			case __S_DAILY_PCPN:
				viewName = "vw_CDSS_DailyPcpn";
				orderNumber = 60;
				break;				
			case __S_DAILY_SNOW:
				viewName = "vw_CDSS_DailySnow";
				orderNumber = 66;
				break;
			case __S_DAILY_SOLAR:
				viewName = "vw_CDSS_DailySolar";
				orderNumber = 65;
				break;
			case __S_DAILY_VP:
				viewName = "vw_CDSS_DailyVP";
				orderNumber = 63;
				break;
			case __S_DAILY_WIND:
				viewName = "vw_CDSS_DailyWind";
				orderNumber = 68;
				break;
			default:
				return null;
		}
		
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		String[] triplet = new String[3];
		triplet[0] = "meas_num";
		triplet[1] = "EQ";
		triplet[2] = "" + meas_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		if (req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "LE";
			triplet[2] = "" + req_date2.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber(viewName), orderNumber, null);
		ResultSet rs = runSPFlex(parameters);

		Vector v = null;
		if (sqlNumber == __S_DAILY_PCPN) {
			v = toDailyPcpnSPList(rs);
		}
		else {
			v = toDailyTSSPList(rs);
		}

		closeResultSet(rs, __lastStatement);
		return v;
		
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, sqlNumber);
		q.addWhereClause("meas_num=" + meas_num);
		if (req_date1 != null) {
			q.addWhereClause("cal_year >=" + req_date1.getYear());
		}
		if (req_date2 != null) {
			q.addWhereClause("cal_year <=" + req_date2.getYear());
		}
		q.addOrderByClause("cal_year");
		q.addOrderByClause("cal_mon_num");
		ResultSet rs = dmiSelect(q);
		Vector v = null;
		if (sqlNumber == __S_DAILY_PCPN) {
			v = toDailyPcpnList(rs);
		}
		else {
			v = toDailyTSList(rs, sqlNumber);
		}		
		closeResultSet(rs);
		return v;
	}
}

/**
Read the daily_wc table for all data and use struct_meas_type.
This method is used by readTimeSeries().
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_DailyWC</li></ul>
@param meas_num struct_meas_type.meas_num for query.
@param req_date1 If not null, specify the start date for the query.
@param req_date2 If not null, specify the end date for the query.
@return a Vector of HydroBase_DailyWC objects.
@throws Exception if an error occurs.
*/
public Vector readDailyWCList(	int meas_num, DateTime req_date1,
				DateTime req_date2 ) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		String[] triplet = new String[3];
		triplet[0] = "meas_num";
		triplet[1] = "EQ";
		triplet[2] = "" + meas_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		if (req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "LE";
			triplet[2] = "" + req_date2.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_DailyWC"), 11, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toDailyWCSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_DAILY_WC);
		q.addWhereClause("daily_wc.meas_num = " + meas_num);
		if (req_date1 != null) {
			q.addWhereClause("cal_year >=" + req_date1.getYear());
		}
		if (req_date2 != null) {
			q.addWhereClause("cal_year <=" + req_date2.getYear());
		}
		q.addOrderByClause("daily_wc.meas_num");
		q.addOrderByClause("daily_wc.structure_num");
		q.addOrderByClause("daily_wc.cal_year");
		q.addOrderByClause("daily_wc.cal_mon");	
		q.addOrderByClause("daily_wc.s");
		ResultSet rs = dmiSelect(q);	
		Vector v = toDailyWCList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the daily_wc table for all data and use struct_meas_type.<p>
This method is used by:<ul>
<li>HydroBase_GUI_DailyWC</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_WISDailyWC_Diversion</li>
<li>vw_CDSS_WISDailyWC_Release</li></ul>
@param structure_num the structure num to match
@param recordType the record type to match.  if "H", Diversions will be 
returned.  Otherwise, releases will be returned.
@return a Vector of HydroBase_DailyWC objects, or HydroBase_WISDailyWC objects
if a stored procedure is executed.
@throws Exception if an error occurs.
*/
public Vector readDailyWCListForStructure_numRecordType(int structure_num,
String recordType)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		String[] triplet = new String[3];
		triplet[0] = "structure_num";
		triplet[1] = "EQ";
		triplet[2] = "" + structure_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
	
		if (recordType.equals("H")) {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber("vw_CDSS_WISDailyWC_Diversion"), 
				12, null);
		}
		else {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber("vw_CDSS_WISDailyWC_Release"), 
				13, null);
		}
	
		ResultSet rs = runSPFlex(parameters);
		Vector v = toDailyWCSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_DAILY_WC);
		q.addWhereClause("daily_wc.structure_num = " + structure_num);
	
	        // construct where clause and submit query
	        if (recordType.equals("H")) {
	                q.addWhereClause("(T<>'6' and T<>'7' and T<>'8') "
				+ "OR T IS NULL");
	        }
	        else {
			// Reservoir
	                q.addWhereClause("T='6' OR T='7' OR T='8'");
	        }
		
		q.addOrderByClause("daily_wc.meas_num");
		q.addOrderByClause("daily_wc.structure_num");
		q.addOrderByClause("daily_wc.cal_year");
		q.addOrderByClause("daily_wc.cal_mon");	
		q.addOrderByClause("daily_wc.s");

		ResultSet rs = dmiSelect(q);	
		Vector v = toDailyWCList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the dam and structure tables for the record that matches the specified
structure_num.<p>
This method is used by:<ul>
<li>HydroBaseDMI.readGlobalData()</li>
<li>HydroBase_GUI_Dam.submitAndDisplayDamQuery()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_Dam_Sel_By_Structure_num</li>
</ul>
@return a HydroBase_StructureDam object
@throws Exception if an error occurs.
*/
public HydroBase_StructureDam readDamForStructure_num(int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_DAM);
	q.addWhereClause("structure.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toDamSPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toDamList(rs);
		closeResultSet(rs);
	}
	if (v == null || v.size() == 0) {
		return null;
	}
	return (HydroBase_StructureDam)(v.elementAt(0));
}

/**
Read the dam_inspection table for all data matching the specified 
structure num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_Dam.submitAndDisplayInspectionQuery()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_DamInspection_Sel_By_Structure_num</li>
</ul>
@return a Vector of HydroBase_DamInspection objects
@throws Exception if an error occurs.
*/
public Vector readDamInspectionListForStructure_num(int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_DAM_INSPECTION);
	q.addWhereClause("dam_inspection.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toDamInspectionSPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toDamInspectionList(rs);
		closeResultSet(rs);
	}
	return v;
}

/**
Read the dam_outlet table for all data matching the specified structure num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_Dam.submitAndDisplayOutletQuery()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_DamOutlet_Sel_By_Structure_num</li>
</ul>
@return a Vector of HydroBase_DamOutlet objects.
@throws Exception if an error occurs.
*/
public Vector readDamOutletListForStructure_num(int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_DAM_OUTLET);
	q.addWhereClause("dam_outlet.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = toDamOutletList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the dam_spillway table for all data matching the specified structure 
num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_Dam.submitAndDisplaySpillwayQuery()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_DamSpillway_Sel_By_Structure_num</li>
</ul>
@return a Vector of HydroBase_DamSpillway objects.
@throws Exception if an error occurs.
*/
public Vector readDamSpillwayListForStructure_num(int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_DAM_SPILLWAY);
	q.addWhereClause("dam_spillway.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = toDamSpillwayList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the HydroBase db_version for the version type.  Currently the version type
is not used to limit the query.  <p>
<p>
This method is used by:<ul>
<li>HydroBaseDMI.getDatabaseProperties()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_DBVersion_Sel</li>
</ul>
@param version_type Database version type (db_version.version_type).
@return a Vector of objects of type HydroBase_DBVersion.
@throws Exception if an error occurs.
*/
public Vector readDBVersionListForVersionType ( String version_type )
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	if (version_type != null) {
		buildSQL ( q, __S_DBVERSION_FOR_VERSION_TYPE);
		q.addWhereClause("db_version.version_type = '" 
			+ version_type + "'");
	}
	else {
		buildSQL(q, __S_DBVERSION);
	}
	q.addOrderByClause("db_version.version_date DESC");
	ResultSet rs = dmiSelect(q);
	Vector v = toDBVersionList (rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the diversion_comment table for all data and join with data in 
the structure table.<p>
This method is used by:<ul>
<li>readTimeSeries()</li>
<li>HydroBase_Report_StructureSummary.formatMonthlyDiversionForQINFO()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_DiversionComment_Sel_By_Meas_num</li>
</ul>
@param meas_num struct_meas_type.meas_num for query.
@param req_date1 If not null, specify the start date for the query.
@param req_date2 If not null, specify the end date for the query.
@return a Vector of HydroBase_DiversionComment objects.
@throws Exception if an error occurs.
*/
public Vector readDiversionCommentList(	int meas_num, DateTime req_date1,
					DateTime req_date2 ) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_DIVERSION_COMMENT);
	q.addWhereClause("diversion_comment.meas_num = " + meas_num);
	// Appliation requests are in calendar year and the comm_date is also
	// apparently in calendar year but all dates are typically Oct 31 so
	// only the year is important...
	// REVISIT (SAM 2003-12-09) - need to do some work to decide how best to
	// handle this since DB has YYYY-MM-DD but in memory we are carrying the
	// data with YYYY for time series.
	//
	//if (req_date1 != null) {
	//	q.addWhereClause("diversion_comment.comm_date >=" +
	//		req_date1.getYear());
	//}
	//if (req_date2 != null) {
	//	q.addWhereClause("diversion_comment.comm_date <=" +
	//		(req_date2.getYear() + 1));
	//}
	q.addOrderByClause("diversion_comment.comm_date");
	ResultSet rs = dmiSelect(q);
	Vector v = toDiversionCommentList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the diversion_comment table for all data and join with data in 
the structure table.<p>
This is called by:<ul>
<li>HydroBase_Report_StructureSummary.formatMonthlyDiversionForQINFO()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_DiversionComment_Sel_By_Structure_num</li>
</ul>
@return a Vector of HydroBase_DiversionComment objects.
@throws Exception if an error occurs.
*/
public Vector readDiversionCommentListForStructure_num(int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_DIVERSION_COMMENT_FOR_STRUCTURE_NUM);
	q.addWhereClause("diversion_comment.structure_num = " + structure_num);
	q.addOrderByClause("diversion_comment.comm_date");
	ResultSet rs = dmiSelect(q);
	Vector v = toDiversionCommentList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the emergency_plan table for all data matching the specified structure
num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_Dam.submitAndDisplayEmergencyPlanQuery()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_EmergencyPlan_Sel_By_Structure_num</li>
</ul>
@return a Vector of HydroBase_EmergencyPlan objects.
@throws Exception if an error occurs.
*/
public Vector readEmergencyPlanListForStructure_num(int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_EMERGENCY_PLAN);
	q.addWhereClause("emergency_plan.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = toEmergencyPlanList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the equipment table for all data and join with data in the structure table.
This method only returns the first record of the returned data.<p>
This method is used by:<ul>
<li>HydroBase_Report_StructureSummary.submitEquipmentQuery</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_Equipment_Sel_By_Structure_num</li>
</ul>
@return a HydroBase_Equipment object.
@throws Exception if an error occurs.
*/
public HydroBase_Equipment readEquipmentForStructure_num(int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_EQUIPMENT);
	q.addWhereClause("equipment.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toEquipmentSPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toEquipmentList(rs);
		closeResultSet(rs);
	}
	if (v.size() > 0) {
		return (HydroBase_Equipment)v.elementAt(0);
	}
	else {
		return null;
	}
}

/**
Read the frost_dates table for all data.  Order results by frost_dates.cal_year.
<p>
This is used by:<ul>
<li>readTimeSeries()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_Frost_Dates</li></ul>
@param meas_num the meas_type.meas_num key for this time series.
@param req_date1 If not null, specify the start date for the query.
@param req_date2 If not null, specify the end date for the query.
@return a Vector of HydroBase_FrostDates objects.
@throws Exception if an error occurs.
*/
public Vector readFrostDatesList(int meas_num, DateTime req_date1,
DateTime req_date2) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		String[] triplet = new String[3];
		triplet[0] = "meas_num";
		triplet[1] = "EQ";
		triplet[2] = "" + meas_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		if (req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "LE";
			triplet[2] = "" + req_date2.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Frost_Dates"), 14, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toFrostDatesSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_FROST_DATES);
		q.addWhereClause("frost_dates.meas_num = " + meas_num);
		if (req_date1 != null) {
			q.addWhereClause("frost_dates.cal_year >="
				+ req_date1.getYear());
		}
		if (req_date2 != null) {
			q.addWhereClause("frost_dates.cal_year <="
				+ req_date2.getYear());
		}
		q.addOrderByClause("frost_dates.cal_year");
		ResultSet rs = dmiSelect(q);
		Vector v = toFrostDatesList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the general_comment table for all data with the same structure_num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_StructureMoreInfo.submitAndDisplayGeneralCommentQuery</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_GeneralComment_Sel_By_Structure_num</li>
</ul>
@return a Vector of HydroBase_GeneralComment objects.
@throws Exception if an error occurs.
*/
public Vector readGeneralCommentListForStructure_num(int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_GENERAL_COMMENT);
	q.addWhereClause("general_comment.structure_num = " + structure_num);
	if (isDatabaseVersionAtLeast(VERSION_19990305)) {
		q.addOrderByClause("general_comment.date_entered DESC");
	}
	ResultSet rs = dmiSelect(q);
	Vector v = toGeneralCommentList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the geoloc table for the geoloc object that matches the given geoloc_num.
This method is used by:<ul>
<li>HydroBase_GUI_SetCall.structureWindowClosed()</li>
<li>HydroBase_GUI_WISDiagram.lookupLocation()</li>
<li>HydroBase_NodeNetwork.findGeolocCoordinates()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<p>
<li>usp_CDSS_Geoloc_Sel_By_Geoloc_num</li>
</ul>
@param geoloc_num the geoloc_num for which to return the matching geoloc
object.
@return an HydroBase_Geoloc object or null if the geoloc could not be found.
@throws Exception if an error occurs.
*/
public HydroBase_Geoloc readGeolocForGeoloc_num(int geoloc_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_GEOLOC);
	q.addWhereClause("geoloc.geoloc_num = " + geoloc_num);
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toGeolocSPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toGeolocList(rs);
		closeResultSet(rs);
	}
	if (v.size() == 0) {
		return null;
	}
	return (HydroBase_Geoloc)v.elementAt(0);
}

/**
Reads all geophlogs records with the given well_num.  This does not perform
a join with the groundwater table.<p>
<b>This method can only be used with 20050701+ databases.</b>
This method is used by:<p>
<ul><li>HydroBase_GUI_GroundWaterQuery</li></ul><p>
This method uses the following stored procedure:<p>
<ul><li>usp_CDSS_Geophlogs_Sel</li></ul>
@param well_num the well_num to match against.
@return a Vector of HydroBase_GroundWaterWellsGeophlogs Objects.
@throws Exception if an error occurs.
*/
public Vector readGeophlogsListForWell_num(int well_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_GEOPHLOGS);
	q.addWhereClause("well_num = " + well_num);
	ResultSet rs = dmiSelect(q);
	Vector v = toGeophlogsList(rs);
	closeResultSet(rs, q);
	return v;
}

/**
Read global data that should be kept in memory to increase performance.
This is called from the DMI.open() base class method.
The following data are read and are available with get() methods:
<ul>
<li>County_ref</li>
<li>CU_method</li>
<li>HUC (as Vector of String since no separate table exists).</li>
<li>Meas_type (distinct meas_type, time_step, data_source, vax_field).</li>
<li>Struct_meas_type (distinct meas_type, time_step, data_source).</li>
</ul>
*/
public void readGlobalData () {
	String routine = "HydroBaseDMI.readGlobalData";
	boolean test = IOUtil.testing();
	if (test) {
		//IOUtil.testing(false);
		dumpSQLOnExecution(false);
	}
	
	boolean readOnStart = false;
	
	if (!readOnStart) {
		return;
	}
	// Read the CountyRef data...

	try {
		__CountyRef_Vector = readCountyRefList();
	}
	catch ( Exception e) {
		Message.printWarning ( 2, routine,
		"Unable to read County_Ref data.");
		Message.printWarning ( 2, routine, e);
	}
	if (__CountyRef_Vector == null) {
		__CountyRef_Vector = new Vector();
	}

	// Read the CropRef data...
	
	try {
		__CropRef_Vector = readCropRefList();
	}
	catch ( Exception e) {
		Message.printWarning ( 2, routine,
		"Unable to read Crop_Ref data.");
		Message.printWarning ( 2, routine, e);
	}
	if (__CropRef_Vector == null) {
		__CropRef_Vector = new Vector();
	}

	// Read the water districts data...
	try {
		__WaterDistricts_Vector = readWaterDistrictList(false);
	}
	catch (Exception e) {
		Message.printWarning ( 2, routine,
			"Unable to read WaterDistrict data.");
		Message.printWarning ( 2, routine, e);
	}
	if (__WaterDistricts_Vector == null) {
		__WaterDistricts_Vector = new Vector();
	}

	// read the water district by div data
	try {
		__WaterDistrictsByDiv_Vector = readWaterDistrictList(true);
	}
	catch (Exception e) {
		Message.printWarning ( 2, routine,
			"Unable to read WaterDistrict data.");
		Message.printWarning ( 2, routine, e);
	}
	if (__WaterDistrictsByDiv_Vector == null) {
		__WaterDistrictsByDiv_Vector = new Vector();
	}

	// read the water district numbers from the structures table
	try {
		__WaterDistrictsFromStructures_Vector = 
			readStructureDistinctWDList();
	}
	catch (Exception e) {
		Message.printWarning ( 2, routine,
			"Unable to read WaterDistrict data.");
		Message.printWarning ( 2, routine, e);
	}
	if (__WaterDistrictsFromStructures_Vector == null) {
		__WaterDistrictsFromStructures_Vector = new Vector();
	}

	// Read the water divisions data...
	try {
		__WaterDivisions_Vector = readWaterDivisionList();
	}
	catch (Exception e) {
		Message.printWarning ( 2, routine,
			"Unable to read water division data.");
		Message.printWarning ( 2, routine, e);
	}
	if (__WaterDivisions_Vector == null) {
		__WaterDivisions_Vector = new Vector();
	}

	// read the structure types
	try {
		__StrTypes_Vector = readStrTypeList();
	}
	catch (Exception e) {
		Message.printWarning ( 2, routine,
			"Unable to read StrTypes data.");
		Message.printWarning ( 2, routine, e);
	}
	if (__StrTypes_Vector == null) {
		__StrTypes_Vector = new Vector();
	}

	// read the loc types 
	try {
		__LocTypes_Vector = readLocTypeList();
	} 
	catch (Exception e) {
		Message.printWarning ( 2, routine,
			"Unable to read LocTypes data.");
		Message.printWarning ( 2, routine, e);
	}
	if (__LocTypes_Vector == null) {
		__LocTypes_Vector = new Vector();
	}

	// read the use types
	try {
		__UseTypes_Vector = readUseList();
	}
	catch (Exception e) {
		Message.printWarning ( 2, routine,
			"Unable to read UseTypes data.");
		Message.printWarning ( 2, routine, e);
	}
	if (__UseTypes_Vector == null) {
		__UseTypes_Vector = new Vector();
	}

	// Read the BlaneyCriddleCUMethod data...

	try {
		__BlaneyCriddleCUMethod_Vector =
			readCUBlaneyCriddleListForMethodDesc ( null, true);
	}
	catch ( Exception e) {
		Message.printWarning ( 2, routine,
		"Unable to read BlaneyCriddle CU_method data.");
		Message.printWarning ( 2, routine, e);
	}
	if (__BlaneyCriddleCUMethod_Vector == null) {
		__BlaneyCriddleCUMethod_Vector = new Vector();
	}

	// Read the CropcharCUMethod data...

	try {
		__CropcharCUMethod_Vector = readCropcharListForMethodDesc (
			null, true);
	}
	catch ( Exception e) {
		Message.printWarning ( 2, routine,
		"Unable to read Cropchar CU_method data.");
		Message.printWarning ( 2, routine, e);
	}
	if (__CropcharCUMethod_Vector == null) {
		__CropcharCUMethod_Vector = new Vector();
	}

	__HUC_Vector = new Vector();
	// Read the distinct Meas_type.  
	try {
		__MeasType_Vector = readMeasTypeDistinctList();
	}
	catch (Exception e) {
		Message.printWarning ( 2, routine,
			"Unable to read distinct MeasType data.");
		Message.printWarning ( 2, routine, e);
	}

	if (__MeasType_Vector == null) {
		__MeasType_Vector = new Vector();
	}

	// Read the currently in use types.
	try {
		__RefCIU_Vector = readRefCIUList();
	}
	catch (Exception e) {
		Message.printWarning ( 2, routine,
			"Unable to read ref_ciu data.");
		Message.printWarning ( 2, routine, e);
	}
	if (__RefCIU_Vector == null) {
		__RefCIU_Vector = new Vector();
	}

	// Read the distinct Struct_meas_type.  
	try {
		__StructMeasType_Vector = readStructMeasTypeDistinctList();
	}
	catch (Exception e) {
		Message.printWarning ( 2, routine,
			"Unable to read distinct StructMeasType data.");
		Message.printWarning ( 2, routine, e);
	}
	if (__StructMeasType_Vector == null) {
		__StructMeasType_Vector = new Vector();
	}

	if (test) {
		IOUtil.testing(true);
		dumpSQLOnExecution(false);
	}
}

/**
Reads groundwater driller's K sum data.<p>
<b>This method cannot be used with pre-20050701 databases.</b><p>
This method is used by:<p>
<ul><li>HydroBase_GUI_GroundWaterQuery</li></ul><p>
This method used the following view:<p>
<ul><li>vw_CDSS_GroundWaterWellsDillersKSum</li></ul>
@param panel the InputFilter_JPanel to use for querying the data.
@param districtWhere the where clause to use for limiting the query.
@return a Vector of HydroBase_GroundWaterWellsDrillersKSum Objects.
@throws Exception if an error occurs.
*/
public Vector readGroundWaterWellsDrillersKSumList(InputFilter_JPanel panel,
String[] districtWhere) 
throws Exception {
	// SP only
	String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
		panel, districtWhere);

	HydroBase_GUI_Util.fillSPParameters(parameters, 
		getViewNumber(
		"vw_CDSS_GroundWaterWellsDrillersKSum"), 84, null);
	ResultSet rs = runSPFlex(parameters);
	Vector v = toGroundWaterWellsDrillersKSumList(rs);
	closeResultSet(rs, __lastStatement);
	return v;					
}

/**
Reads GroundwaterWells and Geophlogs data.<p>
<b>This method cannot be used with pre-20050701 databases.</b><p>
This method is used by:<p>
<ul><li>HydroBase_GUI_GroundWaterQuery</li></ul><p>
This method used the following view:<p>
<ul><li>vw_CDSS_GroundWaterWellsGeophlogs</li></ul>
@param panel the InputFilter_JPanel to use for querying the data.
@param districtWhere the where clause to use for limiting the query.
@return a Vector of HydroBase_GroundWaterWellsView Objects.
@throws Exception if an error occurs.
*/
public Vector readGroundWaterWellsGeophlogsList(InputFilter_JPanel panel,
String[] districtWhere) 
throws Exception {
	// SP only
	String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
		panel, districtWhere);

	HydroBase_GUI_Util.fillSPParameters(parameters, 
		getViewNumber(
		"vw_CDSS_GroundWaterWellsGeophlogs"), 82, null);
	ResultSet rs = runSPFlex(parameters);
	Vector v = toGroundWaterWellsGeophlogsList(rs);
	closeResultSet(rs, __lastStatement);
	return v;					
}

/**
Read a single record of ground water well meas type data.
<b>This method cannot be used with pre-20050701 databases.</b><p>
This method is used by:<p>
<ul><li>readTimeSeries</li></ul><p>
This method uses the following stored procedure:<p>
<ul><li>vw_CDSS_GroundWaterWellsGroundWaterWellsMeasType</li></ul>
@param identifier the data source ID to match the record against.
@return a HydroBase_GroundWaterWellsView object.
@throws Exception if an error occurs.
*/
public HydroBase_GroundWaterWellsView readGroundWaterWellMeasType(
String identifier)
throws Exception {
	String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
		null, null);
		
	String[] triplet = null;

	if (identifier != null && identifier.length() > 0) {
		triplet = new String[3];
		triplet[0] = "identifier";
		triplet[1] = "MA";
		triplet[2] = identifier;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
	}

	HydroBase_GUI_Util.fillSPParameters(parameters, 
		getViewNumber(
		"vw_CDSS_GroundWaterWellsGroundWaterWellsMeasType"),
		83, null);

	ResultSet rs = runSPFlex(parameters);
	Vector v = toGroundWaterWellMeasTypeList(rs);
	closeResultSet(rs, __lastStatement);

	if (v == null || v.size() == 0) {
		return null;
	}
	else {
		return (HydroBase_GroundWaterWellsView)v.elementAt(0);
	}
}

/**
Reads the database for the data necessary to fill groundwater well and
groundwater meas type information.  For pre-20050701 databases, this method
can be called, but it will immediately call 
'readUnpermittedWells' with the following parameters:<p>
readUnpermittedWells(well_num, null, null)<p>
but note that well_num will be the structure_num to query for in the other 
query.<p>
This is called by:<ul>
<li>HydroBase_Util.addAlternateWellIdentifiers()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_GroundwaterWellsGroundWaterWellsMeasType</li></ul>
@return a HydroBase_GroundWaterWellsView object
@param well_num If &gt; 0, a well_num value to query for.  If missing,
will not be used.
@throws Exception if an error occurs.
*/
public HydroBase_GroundWaterWellsView readGroundWaterWellsMeasType(int well_num)
throws Exception {
	if (getDatabaseVersion() < VERSION_20050701) {
		return readUnpermittedWells(well_num, null, null);
	}

	String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
		null, null);
		
	String[] triplet = null;
	if (!DMIUtil.isMissing(well_num)) {
		triplet = new String[3];
		triplet[1] = "well_num";
		triplet[1] = "EQ";
		triplet[2] = "" + well_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
	}

	HydroBase_GUI_Util.fillSPParameters(parameters, 
		getViewNumber(
		"vw_CDSS_GroundWaterWellsGroundWaterWellsMeasType"),
		83, null);
	ResultSet rs = runSPFlex(parameters);
	Vector v = toGroundWaterWellMeasTypeList(rs);
	closeResultSet(rs, __lastStatement);

	if (v == null || v.size() == 0) {
		return null;
	}
	else {
		return (HydroBase_GroundWaterWellsView)v.elementAt(0);
	}
}

/**
Reads the database for the data necessary to fill groundwater well and
groundwater meas type information.  For pre-20050701 databases, this method
can be called, but it will immediately call 
'readUnpermittedWellStructMeasTypeList' and return THAT query's Vector.
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_GroundWaterWellsGroundWaterWellsMeasType</li></ul>
@param panel the panel of InputFilters that hold the query constraints.
@param districtWhere the value returned by getWaterDistrictWhereClause().
@return a Vector of HydroBase_StructureGeolocStructMeasType or 
HydroBase_StructureGeolocStructMeasTypeView objects.
@throws Exception if there is an error running the query.
*/
public Vector readGroundWaterWellsMeasTypeList(InputFilter_JPanel panel, 
String[] districtWhere)
throws Exception {
	if (getDatabaseVersion() < VERSION_20050701) {
		return readUnpermittedWellStructMeasTypeList(panel, 
			districtWhere);
	}

	String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
		panel, districtWhere);
	HydroBase_GUI_Util.fillSPParameters(parameters, 
		getViewNumber(
	    "vw_CDSS_GroundWaterWellsGroundWaterWellsMeasType"),
		83, null);
	ResultSet rs = runSPFlex(parameters);
	Vector v = toGroundWaterWellMeasTypeList(rs);
	closeResultSet(rs, __lastStatement);
	return v;
}

/**
Reads the database for the data necessary to fill the pump test table in the 
ground water query GUI.  This method is called both for databases that use 
stored procedures and those that do not, and it handles calling SPFlex or
the readXXXList() method, as appropriate.
This method is used by:<ul>
<li>HydroBase_GUI_GroundWaterQuery</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following views:<p>
<ul><li>vw_CDSS_GroundWaterWells_PumpingTest (for databases newer than
VERSION_20050701)</li></ul>
<ul><li>vw_CDSS_Pump_Test</li></ul>
@param panel the panel of InputFilters that hold the query constraints.
@param districtWhere the value returned by getWaterDistrictWhereClause().
@return a Vector of HydroBase_GroundWaterWellsPumpingTest 
objects.
@throws Exception if there is an error running the query.
*/
public Vector readGroundWaterWellsPumpingTestList(InputFilter_JPanel panel, 
String[] districtWhere)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			panel, districtWhere);

		if (getDatabaseVersion() < VERSION_20050701) {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber(
					"vw_CDSS_Pump_Test"), 19, null);
		}
		else {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber(
				       "vw_CDSS_GroundWaterWellsPumpingTests"),
					81, null);
		}
			
		ResultSet rs = runSPFlex(parameters);
		Vector v = toGroundWaterWellsPumpingTestList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		Vector wheres 
			= HydroBase_GUI_Util.getWhereClausesFromInputFilter(
			this, panel, HydroBase_GUI_Util._GEOLOC_TABLE_NAME,
			HydroBase_GUI_Util.GROUND_WATER);
		if (districtWhere != null) {
			wheres.add(districtWhere[0]);
		}
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_PUMP_TEST_VIEW);
		if (wheres != null) {
			int size = wheres.size();
			for (int i = 0; i < size; i++) {
				q.addWhereClause((String)wheres.elementAt(i));
			}
		}
		
		ResultSet rs = dmiSelect(q);
		Vector v = toGroundWaterWellsPumpingTestList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Reads groundwater volcanics data.<p>
<b>This method cannot be used with pre-20050701 databases.</b><p>
This method is used by:<p>
<ul><li>HydroBase_GUI_GroundWaterQuery</li></ul><p>
This method used the following view:<p>
<ul><li>vw_CDSS_GroundWaterWellsVolcanics</li></ul>
@param panel the InputFilter_JPanel to use for querying the data.
@param districtWhere the where clause to use for limiting the query.
@return a Vector of HydroBase_GroundWaterWellsVolcanics Objects.
@throws Exception if an error occurs.
*/
public Vector readGroundWaterWellsVolcanicsList(InputFilter_JPanel panel,
String[] districtWhere) 
throws Exception {
	// SP only
	String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
		panel, districtWhere);

	HydroBase_GUI_Util.fillSPParameters(parameters, 
		getViewNumber(
		"vw_CDSS_GroundWaterWellsVolcanics"), 85, null);
	ResultSet rs = runSPFlex(parameters);
	Vector v = toGroundWaterWellsVolcanicsList(rs);
	closeResultSet(rs, __lastStatement);
	return v;					
}

/**
Read the loc_type table for all data.<p>
This method is used by:<ul>
<li>HydroBaseDMI.readGlobalData()</li>
</ul>
<p><b>Stored Procedure</b><p>
@return a Vector of HydroBase_LocType objects.
@throws Exception if an error occurs.
*/
public Vector readLocTypeList() 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_LOC_TYPE);
	ResultSet rs = dmiSelect(q);
	Vector v = toLocTypeList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the mapfile table for records with the matching structure_num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_StructureMoreInfo.submitAndDisplayMapfileQuery()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_Mapfile_Sel_By_Structure_num</li>
</ul>
@return a Vector of HydroBase_Mapfile objects.
@throws Exception if an error occurs.
*/
public Vector readMapfileListForStructure_num(int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_MAPFILE);
	q.addWhereClause("mapfile.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toMapfileSPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toMapfileList(rs);
		closeResultSet(rs);
	}
	return v;
}

/**
Reads the meas_type table for all distinct meas types.<p>
</pre>
This method is called by:<p>
<ul><li>readGlobalData()</li></ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_MeasType_Sel_Distinct</li>
</ul>
@return a Vector of HydroBase_MeasTypes.
@throws Exception if there are any errors.
*/
public Vector readMeasTypeDistinctList()
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_MEAS_TYPE_DISTINCT);
	q.addOrderByClause("meas_type.meas_type");
	ResultSet rs = dmiSelect(q);
	Vector v = toMeasTypeDistinctList(rs);	
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Reads the meas_type table for all data matching the specified criteria.<p>
</pre>
This method is called by:<p>
<ul><li>readTimeSeries()</li></ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>vw_CDSS_StationMeasType</li>
</ul>
@param station_num the station_num to query for.  If missing (-999), will not
be used.
@param meas_type the meas_type to query for.  If null, will not be used.
@param vax_field the vax_field to query for.  If null, will not be used.
@param time_step the time_step to query for.  If null, will not be used.
@param data_source the data_source to query for.  If null, will not be used.
@return a Vector of HydroBase_MeasTypes.
@throws Exception if there are any errors.
*/
public Vector readMeasTypeList(int station_num, String meas_type, 
String vax_field, String time_step, String data_source)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = null;
		if (!DMIUtil.isMissing(station_num)) {
			triplet = new String[3];
			triplet[0] = "station_num";
			triplet[1] = "EQ";
			triplet[2] = "" + station_num;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (meas_type != null && meas_type.length() > 0) {
			triplet = new String[3];
			triplet[0] = "meas_type";
			triplet[1] = "MA";
			triplet[2] = meas_type;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (vax_field != null && vax_field.length() > 0) {
			triplet = new String[3];
			triplet[0] = "vax_field";
			triplet[1] = "MA";
			triplet[2] = vax_field;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (time_step != null && time_step.length() > 0) {
			triplet = new String[3];
			triplet[0] = "time_step";
			triplet[1] = "MA";
			triplet[2] = time_step;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (data_source != null && data_source.length() > 0) {
			triplet = new String[3];
			triplet[0] = "data_source";
			triplet[1] = "MA";
			triplet[2] = data_source;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_StationMeasType"), 70, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toStationMeasTypeSPList(rs, false);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_STATION_MEAS_TYPE_VIEW);
		if (!DMIUtil.isMissing(station_num)) {
			q.addWhereClause("meas_type.station_num = " 
				+ station_num);
		}
		if ((meas_type != null) && (meas_type.length() > 0)) {
			q.addWhereClause("meas_type.meas_type = '" 
				+ meas_type + "'");
		}
		if ((vax_field != null) && (vax_field.length() > 0)) {
			q.addWhereClause("meas_type.vax_field = '" 
				+ vax_field + "'");
		}
		if ((time_step != null) && (time_step.length() > 0)) {
			q.addWhereClause("meas_type.time_step = '" 
				+ time_step + "'");
		}
		if ((data_source != null) && (data_source.length() > 0)) {
			q.addWhereClause("meas_type.data_source = '" 
				+ data_source + "'");
		}
		q.addOrderByClause("station.station_num");
		q.addOrderByClause("meas_type.meas_num");
		ResultSet rs = dmiSelect(q);
		Vector v = toStationMeasTypeSPList(rs, false);
		closeResultSet(rs);
		return v;
	}
}

/**
General function to read monthly data from the station tables.
Since all these queries share a lot of common aspects, they can all basically
be handled by one main read and one main to*() method.  Order results
according to cal_year, cal_mon_num field.
@param sqlNumber the SQL select statement to execute, as follows:
<pre>
SQLNumber                  Description            Table             Field
__S_MONTHLY_AVG_MAX_T       Monthly avg max temp.  monthly_temp      avg_max_t
__S_MONTHLY_AVG_MIN_T       Monthly avg min temp.  monthly_temp      avg_min_t
__S_MONTHLY_MAX_FLOW        Monthly max flow       monthly_flow      max_q_cfs
__S_MONTHLY_MEAN_T          Monthly mean temp.     monthly_temp      mean_t
__S_MONTHLY_MIN_FLOW        Monthly min flow       monthly_flow      min_q_cfs
__S_MONTHLY_TOTAL_EVAP      Monthly total evap.    monthly_evap      total_evap
__S_MONTHLY_TOTAL_FLOW      Monthly flow vol.      monthly_flow      total_q_af
__S_MONTHLY_TOTAL_NFLOW     Monthly nat. flow vol. monthly_nflow     total_q_af
__S_MONTHLY_TOTAL_PCPN      Monthly precip.        monthly_pcpn      total_pcpn
__S_MONTHLY_TOTAL_SNOW      Monthly snow accum.    monthly_snow      total_snow
</pre>
This method is used by:<ul>
<li>readTimeSeries()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_MonthlyEvap</li>
<li>vw_CDSS_MonthlyFlow_MaxQ</li>
<li>vw_CDSS_MonthlyFlow_MinQ</li>
<li>vw_CDSS_MonthlyFLow_TotalAF</li>
<li>vw_CDSS_MonthlyNflow</li>
<li>vw_CDSS_MonthlyPcpn</li>
<li>vw_CDSS_MonthlySnow</li>
<li>vw_CDSS_MonthlyTemp_Max</li>
<li>vw_CDSS_MonthlyTemp_Mean</li>
<li>vw_CDSS_MonthlyTemp_Min</li>
</ul>
@param meas_num the meas_type.meas_num key for this time series. -999 to ignore.
@param req_date1 If not null, specify the start date for the query.
@param req_date2 If not null, specify the end date for the query.
@return a Vector of HydroBase_X objects.
@throws Exception if an error occurs.
*/
protected Vector readMonthlyStationData(int sqlNumber, int meas_num,
DateTime req_date1, DateTime req_date2) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String viewName = null;
		int orderNumber = -1;

		switch(sqlNumber) {
			case __S_MONTHLY_MAX_ADMIN_FLOW:
				viewName = "vw_CDSS_MonthlyAdminFlow_MaxQ";
				orderNumber = 114;
				break;
			case __S_MONTHLY_MIN_ADMIN_FLOW:
				viewName = "vw_CDSS_MonthlyAdminFlow_MinQ";
				orderNumber = 115;
				break;
			case __S_MONTHLY_TOTAL_ADMIN_FLOW:
				viewName = "vw_CDSS_MonthlyAdminFlow_TotalAF";
				orderNumber = 116;
				break;
			case __S_MONTHLY_TOTAL_EVAP:
				viewName = "vw_CDSS_MonthlyEvap";
				orderNumber = 56;
				break;
			case __S_MONTHLY_MAX_FLOW:
				viewName = "vw_CDSS_MonthlyFlow_MaxQ";
				orderNumber = 54;
				break;
			case __S_MONTHLY_MIN_FLOW:
				viewName = "vw_CDSS_MonthlyFlow_MinQ";
				orderNumber = 55;
				break;
			case __S_MONTHLY_TOTAL_FLOW:
				viewName = "vw_CDSS_MonthlyFlow_TotalAF";
				orderNumber = 53;
				break;
			case __S_MONTHLY_TOTAL_NFLOW:
				viewName = "vw_CDSS_MonthlyNflow";
				orderNumber = 57;
				break;
			case __S_MONTHLY_TOTAL_PCPN:
				viewName = "vw_CDSS_MonthlyPcpn";
				orderNumber = 58;
				break;
			case __S_MONTHLY_TOTAL_SNOW:
				viewName = "vw_CDSS_MonthlySnow";
				orderNumber = 59;
				break;
			case __S_MONTHLY_AVG_MAX_T:
				viewName = "vw_CDSS_MonthlyTemp_Max";
				orderNumber = 51;
				break;
			case __S_MONTHLY_MEAN_T:
				viewName = "vw_CDSS_MonthlyTemp_Mean";
				orderNumber = 50;
				break;
			case __S_MONTHLY_AVG_MIN_T:
				viewName = "vw_CDSS_MonthlyTemp_Min";
				orderNumber = 52;
				break;
		}

		String[] triplet = null;
		if (!DMIUtil.isMissing(meas_num)) {
			triplet = new String[3];
			triplet[0] = "meas_num";
			triplet[1] = "EQ";
			triplet[2] = "" + meas_num;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "LE";
			triplet[2] = "" + req_date2.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber(viewName), orderNumber, null);
		ResultSet rs = runSPFlex(parameters);

		Vector v = null;

		switch(sqlNumber) {
			case __S_MONTHLY_TOTAL_EVAP:
				v = toMonthlyEvapList(rs);
				break;
			case __S_MONTHLY_MAX_ADMIN_FLOW:
			case __S_MONTHLY_MAX_FLOW:
			case __S_MONTHLY_MIN_ADMIN_FLOW:
			case __S_MONTHLY_MIN_FLOW:
			case __S_MONTHLY_TOTAL_ADMIN_FLOW:
			case __S_MONTHLY_TOTAL_FLOW:
				v = toMonthlyFlowList(rs, sqlNumber);
				break;
			case __S_MONTHLY_TOTAL_NFLOW:
				v = toMonthlyNflowList(rs);
				break;
			case __S_MONTHLY_TOTAL_PCPN:
				v = toMonthlyPcpnList(rs);
				break;
			case __S_MONTHLY_TOTAL_SNOW:
				v = toMonthlySnowList(rs);
				break;
			case __S_MONTHLY_AVG_MAX_T:
			case __S_MONTHLY_MEAN_T:
			case __S_MONTHLY_AVG_MIN_T:
				v = toMonthlyTempList(rs, sqlNumber);
				break;
		}

		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, sqlNumber);
		if (!DMIUtil.isMissing(meas_num)) {
			q.addWhereClause("meas_num=" + meas_num);
		}
		if (req_date1 != null) {
			q.addWhereClause("cal_year >=" + req_date1.getYear());
		}
		if (req_date2 != null) {
			q.addWhereClause("cal_year <=" + req_date2.getYear());
		}
		q.addOrderByClause("cal_year");
		q.addOrderByClause("cal_mon_num");
		ResultSet rs = dmiSelect(q);
		Vector v = null;
		switch(sqlNumber) {
			case __S_MONTHLY_TOTAL_PCPN:
				v = toMonthlyPcpnList(rs);		break;
			case __S_MONTHLY_AVG_MAX_T:
			case __S_MONTHLY_AVG_MIN_T:
			case __S_MONTHLY_MEAN_T:
				v = toMonthlyTempList(rs, sqlNumber);	break;
			case __S_MONTHLY_TOTAL_EVAP:
				v = toMonthlyEvapList(rs);		break;
			case __S_MONTHLY_TOTAL_SNOW:
				v = toMonthlySnowList(rs);		break;
			case __S_MONTHLY_MAX_FLOW:
			case __S_MONTHLY_MIN_FLOW:
			case __S_MONTHLY_TOTAL_FLOW:
				v = toMonthlyFlowList(rs, sqlNumber);	break;
			case __S_MONTHLY_TOTAL_NFLOW:
				v = toMonthlyNflowList(rs);		break;
		}
		closeResultSet(rs);
		return v;
	}
}

/**
Read the net_amts table for a structure_num.
This method is used by:<ul>
<li>HydroBase_GUI_EditCallsBypass</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following views:<p>
<li>vw_CDSS_NetAmts</li></ul>
@param structure_num if missing, will be ignored.
@param wd Water district to select.  If missing, will be ignored.
@param id Identifier to select.  If missing, will be ignored.
@param positiveNetRateAbs whether to only return net amts with positive net
rates.
@param orderBys a Vector of potential order by clauses to include.  If null,
will not be included.  
@return a Vector of HydroBase_NetAmts objects.
@throws Exception if an error occurs.
*/
public Vector readNetAmtsList(int structure_num, int wd, int id, 
boolean positiveNetRateAbs, Vector orderBys, boolean old)
throws Exception {
	return readNetAmtsList(structure_num, wd, id, positiveNetRateAbs,
		null);
}

public Vector readNetAmtsList(int structure_num, int wd, int id, 
boolean positiveNetRateAbs, String orderCode)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = null;
		if (!DMIUtil.isMissing(structure_num)) {
			triplet = new String[3];
			triplet[0] = "structure_num";
			triplet[1] = "EQ";
			triplet[2] = "" + structure_num;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (!DMIUtil.isMissing(wd)) {
			triplet = new String[3];
			triplet[0] = "wd";
			triplet[1] = "EQ";
			triplet[2] = "" + wd;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (!DMIUtil.isMissing(id)) {
			triplet = new String[3];
			triplet[0] = "id";
			triplet[1] = "EQ";
			triplet[2] = "" + id;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (positiveNetRateAbs) {
			triplet = new String[3];
			triplet[0] = "net_rate_abs";
			triplet[1] = "GT";
			triplet[2] = "0";
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		int orderNumber = -1;
		if (orderCode == null) {
			// default order by (used by StateDMI)
			orderNumber = 15;
		}
		else if (orderCode.equals("72")) {
			orderNumber = 72;
		}
		else {
			// not yet assigned
			orderNumber = 72;
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_NetAmts"), orderNumber, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toNetAmtsSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_NET_AMTS_FOR_WD_ID);
		if (!DMIUtil.isMissing(structure_num)) {
			q.addWhereClause("net_amts.structure_num = " 
				+ structure_num);
		}
		if (!DMIUtil.isMissing(wd)) {
			q.addWhereClause("net_amts.wd = " + wd);
		}
		if (!DMIUtil.isMissing(id)) {
			q.addWhereClause("net_amts.id = " + id);
		}
		if (positiveNetRateAbs) {
			q.addWhereClause("net_rate_abs > 0");
		}

		if (orderCode == null) {
			// default order by (used by StateDMI)
			q.addOrderByClause("net_amts.admin_no");
			q.addOrderByClause("net_amts.order_no");
		}
		else if (orderCode.equals("72")) {
			q.addOrderByClause("net_amts.net_num");
			q.addOrderByClause("net_amts.[id]");
		}
		else {
			// not yet assigned
			q.addOrderByClause("net_amts.net_num");
			q.addOrderByClause("net_amts.[id]");
		}

		
		ResultSet rs = dmiSelect(q);
		Vector v = toNetAmtsList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Reads the database for the data necessary to fill the table in the 
net amts query GUI.  This method is called both for databases that use 
stored procedures and those that do not, and it handles calling SPFlex or
the readXXXList() method, as appropriate.
<p><b>Stored Procedures</b><p>
This method uses the following views:<p>
<li>vw_CDSS_NetAmts</li></ul>
@param panel the panel of InputFilters that hold the query constraints.
@param districtWhere the value returned by getWaterDistrictWhereClause().
@param mapQueryLimits the GRLimits defining the geographical area for which
to query.
@param type the type of report for which the query is being run.  Only used
when coming from HydroBase_Report_NetAmts.  If -1, ignored.
@return a Vector of HydroBase_NetAmts objects.
@throws Exception if there is an error running the query.
*/
public Vector readNetAmtsList(InputFilter_JPanel panel, 
String[] districtWhere, GRLimits mapQueryLimits, int type)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			panel, districtWhere);

		int orderNumber = 0;
		if (type == HydroBase_Report_NetAmounts.ADMIN_STREAM 
			|| type == HydroBase_Report_NetAmounts.PRIORITY_STREAM){
			orderNumber = 16;
		}
		if (type == HydroBase_Report_NetAmounts.STREAM) {
			orderNumber = 49;
		}		
			
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_NetAmts"), orderNumber, 
			mapQueryLimits);

		ResultSet rs = runSPFlex(parameters);
		Vector v = toNetAmtsSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;	
	}
	else {
		Vector orderBys 
			= HydroBase_GUI_Util.getOrderBysFromInputFilter_JPanel(
			panel, false);
		Vector wheres 
			= HydroBase_GUI_Util.getWhereClausesFromInputFilter(
			this, panel, HydroBase_GUI_Util._NET_AMOUNTS_TABLE_NAME,
			HydroBase_GUI_Util.WATER_RIGHT);
		if (districtWhere != null) {
			wheres.add(districtWhere[0]);
		}
		if (type == HydroBase_Report_NetAmounts.ADMIN_STREAM 
			|| type == HydroBase_Report_NetAmounts.PRIORITY_STREAM 
			|| type == HydroBase_Report_NetAmounts.STREAM) {
			orderBys.add("net_amts.wd_stream_name");
		}
		if (type == HydroBase_Report_NetAmounts.STREAM) {
			orderBys.add("net_amts.wr_name");
		}		
		orderBys.add("net_amts.net_num");
		return readNetAmtsList(wheres, orderBys);
	}
}

/**
Read the net_amts table for all data.  This method is used by non-SP code.
This method is used by:<ul>
<li>HydroBase_Device_WISDiagram.queryRights()</li>
<li>HydroBase_GUI_EditCallsBypass.structureListClicked()</li>
<li>HydroBase_GUI_SetCall.structureListClicked()</li>
<li>HydroBase_GUI_WaterRightsQuery.submitQuery()</li>
<li>StateDMI_Processor.do_readDiversionStationRightsFromHydroBase()</li>
</ul>
<p><b>Stored Procedures</b><p>
<b>THIS METHOD HAS NO STORED PROCEDURES</b><br>
Use instead one of the other readNetAmts() methods.
@param where a Vector of where clauses to limit the kind of data that is 
returned.  Can be null.
@param order a Vector of order by clauses.  Can be null.
@return a Vector of HydroBase_NetAmts objects.
@throws Exception if an error occurs.
*/
public Vector readNetAmtsList(Vector where, Vector order) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_NET_AMTS);
	if (where != null) {
		for (int i = 0; i < where.size(); i++) {
			q.addWhereClause(convertCounty(
				(String)where.elementAt(i)));
		}
	}
	if (order != null) {
		for (int i = 0; i < order.size(); i++) {
			q.addOrderByClause((String)order.elementAt(i));
		}
	}
	ResultSet rs = dmiSelect(q);
	Vector v = toNetAmtsList(rs);
	closeResultSet(rs);
	return v;
}

/**
Read the parcel_use_ts tables for all data with the matching
criteria.<p>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_Parcel_Use_TS</li></ul>
This method is used by StateDMI.
@param cal_year cal year to query for - specify missing to ignore.
@param div Division to query for - specify missing to ignore.
@param parcel_id Parcel_id to query for - specify missing to ignore.
@param land_use Land use to query for - can specify null or blank to ignore.
@param irrig_type Irrigation type to query for - can specify null or blank to
ignore.
@param req_date1 First cal_year to read - specify null to ignore.
@param req_date2 Last cal_year to read - specify null to ignore.
@return a Vector of HydroBase_ParcelUseTS objects.  The objects are sorted by
div, parcel_id, and cal_year.
*/
public Vector readParcelUseTSList(int cal_year, int div, int parcel_id,
String land_use, String irrig_type, DateTime req_date1, DateTime req_date2)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		String[] triplet = null;
		
		if (!DMIUtil.isMissing(cal_year)) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "EQ";
			triplet[2] = "" + cal_year;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (!DMIUtil.isMissing(div)) {
			triplet = new String[3];
			triplet[0] = "div";
			triplet[1] = "EQ";
			triplet[2] = "" + div;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}			

		if (!DMIUtil.isMissing(parcel_id)) {
			triplet = new String[3];
			triplet[0] = "parcel_id";
			triplet[1] = "EQ";
			triplet[2] = "" + parcel_id;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}			

		if (land_use != null && land_use.length() > 0) {
			triplet = new String[3];
			triplet[0] = "land_use";
			triplet[1] = "MA";
			triplet[2] = land_use;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}			

		if (irrig_type != null && irrig_type.length() > 0) {
			triplet = new String[3];
			triplet[0] = "irrig_type";
			triplet[1] = "MA";
			triplet[2] = irrig_type;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}			

		if (req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "LE";
			triplet[2] = "" + req_date2.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Parcel_Use_TS"), 18, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toParcelUseTSList(rs, false);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_PARCEL_USE_TS);
	
		q.addOrderByClause("parcel_use_ts.div");
		q.addOrderByClause("parcel_use_ts.parcel_id");
		q.addOrderByClause("parcel_use_ts.cal_year");

		if (!DMIUtil.isMissing(div)) {
			q.addWhereClause("parcel_use_ts.div = " + div);
		}
		if (!DMIUtil.isMissing(cal_year)) {
			q.addWhereClause("parcel_use_ts.cal_year = "+ cal_year);
		}
		if (!DMIUtil.isMissing(parcel_id)) {
			q.addWhereClause("parcel_use_ts.parcel_id = " 
				+ parcel_id);
		}
		if ((land_use != null) && (land_use.length() > 0)) {
			q.addWhereClause("parcel_use_ts.land_use = '" 
				+ land_use + "'");
		}
		if (irrig_type != null && irrig_type.length() > 0) {
			q.addWhereClause("parcel_use_ts.irrig_type = '"
				+ irrig_type + "'");
		}
		
		if (req_date1 != null) {
			q.addWhereClause("parcel_use_ts.cal_year >= " 
				+ req_date1.getYear());
		}
		if (req_date2 != null) {
			q.addWhereClause("parcel_use_ts.cal_year <= " 
				+ req_date2.getYear());
		}
	
		ResultSet rs = dmiSelect(q);
		Vector v = toParcelUseTSList(rs, false);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the parcel_use_ts tables for all distinct cal_years with the matching
criteria.<p>
<p><b>Stored Procedures</b><p>
This method uses the following Stored Procedure:<p><ul>
<li>usp_CDSS_ParcelUseTS_CalYear_Distinct</li></ul>
This method is used by StateDMI.
@param div Division to query for - specify missing to ignore.
@return a Vector of Integers, each of which is a unique calendar year for the
specified div (or all divs), sorted ascending.
*/
public Vector readParcelUseTSDistinctCalYearsList(int div)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_PARCEL_USE_TS_DISTINCT);

	q.selectDistinct(true);

	q.addOrderByClause("parcel_use_ts.cal_year");

	if (__useSP) {
		q.addWhereClause("parcel_use_ts.div = " + div);
	}
	else {
		if (!DMIUtil.isMissing(div)) {
			q.addWhereClause("parcel_use_ts.div = " + div);
		}
	}

	ResultSet rs = dmiSelect(q);
	Vector v = toParcelUseTSList(rs, true);

	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}

	int size = v.size();
	HydroBase_ParcelUseTS p = null;
	Vector calYears = new Vector();
	for (int i = 0; i < size; i++) {
		p = (HydroBase_ParcelUseTS)v.elementAt(i);
		calYears.add(new Integer(p.getCal_year()));
	}
	return calYears;
}

/**
Read the parcel_use_ts tables for all data with the matching
criteria, in particular matching a list of parcel IDs.<p>
See the overloaded method for a description of the query.  This version varies
only in that a list of parcel identifiers can be specified, rather than one.
</pre>
<b>Stored Procedures</b><p>
This method uses the stored procedures used in readParcelUseTSList().
This method is used by StateDMI to aggregate parcels.
@param div Division to query for - specify a negative number to ignore.
@param parcel_id Parcel_id values to query for - specify null to ignore.
@param land_use Land use to query for - can specify null or blank to ignore.
@param irrig_type Irrigation type to query for - can specify null or blank to
ignore.
@param req_date1 First cal_year to read - specify null to ignore.
@param req_date2 Last cal_year to read - specify null to ignore.
@return a Vector of HydroBase_ParcelUseTS objects.  The objects are sorted by
div, parcel_id, and cal_year.
*/
public Vector readParcelUseTSListForParcelList(int div, int[] parcel_id,
String land_use, String irrig_type, DateTime req_date1, DateTime req_date2 )
throws Exception {
	if (__useSP) {
		int size = 0;
		Vector results = new Vector();
		Vector v = null;

		if (parcel_id.length == 0) {
			return readParcelUseTSList(-999, div, -999,
				land_use, irrig_type, req_date1, req_date2);
		}
		else {
			for (int i = 0; i < parcel_id.length; i++) {
				v = readParcelUseTSList(-999, div, parcel_id[i],
					land_use, irrig_type, req_date1,
					req_date2);
				size = v.size();
				for (int j = 0; j < size; j++) {
					results.add(v.elementAt(j));
				}
			}
			return results;
		}
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_PARCEL_USE_TS);
	
		q.addOrderByClause("parcel_use_ts.div");
		q.addOrderByClause("parcel_use_ts.parcel_id");
		q.addOrderByClause("parcel_use_ts.cal_year");
		if (div > 0) {
			q.addWhereClause("parcel_use_ts.div = " + div);
		}
		if (parcel_id != null) {
			StringBuffer where = new StringBuffer();
			where.append("(");
			for ( int i = 0; i < parcel_id.length; i++) {
				if (i != 0) {
					where.append(" OR ");
				}
				where.append("(parcel_use_ts.parcel_id = " +
					parcel_id[i]+ ")");
			}
			where.append(")");
			q.addWhereClause(where.toString());
		}
		if ((land_use != null) && (land_use.length() > 0)) {
			q.addWhereClause("parcel_use_ts.land_use = '" 
				+land_use+"'");
		}
		if (req_date1 != null) {
			q.addWhereClause("parcel_use_ts.cal_year >= " +
				req_date1.getYear());
		}
		if (req_date2 != null) {
			q.addWhereClause("parcel_use_ts.cal_year <= " + 
				req_date2.getYear());
		}
	
		ResultSet rs = dmiSelect(q);
		Vector v = toParcelUseTSList(rs, false);
		closeResultSet(rs);
		return v;
	}
}

/**
Reads all record from the parcel use ts structure join table that have the
specified structure_num.
This method is used by:<ul>
<li>HydroBase_GUI_IrrigatedAcres.HydroBase_GUI_IrrigatedAcres()</li>
<li>StateDMI for processing well data.</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_ParcelUseTSStructureToParcel_Sel_By_Structure_num</li>
</ul>
@param structure_num the structure_num for which to query the database.
@return a Vector of HydroBase_ParcelUseTSStructureToParcel objects.
@throws Exception if an error occurs.
*/
public Vector readParcelUseTSStructureToParcelListForStructure_num(
int structure_num) 
throws Exception {
	return readParcelUseTSStructureToParcelListForStructure_numCal_year (
		structure_num, -999 );
}

/**
Reads all record from the parcel use ts structure join table that have the
specified structure_num, for the given calendar year.
This method is used by:<ul>
<li>StateDMI for processing well data.</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_ParcelUseTSStructureToParcel_Sel_By_StructureNumCalYear</li>
</ul>
@param structure_num the structure_num for which to query the database.
@param cal_year Calendar year for which to query the database.
@return a Vector of HydroBase_ParcelUseTSStructureToParcel objects.
@throws Exception if an error occurs.
*/
public Vector readParcelUseTSStructureToParcelListForStructure_numCal_year(
int structure_num, int cal_year) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_PARCEL_USE_TS_STRUCTURE_TO_PARCEL_JOIN_FOR_CAL_YEAR);
	if ( structure_num > 0 ) {
		q.addWhereClause("structure_to_parcel.structure_num = "+ structure_num);
	}
	if ( cal_year > 0 ) {
		q.addWhereClause("parcel_use_ts.cal_year = "+ cal_year);
	}
	q.addOrderByClause("parcel_use_ts.parcel_num");
	q.addOrderByClause("parcel_use_ts.cal_year");
	q.addOrderByClause("parcel_use_ts.parcel_id");
	q.addOrderByClause("parcel_use_ts.land_use");
	ResultSet rs = dmiSelect(q);
	Vector v = toParcelUseTSStructureToParcelList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the person_details table for all data and join with data in the structure
table.<p>
This method is used by:<ul>
<li>HydroBase_GUI_OwnerContact.submitAndDisplayPersonDetailsQuery</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_PersonDetails_Sel_By_Structure_num</li>
</ul>
@return a HydroBase_PersonDetail object or null.
@throws Exception if an error occurs.
*/
public HydroBase_PersonDetails readPersonDetailsForStructure_num(
int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_PERSON_DETAILS);
	q.addWhereClause("structure.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = toPersonDetailsList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	if (v == null || v.size() == 0) {
		return null;
	}
	return (HydroBase_PersonDetails)(v.elementAt(0));
}

/**
Reads the ref_ciu table for all data.<p>
This method is called by:<p>
<ul><li>readGlobalData()</li></ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_refCIU_Sel</li>
</ul>
@return a Vector of HydroBase_RefCIUs
@throws Exception if an error occurs.
*/
public Vector readRefCIUList() 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_REF_CIU);
	ResultSet rs = dmiSelect(q);
	Vector v = toRefCIUList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the res_eom table for all data.  <p>
This is used by:<ul>
<li>readTimeSeries()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_Res_EOM</li></ul>
@param meas_num Meas_type.meas_num for query.  
@param req_date1 If not null, specify the start date for the query.
@param req_date2 If not null, specify the end date for the query.
@return a Vector of HydroBase_ResEOM objects.
@throws Exception if an error occurs.
*/
public Vector readResEOMList (	int meas_num, DateTime req_date1,
				DateTime req_date2 ) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		String[] triplet = new String[3];
		triplet[0] = "meas_num";
		triplet[1] = "EQ";
		triplet[2] = "" + meas_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		if (req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "LE";
			triplet[2] = "" + req_date2.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Res_EOM"), 20, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toResEOMSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_RES_EOM);
		q.addWhereClause("res_eom.meas_num = " + meas_num);
		if (req_date1 != null) {
			q.addWhereClause("res_eom.cal_year >=" +
				req_date1.getYear());
		}
		if (req_date2 != null) {
			q.addWhereClause("res_eom.cal_year <=" +
				req_date2.getYear());
		}
		q.addOrderByClause("res_eom.cal_year");
		q.addOrderByClause("res_eom.cal_mon_num");
		ResultSet rs = dmiSelect(q);
		Vector v = toResEOMList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the res_meas table for all data with the matching meas_num.<p>
This is used by:<ul>
<li>readTimeSeries()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_Res_Meas</li></ul>
@param meas_num Meas_type.meas_num for query.
@param req_date1 If not null, specify the start date for the query.
@param req_date2 If not null, specify the end date for the query.
@return a Vector of HydroBase_ResMeas objects.
@throws Exception if an error occurs.
*/
public Vector readResMeasList(int meas_num, DateTime req_date1, 
DateTime req_date2) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		String[] triplet = new String[3];
		triplet[0] = "meas_num";
		triplet[1] = "EQ";
		triplet[2] = "" + meas_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		if (req_date1 != null) {
			if (req_date1.getPrecision() ==DateTime.PRECISION_DAY) {
				triplet = new String[3];
				triplet[0] = "date_time";
				triplet[1] = "GE";
				triplet[2] = "" + DMIUtil.formatDateTime(this,
					req_date1);
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);
			}
			else {
				DateTime req_date1_copy=new DateTime(req_date1);
				req_date1_copy.setPrecision(
					DateTime.PRECISION_DAY);
				req_date1_copy.setDay(1);
			
				triplet = new String[3];
				triplet[0] = "date_time";
				triplet[1] = "GE";
				triplet[2] = "" + DMIUtil.formatDateTime(this,
					req_date1_copy);
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);			
			}
		}

		if (req_date2 != null) {
			if (req_date2.getPrecision() ==DateTime.PRECISION_DAY) {
				triplet = new String[3];
				triplet[0] = "date_time";
				triplet[1] = "LE";
				triplet[2] = "" + DMIUtil.formatDateTime(this,
					req_date2);
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);			
			}
			else {
				DateTime req_date2_copy=new DateTime(req_date2);
				req_date2_copy.setPrecision( 
					DateTime.PRECISION_DAY);
				req_date2_copy.setDay(
					TimeUtil.numDaysInMonth(
					req_date2_copy));
			
				triplet = new String[3];
				triplet[0] = "date_time";
				triplet[1] = "LE";
				triplet[2] = "" + DMIUtil.formatDateTime(this,
					req_date2_copy);
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);			
			}
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Res_Meas"), 21, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toResMeasList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_RES_MEAS);
		q.addWhereClause("res_meas.meas_num = " + meas_num);
		if (req_date1 != null) {
			if (req_date1.getPrecision() ==DateTime.PRECISION_DAY) {
				q.addWhereClause("res_meas.date_time >=" 
					+ DMIUtil.formatDateTime(this,
					req_date1));
			}
			else {
				DateTime req_date1_copy=new DateTime(req_date1);
				req_date1_copy.setPrecision(
					DateTime.PRECISION_DAY);
				req_date1_copy.setDay(1);
				q.addWhereClause("res_meas.date_time >=" 
					+ DMIUtil.formatDateTime(this,
					req_date1_copy));
			}
		}
		if (req_date2 != null) {
			if (req_date2.getPrecision() ==DateTime.PRECISION_DAY) {
				q.addWhereClause("res_meas.date_time <=" 
					+ DMIUtil.formatDateTime(this,
					req_date2));
			}
			else {
				DateTime req_date2_copy=new DateTime(req_date2);
				req_date2_copy.setPrecision( 
					DateTime.PRECISION_DAY);
				req_date2_copy.setDay(
					TimeUtil.numDaysInMonth(
					req_date2_copy));
				q.addWhereClause("res_meas.date_time <=" 
					+ DMIUtil.formatDateTime(this,
					req_date2_copy));
			}
		}
		q.addOrderByClause("res_meas.date_time");
		ResultSet rs = dmiSelect(q);
		Vector v = toResMeasList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the res_meas table for all data with the matching structure_num.  <p>
This method is used by:<ul>
<li>HydroBase_GUI_ReservoirMeasurement.submitReservoirMeasurementQuery()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_Res_Meas</li></ul>
@return a Vector of HydroBase_ResMeas objects.
@throws Exception if an error occurs.
*/
public Vector readResMeasListForStructure_num(int structure_num)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = new String[3];
		triplet[0] = "structure_num";
		triplet[1] = "EQ";
		triplet[2] = "" + structure_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
			
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Res_Meas"), 21, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toResMeasList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_RES_MEAS);
		q.addWhereClause("res_meas.structure_num = " + structure_num);
		q.addOrderByClause("res_meas.date_time");
		ResultSet rs = dmiSelect(q);
		Vector v = toResMeasList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the rolodex table for all data matching the where clause.<p>
This method is used by:<ul>
<li>HydroBase_Report_StructureSummary.submitRolodexQuery()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_Rolodex_Sel_By_Rolodex_num</li></ul>
@param rolodex_num the rolodex_num for which to return a record in the rolodex
table.
@return a HydroBase_Rolodex object.
@throws Exception if an error occurs.
*/
public HydroBase_Rolodex readRolodexForRolodex_num(int rolodex_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_ROLODEX_FOR_ROLODEX_NUM);
	q.addWhereClause("rolodex.rolodex_num = " + rolodex_num);
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toRolodexSPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toRolodexList(rs);
		closeResultSet(rs);
	}
	if (v.size() > 0) {
		return (HydroBase_Rolodex)v.elementAt(0);
	}
	else {
		return null;
	}
}

/**
Read the rolodex table for all data with the matching rolodex_num and for which
the data in the person_details table has the matching structure_num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_OwnerContact.submitAndDisplayRolodexQuery()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_Rolodex_Sel_By_Structure_num</li></ul>
@param rolodex_num the rolodex_num for which to return a record in the rolodex
table.
@return a HydroBase_Rolodex object.
@throws Exception if an error occurs.
*/
public HydroBase_Rolodex readRolodexForRolodex_numStructure_num(int rolodex_num,
int structure_num)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_ROLODEX_FOR_STRUCTURE_NUM);
	if (!__useSP) {
		// REVISIT (JTS - 2005-02-25)
		// when rolodex_num is removed from this method, this won't
		// be necessary
		q.addWhereClause("rolodex.rolodex_num = " + rolodex_num);
	}
	q.addWhereClause("person_details.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toRolodexSPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toRolodexList(rs);
		closeResultSet(rs);
	}

	if (v.size() > 0) {
		return (HydroBase_Rolodex)v.elementAt(0);
	}
	else {
		return null;
	}
}

/**
Read the rt_meas table for all data matching the given criteria.<p>
This method is called by:<ul>
<li>readTimeSeries()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_RealTime_Telemetry</li></ul>
@param meas_num the meas_type.meas_num key for this time series.
@param req_date1 If not null, specify the start date for the query.
@param req_date2 If not null, specify the end date for the query.
@param missingAmt if true, then records with missing amt values will be 
returned.  If false, they won't be.
@return a Vector of HydroBase_RTMeas objects.
@throws Exception if an error occurs.
*/
public Vector readRTMeasList(int meas_num, DateTime req_date1,
DateTime req_date2, boolean useFlaggedData, boolean missingAmt)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = new String[3];
		triplet[0] = "meas_num";
		triplet[1] = "EQ";
		triplet[2] = "" + meas_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
			
		if (req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "date_time";
			triplet[1] = "GE";
			String s = DMIUtil.formatDateTime(this, req_date1);
			triplet[2] = s;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
			
		if (req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "date_time";
			triplet[1] = "LE";
			String s = DMIUtil.formatDateTime(this, req_date2);
			triplet[2] = s;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (!missingAmt) {
			triplet = new String[3];
			triplet[0] = "amt";
			triplet[1] = "NE";
			triplet[2] = "" + DMIUtil.MISSING_DOUBLE;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (!useFlaggedData) {
			triplet = new String[3];
			triplet[0] = "flag";
			triplet[1] = "NL";
			triplet[2] = "1";
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
		
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_RealTime_Telemetry"), 
			25, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toRTMeasList(rs);
		closeResultSet(rs, null);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_RT_MEAS);
		q.addWhereClause("meas_num=" + meas_num);
		if (req_date1 != null) {
			q.addWhereClause("date_time >=" +
				DMIUtil.formatDateTime(this,req_date1));
		}
		if (req_date2 != null) {
			q.addWhereClause("date_time <=" +
				DMIUtil.formatDateTime(this,req_date2));
		}
		if (!missingAmt) {
			q.addWhereClause("amt <> " + DMIUtil.MISSING_DOUBLE);
		}
		if (!useFlaggedData) {
			q.addWhereClause("(rt_meas.flag is null "
				+ "OR rt_meas.flag = ' ')");
		}
		q.addOrderByClause("date_time");
		ResultSet rs = dmiSelect(q);
		Vector v = toRTMeasList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the snow_crse table for the requested time series - only actual
observations are read, not "EST" or values with no day specified.
This is called by:<ul>
<li>readTimeSeries()</li>
</ul>
<p><b>Stored Procedures</b><p>
<li>vw_CDSS_SnowCrse</li></ul>
@return a Vector of HydroBase_SnowCrse objects.
@param meas_num the meas_type.meas_num key for this time series.
@param req_date1 If not null, specify the start date for the query.
@param req_date2 If not null, specify the end date for the query.
@throws Exception if an error occurs. 
*/
public Vector readSnowCrseList(int meas_num, DateTime req_date1,
DateTime req_date2) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		String[] triplet = new String[3];
		triplet[0] = "meas_num";
		triplet[1] = "EQ";
		triplet[2] = "" + meas_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		triplet = new String[3];
		triplet[0] = "cal_mon_num";
		triplet[1] = "NN";
		triplet[2] = "1";
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		if (req_date1 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date2 != null) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "LE";
			triplet[2] = "" + (req_date2.getYear() + 1);
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_SnowCrse"), 22, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toSnowCrseSPList(rs);
		closeResultSet(rs, null);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_SNOW_CRSE);
		q.addWhereClause("meas_num=" + meas_num);
		q.addWhereClause("cal_mon_num is not null");
		if (req_date1 != null) {
			q.addWhereClause("cal_year >=" + req_date1.getYear());
		}
		if (req_date2 != null) {
			q.addWhereClause("cal_year <=" + req_date2.getYear());
		}
		q.addOrderByClause("snow_crse.cal_year");
		q.addOrderByClause("snow_crse.cal_mon_num");
		ResultSet rs = dmiSelect(q);
		Vector v = toSnowCrseList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the station table for a single station matching the station_id.<p>
This is called by:<ul>
<li>HydroBase_GUI_WISDiagram.lookupLocation()</li>
<li>HydroBase_NodeNetwork</li>
</ul>
<p><b>Stored Procedure</b><p>
<b>THIS METHOD USES NO STORED PROCEDURES</b>.  This method is only used
with SQL code.  Use readStationViewForStation_id() for SP code.
@param station_id HydroBase station.station_id value.
@return a Single HydroBase_Station object.
@throws Exception if an error occurs.
*/
public HydroBase_Station readStationForStation_id( String station_id ) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_STATION_FOR_STATION_ID);
	q.addWhereClause("station.station_id = '" + station_id + "'");
	ResultSet rs = dmiSelect(q);
	Vector v = toStationList(rs);
	closeResultSet(rs);
	if ((v == null) || (v.size() == 0)) {
		return null;
	}
	else {
		return (HydroBase_Station)v.elementAt(0);
	}
}

/**
Read the station table for all data that have the ids in the provided id list.
This method is used by:<ul>
<li>HydroBase_NodeNetwork.setNodeDescriptions()</li>
</ul>
@param ids a vector of station_id values.
@return a Vector of HydroBase_Station objects.
@throws Exception if an error occurs.
*/
public Vector readStationListForStation_idList(Vector ids) 
throws Exception {
	String station = "";
	int size = ids.size();
	Vector results = new Vector();
	Object o = null;
	for (int i = 0; i < size; i++) {
		station = (String)ids.elementAt(0);
		if (__useSP) {
			o = readStationViewForStation_id(station);
			if (o != null) {
				results.add(o);
			}
		}
		else {
			o = readStationForStation_id(station);
			if (o != null) {
				results.add(o);
			}
		}
	}
	return results;
}

/**
Read a Vector of HydroBase_CUClimWts objects given a county and hydrounit (HUC)
pattern.  The output is ordered by county, hydrounit.<p>
This is used by StateDMI.
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_StationCUClimWts</li></ul>
@param county the county to use for matching cu_clim_wts.county (can be a
wildcard pattern).
@param hydrounit the hydrologic unit to use for matching cu_clim_wts.hydrounit
(can be a wildcard pattern).
@return a Vector of HydroBase_CUClimWts objects.
@throws Exception if an error occurs.
*/
public Vector readStationGeolocCUClimWtsListForCountyAndHydrounit(
String county, String hydrounit) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		String[] triplet = null;
		if (county != null && county.length() > 0) {
			triplet = new String[3];
			triplet[0] = "county";
			triplet[1] = "MA";
			triplet[2] = county;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (hydrounit != null && hydrounit.length() > 0) {
			triplet = new String[3];
			triplet[0] = "hydrounit";
			triplet[1] = "MA";
			triplet[2] = hydrounit;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_StationCUClimWts"), 23, 
			null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toStationGeolocCUClimWtsSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_STATION_GEOLOC_CU_CLIM_WTS);
	
		String where = "";
		if ((county != null) && !county.equals("*")) {
			where = "cu_clim_wts.county like '" + county + "'";
			q.addWhereClause(where.replace('*','%'));
		}
		if ((hydrounit != null) && !hydrounit.equals("*")) {
			where = "cu_clim_wts.hydrounit like '" + hydrounit 
				+ "'";
			q.addWhereClause(where.replace('*','%'));
		}
		q.addOrderByClause("cu_clim_wts.county");
		q.addOrderByClause("cu_clim_wts.hydrounit");
		ResultSet rs = dmiSelect(q);
		Vector v = toStationGeolocCUClimWtsList(rs);
		closeResultSet(rs);
		return v;
	}
}
	
/**
Read HydroBase_StationGeoloc objects for a single station matching the
station_id.<p>
This is called by:<ul>
<li>readTimeSeries()</li>
</ul>
<p><b>Stored Procedure</b><p>
<b>THIS METHOD HAS NO STORED PROCEDURES</b>.  This method is used with code
that does SQL.  SP code uses readStationViewForStation_id().
@param station_id HydroBase station.station_id value.
@return a Single HydroBase_StationGeoloc object.
@throws Exception if an error occurs.
@deprecated readStationViewForStation_id should be used instead.
*/
public HydroBase_StationGeoloc readStationGeolocForStation_id(String station_id)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_STATION_GEOLOC_FOR_STATION_ID);
	q.addWhereClause("station.station_id = '" + station_id + "'");
	ResultSet rs = dmiSelect(q);
	Vector v = toStationGeolocList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	if ((v == null) || (v.size() == 0)) {
		return null;
	}
	else {
		return (HydroBase_StationGeoloc)v.elementAt(0);
	}
}

/**
Read the station, geoloc and meas_type tables for a record that has the given
meas_type.<p>
This is used by TSTool and HydroBase_Util.
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_StationMeasType</li></ul>
@param panel an InputFilter_JPanel containing what to limit the query by.  
Specify null if no panel contains query limits.
@param districtWhere the value returned by getWaterDistrictWhereClause().
@param mapQueryLimits the GRLimits defining the geographical area for which
to query.
@param meas_type the meas_type for which to return the record (specify null to
read all).
@param time_step the time_step for which to return the record (specify null to
read all).
@param vax_field the vax_field for which to return the record (specify null to
read all).
@param data_source the data_source for which to return the record (specify null
to read all).
@param transmit the transmit value to read for (specify null to read all).
@return a Vector of HydroBase_StationGeolocMeasType or HydroBase_StationView
objects.
@throws Exception if an error occurs.
*/
public Vector readStationGeolocMeasTypeList(InputFilter_JPanel panel, 
String[] districtWhere, GRLimits mapQueryLimits, String meas_type, 
String time_step, String vax_field, String data_source, String transmit,
boolean meas_typeContains)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			panel, districtWhere);

		String[] triplet = null;
		if (meas_type != null && meas_type.length() > 0) {
			triplet = new String[3];
			triplet[0] = "meas_type";
			if (meas_typeContains) {
				triplet[1] = "CN";
			}
			else {
				triplet[1] = "MA";
			}
			triplet[2] = meas_type;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (time_step != null && time_step.length() > 0) {
			triplet = new String[3];
			triplet[0] = "time_step";
			triplet[1] = "MA";
			triplet[2] = time_step;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (vax_field != null && vax_field.length() > 0) {
			triplet = new String[3];
			triplet[0] = "vax_field";
			triplet[1] = "MA";
			triplet[2] = vax_field;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (data_source != null && data_source.length() > 0) {
			triplet = new String[3];
			triplet[0] = "data_source";
			triplet[1] = "MA";
			triplet[2] = data_source;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (transmit != null && transmit.length() > 0) {
			triplet = new String[3];
			triplet[0] = "transmit";
			triplet[1] = "MA";
			triplet[2] = transmit;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_StationMeasType"), 24, 
			mapQueryLimits);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toStationMeasTypeSPList(rs, false);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_STATION_MEAS_TYPE_VIEW);
		if (districtWhere != null) {
			q.addWhereClause(districtWhere[0]);
		}
		if (meas_type != null && meas_type.length() > 0) {
			if (!meas_typeContains) {
				q.addWhereClause("meas_type.meas_type = '" 
					+ meas_type + "'");
			}
			else {
				q.addWhereClause("meas_type.meas_type like '%" 
					+ meas_type + "%'");
			}
		}
		if (time_step != null && time_step.length() > 0) {
			q.addWhereClause("meas_type.time_step = '" + time_step 
				+ "'");
		}
		if (vax_field != null && vax_field.length() > 0) {
			q.addWhereClause("meas_type.vax_field = '" + vax_field 
				+ "'");
		}
		if (data_source != null && data_source.length() > 0) {
			q.addWhereClause("meas_type.data_source = '" 
				+ data_source + "'");
		}

		if (transmit != null && transmit.length() > 0) {
			q.addWhereClause("meas_type.transmit = '"
				+ transmit + "'");
		}

//		Vector orderBys 
//			= HydroBase_GUI_Util.getOrderBysFromInputFilter_JPanel(
//			panel, false);
//		q.addOrderByClauses(orderBys);

		if (panel != null) {
			Vector where_clauses 
				= DMIUtil.getWhereClausesFromInputFilter(
					this, panel);		
			// Add additional where clauses...
			if (where_clauses == null) {
				where_clauses = new Vector();
			}
			if (districtWhere != null) {
				where_clauses.add(districtWhere[0]);
			}
			for (int i = 0; i < where_clauses.size(); i++) {
				q.addWhereClause(convertCounty(
					(String)where_clauses.elementAt(i)));
			}
		}

		q.addOrderByClause("geoloc.wd");
		q.addOrderByClause("geoloc.geoloc_num");
		q.addOrderByClause("station.station_name");
		q.addOrderByClause("meas_type.meas_num");
		q.addOrderByClause("meas_type.meas_type");
//		q.addOrderByClause("station.station_id");

		ResultSet rs = dmiSelect(q);
		Vector v = toStationMeasTypeSPList(rs, false);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the station, geoloc and meas_type tables for data.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WISBuilder</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_StationMeasType</li></ul>
@return a Vector of HydroBase_StationGeolocMeasType objects.
@param wd the wd for which to query.  
@param measType used to specify a specific meas type to query for.  Can be null.
@param timeStep used to specify a specific time step to query for.  Can be null.
@param vaxField used to specify a specific vax field to query for.  Can be null.
@param data_source used the specify a specific data source to query for.  Can
be null.
@param distinct if true, only distinct stations will be selected
@throws Exception if an error occurs.
@deprecated (JTS - 2006-05-25) I don't believe this method is used anymore.
If anything compiles and sees this deprecation, mark this method as used.
*/
public Vector readStationGeolocMeasTypeListForWD(int wd, String meas_type, 
String time_step, String vax_field, String data_source, boolean distinct) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		
		String[] triplet = null;

		triplet = new String[3];
		triplet[0] = "wd";
		triplet[1] = "EQ";
		triplet[2] = "" + wd;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
		
		if (meas_type != null && meas_type.length() > 0) {
			triplet = new String[3];
			triplet[0] = "meas_type";
			triplet[1] = "MA";
			triplet[2] = meas_type;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
		else {
			// done to simulate this where clause:
			// 	(meas_type.meas_type Like 'RT%' 
			//	OR meas_type.meas_type Like 'Streamflow%'
			triplet = new String[3];
			triplet[0] = "loc_type";
			triplet[1] = "MA";
			triplet[2] = "QS";
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (time_step != null && time_step.length() > 0) {
			triplet = new String[3];
			triplet[0] = "time_step";
			triplet[1] = "MA";
			triplet[2] = time_step;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (vax_field != null && vax_field.length() > 0) {
			triplet = new String[3];
			triplet[0] = "vax_field";
			triplet[1] = "MA";
			triplet[2] = vax_field;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
		
		if (data_source != null && data_source.length() > 0) {
			triplet = new String[3];
			triplet[0] = "data_source";
			triplet[1] = "MA";
			triplet[2] = data_source;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
			
		String viewName = "vw_CDSS_StationMeasType";
		int orderNumber = 24;

		if (distinct) {
			viewName = "vw_CDSS_StationMeasType_Distinct";
			orderNumber = 71;
		}
			
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber(viewName), orderNumber, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toStationMeasTypeSPList(rs, distinct);
		closeResultSet(rs, __lastStatement);
		return v;	
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		if (distinct) {
			buildSQL(q, __S_STATION_MEAS_TYPE_DISTINCT_VIEW);
			q.selectDistinct(true);
		}
		else {
			buildSQL(q, __S_STATION_MEAS_TYPE_VIEW);
		}

		q.addWhereClause("geoloc.wd = " + wd);

		if (meas_type != null && meas_type.length() > 0) {
			q.addWhereClause("meas_type.meas_type = '" + meas_type 
				+ "'");
		}	
		else {
			q.addWhereClause("geoloc.wd = " + wd);
			q.addWhereClause("(meas_type.meas_type Like 'RT%' OR "
				+ "meas_type.meas_type Like 'Streamflow%')");
		}
		
		if (time_step != null && time_step.length() > 0) {
			q.addWhereClause("meas_type.time_step = '" + time_step 
				+ "'");
		}
		if (vax_field != null && !vax_field.equals("")) {
			q.addWhereClause("meas_type.vax_field = '" + vax_field 
				+ "'");
		}
		if (data_source != null && data_source.length() > 0) {
			q.addWhereClause("meas_type.data_source = '" 
				+ data_source + "'");
		}

		q.addOrderByClause("geoloc.wd");
		if (!distinct) {
			q.addOrderByClause("station.geoloc_num");
		}
		q.addOrderByClause("station.station_name");
		if (!distinct) {
			q.addOrderByClause("meas_type.meas_num");
		}
		q.addOrderByClause("meas_type.meas_type");
		
		ResultSet rs = dmiSelect(q);
		Vector v = toStationMeasTypeSPList(rs, distinct);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the station table for a single station matching the station_id.<p>
This is called by:<ul>
<li>HydroBase_GUI_WISDiagram.lookupLocation()</li>
<li>HydroBase_NodeNetwork</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_Station</li></ul>
@param station_id HydroBase station.station_id value.
@return a Single HydroBase_StationView object.
@throws Exception if an error occurs.
*/
public HydroBase_StationView readStationViewForStation_id(String station_id) 
throws Exception {
	Vector v = null;
	
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
	
		String[] triplet = null;
		if (station_id != null && station_id.length() > 0) {
			triplet = new String[3];
			triplet[0] = "station_id";
			triplet[1] = "MA";
			triplet[2] = station_id;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
	
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Station"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		v = toStationSPList(rs);
		closeResultSet(rs, __lastStatement);
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_STATION_VIEW);
		if (station_id != null && station_id.length() > 0) {
			q.addWhereClause("station.station_id = '"
				+ station_id + "'");
		}		
		ResultSet rs = dmiSelect(q);
		v = toStationSPList(rs);
		closeResultSet(rs);
	}

	if (v == null || v.size() == 0) {
		return null;
	}
	else {
		return (HydroBase_StationView)v.elementAt(0);
	}
}

/**
Reads all station views with the given WD.
@param wd the wd to match.
@return a Vector HydroBase_StationView objects.
@throws Exception if an error occurs.
*/
public Vector readStationViewListForWD(int wd) 
throws Exception {
	Vector v = null;
	
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
	
		String[] triplet = new String[3];
		triplet[0] = "wd";
		triplet[1] = "eq";
		triplet[2] = "" + wd;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
	
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Station"), 87, null);
		ResultSet rs = runSPFlex(parameters);
		v = toStationSPList(rs);
		closeResultSet(rs, __lastStatement);
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_STATION_VIEW);
		q.addWhereClause("geoloc.wd = " + wd);
		ResultSet rs = dmiSelect(q);
		v = toStationSPList(rs);
		closeResultSet(rs);
	}
	return v;
}

/**
Read the stream table for the stream that matches the given stream_num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_SetCall.structureWindowClose()</li>
<li>HydroBase_GUI_WISCellAttributes.setupGUI()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_Stream_Sel_By_Stream_num</li>
</ul>
@param stream_num the stream_num to match.
@return an HydroBase_Stream objects or null if none couldbe found.
@throws Exception if an error occurs.
*/
public HydroBase_Stream readStreamForStream_num(int stream_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_STREAM_FOR_STREAM_NUM);
	q.addWhereClause("stream.stream_num = " + stream_num);
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toStreamSPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toStreamList(rs);
		closeResultSet(rs);
	}
	if (v == null || v.size() == 0) {
		return null;
	}
	return (HydroBase_Stream)v.elementAt(0);
}

/**
Read the stream table for the streams that match the given wd and 
str_trib_to.  If str_trib_to is missing (-999), it will not be used in the
where clause<p>
This method is used by:<ul>
<li>HydroBase_GUI_NewWIS.generateStreamList()</li>
<li>HydroBase_GUI_WISBuilder.archiveData()</li>
<li>HydroBase_GUI_WISBuilder.displayStreamList()</li>
</ul>
<p><b>Stored Procedures</b><p>
The stored procedures that correspond to these query are:<ul>
<li>usp_CDSS_Stream_Sel_By_WD</li>
<li>usp_CDSS_Stream_Sel_By_WD_Str_trib_to</li>
</ul>
@param wd the wd to match
@param str_trib_to the str_trib_to to match.  If missing, will be ignored.
@return an HydroBase_Stream objects or null if none couldbe found.
@throws Exception if an error occurs.
*/
public Vector readStreamListForWDStr_trib_to(int wd, int str_trib_to) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	if (!DMIUtil.isMissing(str_trib_to)) {
		buildSQL(q, __S_STREAM_FOR_WD_STR_TRIB_TO);
		q.addWhereClause("stream.str_trib_to = " + str_trib_to);
	}
	else {
		buildSQL(q, __S_STREAM_FOR_WD);
	}
	q.addWhereClause("legacy_stream.wd = " + wd);
	q.addOrderByClause("stream.stream_name");
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toStreamSPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toStreamList(rs);
		closeResultSet(rs);
	}
	return v;
}

/**
Read the str_type table for all data.  Used in generating water rights reports.
<p>The SQL that is executed:<pre>
This method is used by:<ul>
<li>HydroBaseDMI.readGlobalData()</li>
<li>HydroBase_Report_NetAmounts.createNetTabulationReport()</li>
<li>HydroBase_Report_Transaction.HydroBase_Report_Transaction()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_refStructureType_Sel</li>
</ul>
@return a Vector of HydroBase_StrType objects.
@throws Exception if an error occurs.
*/
public Vector readStrTypeList() 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_STR_TYPE);
	if (getDatabaseVersion() > VERSION_20040701) {
		q.addOrderByClause("ref_Structure_Type.str_type");
	}
	else {
		q.addOrderByClause("str_type.str_type");
	}
	ResultSet rs = dmiSelect(q);
	Vector v = toStrTypeList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Reads the struct_meas_type table for all distinct struct meas types.<p>
This method is called by:<p>
<ul><li>readGlobalData()</li></ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_StructMeasType_Sel_Distinct</li> </ul>
@return a Vector of HydroBase_StructMeasTypes
@throws Exception if an error occurs.
*/
public Vector readStructMeasTypeDistinctList()
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_STRUCT_MEAS_TYPE_DISTINCT_2);
	ResultSet rs = dmiSelect(q);
	Vector v = toStructMeasTypeDistinctList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the struct_meas_type table and the wd, id from the structure table for the
records that match the specified structure_num, meas_type, identifier,
time_step, and data_source and join with data in the structure table, ordering
by struct_meas_type.identifier.<p>
This method is used by:<ul>
<li>readTimeSeries()</li>
</ul>
<p><b>Stored Procedures</b><p>

@param structure_num the structure_num for which to read data.
@param meas_type the meas_type for which to read data.  Can be null or blank.
@param identifier the struct_meas_type.identifier for which to read data.
Can be null or blank.  This is the SFUT code that indicates water class.  As of
version 20061003, the SFUT also contains a G: at the end and the F: is a 7-digit
structure identifier.  This method handles backward-compatibility by manipulating
the identifier string, as needed.
@param time_step the struct_meas_type.time_step for which to read data.  Can be
null or blank.
@return a Vector of HydroBase_StructMeasType objects.
*/
public Vector readStructMeasTypeListForStructure_num(int structure_num, 
String meas_type, String identifier, String time_step, String data_source) 
throws Exception {
	return readStructMeasTypeListForWDIDStructure_num ( -1, -1, structure_num,
			meas_type, identifier, time_step, data_source );
}

/**
Read the struct_meas_type table and the wd, id from the structure table for the
records that match the specified structure_num, meas_type, identifier,
time_step, and data_source and join with data in the structure table, ordering
by struct_meas_type.identifier.<p>
This method is used by:<ul>
<li>readTimeSeries()</li>
</ul>
<p><b>Stored Procedures</b><p>

@param wd Water district, only used when adjusting the "identifier" because of
database version backward-compatibiliy issues.
@param id Structure identifier, only used when adjusting the "identifier" because of
database version backward-compatibiliy issues.
@param structure_num the structure_num for which to read data.
@param meas_type the meas_type for which to read data.  Can be null or blank.
@param identifier the struct_meas_type.identifier for which to read data.
Can be null or blank.  This is the SFUT code that indicates water class.  As of
version 20061003, the SFUT also contains a G: at the end and the F: is a 7-digit
structure identifier.  This method handles backward-compatibility by manipulating
the identifier string, as needed.
@param time_step the struct_meas_type.time_step for which to read data.  Can be
null or blank.
@return a Vector of HydroBase_StructMeasType objects.
*/
private Vector readStructMeasTypeListForWDIDStructure_num(int wd, int id,
int structure_num, 
String meas_type, String identifier, String time_step, String data_source) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = new String[3];
		triplet[0] = "structure_num";
		triplet[1] = "EQ";
		triplet[2] = "" + structure_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		if (meas_type != null && meas_type.length() > 0) {
			triplet[0] = "meas_type";
			triplet[1] = "MA";
			triplet[2] = meas_type;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (identifier != null && identifier.length() > 0) {
			identifier = HydroBase_Util.adjustSFUTForHydroBaseVersion(this,wd,id,identifier);
			triplet[0] = "identifier";
			triplet[1] = "MA";
			triplet[2] = identifier;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (time_step != null && time_step.length() > 0) {
			triplet[0] = "time_step";
			triplet[1] = "MA";
			triplet[2] = time_step;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (data_source != null && data_source.length() > 0) {
			triplet[0] = "data_source";
			triplet[1] = "MA";
			triplet[2] = data_source;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
			
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_StructureStructMeasType"), 
			27, null);
		ResultSet rs = runSPFlex(parameters);
		// use the toStructureStructMeas...
		Vector v = toStructMeasTypeSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;	
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_STRUCT_MEAS_TYPE_VIEW);
		q.addWhereClause("structure.structure_num = " + structure_num);
		if ((meas_type != null) && (meas_type.length() > 0)) {
			q.addWhereClause("struct_meas_type.meas_type = '" +
			meas_type + "'");
		}
		if ((identifier != null) && (identifier.length() > 0)) {
			q.addWhereClause("struct_meas_type.identifier = '" +
			identifier + "'");
		}
		if ((time_step != null) && (time_step.length() > 0)) {
			q.addWhereClause("struct_meas_type.time_step = '" +
			time_step + "'");
		}
		if ((data_source != null) && (data_source.length() > 0)) {
			q.addWhereClause("struct_meas_type.data_source = '" +
			data_source + "'");
		}
		q.addOrderByClause("struct_meas_type.meas_type");
		ResultSet rs = dmiSelect(q);
		Vector v = toStructMeasTypeSPList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the struct_meas_type table for all data and join with data in the structure
table, ordering by struct_meas_type.identifier..<p>
If distinct is true, the SQL that is executed:<pre>
This method is used by:<ul>
<li>HydroBase_GUI_ReservoirData</li>
<li>HydroBase_GUI_StructureDetail</li>
<li>HydroBase_Report_StructureSummary</li>
</ul>
<p><b>Stored Procedure</b><p>
The following views are used by this method:<p><ul>
<li>vw_CDSS_StructureStructMeasType</li></ul>
@param distinct if true, this will be a distinct query.  Ignored for
stored procedures.
@return a Vector of HydroBase_StructMeasType objects.
*/
public Vector readStructMeasTypeListForStructure_num(int structure_num,
boolean distinct) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = new String[3];
		triplet[0] = "structure_num";
		triplet[1] = "EQ";
		triplet[2] = "" + structure_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
			
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_StructureStructMeasType"), 
			27, null);
		ResultSet rs = runSPFlex(parameters);
		// use the toStructureStructMeas...
		Vector v = toStructMeasTypeSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;	
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		if (distinct) {
			buildSQL(q, __S_STRUCT_MEAS_TYPE_VIEW);
			q.selectDistinct(true);
		} 
		else {
			buildSQL(q, __S_STRUCT_MEAS_TYPE_VIEW);
		}
		q.addWhereClause("structure.structure_num = " + structure_num);
		q.addOrderByClause("struct_meas_type.identifier");
		ResultSet rs = dmiSelect(q);
		Vector v = toStructMeasTypeSPList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the struct_meas_type table for the records that match the specified 
structure_num and meas_type and join with data in the structure
table, ordering by struct_meas_type.identifier.<p>
This method is used by:<ul>
<li>HydroBase_GUI_ReservoirData.submitAndDisplayReservoirQuery()</li>
<li>HydroBase_GUI_StructureDetail.getAllMeasurementTypes()</li>
</ul>
<p><b>Stored Procedure</b><p>
The following views are used by this method:<p><ul>
<li>vw_CDSS_StructureStructMeasType</li></ul>
@param structure_num the structure_num for which to read data
@param meas_type the meas_type for which to read data.  Cannot be null.
@return a Vector of HydroBase_StructMeasType objects.
*/
public Vector readStructMeasTypeListForStructure_numMeas_type(int structure_num,
String meas_type) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = new String[3];
		triplet[0] = "structure_num";
		triplet[1] = "EQ";
		triplet[2] = "" + structure_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		triplet = new String[3];
		triplet[0] = "meas_type";
		triplet[1] = "MA";
		triplet[2] = meas_type;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
			
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_StructureStructMeasType"), 
			27, null);
		ResultSet rs = runSPFlex(parameters);
		// use the toStructureStructMeas...
		Vector v = toStructMeasTypeSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;	

	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_STRUCT_MEAS_TYPE_VIEW);
		q.addWhereClause("structure.structure_num = " + structure_num);
		q.addWhereClause("struct_meas_type.meas_type = '" 
			+ meas_type + "'");
		q.addOrderByClause("struct_meas_type.identifier");
		ResultSet rs = dmiSelect(q);
		Vector v = toStructMeasTypeSPList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the structure_aka table for all data and join with data in the structure
table.<p>
This method is used by:<ul>
<li>HydroBase_GUI_StructureMoreInfo</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_StructureAKASel_By_Structure_num</li>
</ul>
@return a Vector of HydroBase_StructureAKA objects.
@throws Exception if an error occurs.
*/
public Vector readStructureAKAListForStructure_num(int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_STRUCTURE_AKA);
	q.addWhereClause("structure.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toStructureAKASPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toStructureAKAList(rs);
		closeResultSet(rs);
	}
	return v;
}

/**
Read the a single HydroBase_StructureGeoloc.  This method calls the
readStructureGeolocListForWDIDList() method.
This method is called by readTimeSeries().
@param wd the water district to query for.
@param id the identifier query for.
@return a matching HydroBase_StructureGeoloc, or null if
no data are available.
@throws Exception if an error occurs.
*/
public HydroBase_StructureGeoloc readStructureGeolocForWDID(int wd, int id) 
throws Exception {
	Vector v = new Vector(1);
	// It is a little inefficient to form one string since the called method
	// will just split it out again, but do it this way for now.
	v.add(HydroBase_WaterDistrict.formWDID(wd,id));
	Vector v2 = readStructureGeolocListForWDIDList(v);
	if ((v2 == null) || (v2.size() == 0)) {
		return null;
	}
	// There should never be more than one entry...
	return (HydroBase_StructureGeoloc)v2.elementAt(0);
}

/**
Reads the database for the data necessary to fill the table in the 
Structure query GUI.  This method is called both for databases that use 
stored procedures and those that do not, and it handles calling SPFlex or
the readXXXList() method, as appropriate.
@param panel the panel of InputFilters that hold the query constraints.
@param districtWhere the value returned by getWaterDistrictWhereClause().
@param mapQueryLimits the GRLimits defining the geographical area for which
to query.
@return a Vector of HydroBase_StructureGeoloc or HydroBase_StructureView 
Objects (depending on whether SPFlex was called). 
@throws Exception if there is an error running the query.
*/
public Vector readStructureGeolocList(InputFilter_JPanel panel, 
String[] districtWhere, GRLimits mapQueryLimits)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			panel, districtWhere);
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Structure"), 73, 
			mapQueryLimits);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toStructureSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;	
	}
	else {
//		Vector orderBys 
//			= HydroBase_GUI_Util.getOrderBysFromInputFilter_JPanel(
//			panel, false);
		Vector wheres 
			= HydroBase_GUI_Util.getWhereClausesFromInputFilter(
			this, panel, HydroBase_GUI_Util._GEOLOC_TABLE_NAME,
			HydroBase_GUI_Util.STRUCTURE);
		if (districtWhere != null) {
			wheres.add(districtWhere[0]);
		}
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_STRUCTURE_VIEW);
		int size = 0;
		if (wheres != null) {
			size = wheres.size();
			for (int i = 0; i < size; i++) {
				q.addWhereClause((String)wheres.elementAt(i));
			}
		}
//		if (orderBys != null) {
//			size = orderBys.size();
//			for (int i = 0; i < size; i++) {
//				q.addOrderByClause(
//					(String)orderBys.elementAt(i));
//			}
//		}

		q.addOrderByClause("structure.str_name");
		q.addOrderByClause("structure.structure_num");
		q.addOrderByClause("structure.geoloc_num");
		ResultSet rs = dmiSelect(q);
		Vector v = toStructureSPList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the Structure-Geoloc data for a Vector of WDIDs
This is called by readStructureGeolocForWDID().
<p><b>Stored Procedures</b><p>
This method is not supported for non-stored procedure connections.
@param WDIDs the Vector of WDIDs to query for.
@return a Vector of objects of type HydroBase_StructureGeoloc, or null if
no data are available.  Note that if the database is using stored procedures,
these data should be sorted by WDID ascending.
@throws Exception if an error occurs.
*/
public Vector readStructureGeolocListForWDIDList(Vector WDIDs) 
throws Exception {
	String routine = "HydroBaseDMI.readStructureGeolocListForWDIDs";
	int size = 0;
	if (WDIDs != null) {
		size = WDIDs.size();
	}
	if (size == 0) {
		return null;
	}
	// If the database is Microsoft Access and the number of structures
	// is more than the maximum that can be processed in a select,
	// recursively call this method to select part of the list...
	int maxquery = 25;	// For Access only
	int count = 0;
	if (	getDatabaseEngine().equalsIgnoreCase("Access") &&
		(size > maxquery)) {
		Vector someWDIDs = new Vector();
		Vector v = new Vector();	// returned data
		Vector somev;
		int somesize;
		for ( int i = 1; i <= size; i++) {
			// Put together a short list (account for zero index)...
			someWDIDs.add(WDIDs.elementAt(i - 1));
			++count;
			if ((count == maxquery) || (i == size)) {
				// Time to do a new query...
				somev = readStructureGeolocListForWDIDList (
					someWDIDs);
				// Append the list to the main list to be
				// returned...
				somesize = 0;
				if (somev != null) {
					somesize = somev.size();
				}
				for ( int j = 0; j < somesize; j++) {
					v.add(somev.elementAt(j));
				}
				// Reset for the next query...
				someWDIDs.removeAllElements();
				count = 0;
			}
		}
		// Return the complete list...
		return v;
	}


	// If here, there is no restriction on the query size...
	
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL (q, __S_STRUCTURE_GEOLOC_LIST_FOR_WDID);
	StringBuffer where = new StringBuffer ("(");
	
	int [] wdid_parts = new int[2];
	String wdid = null;
	count = 0;
	for (int i = 0; i < size; i++) {
		wdid = (String)WDIDs.elementAt(i);

		try {
			wdid_parts = HydroBase_WaterDistrict.parseWDID(
				wdid,wdid_parts);
			if (count > 0) {
				where.append(" OR ");
			}
			where.append("(Structure.wd=" + wdid_parts[0]
				+ " AND " 
				+ "Structure.id=" + wdid_parts[1] 
				+ ")");
			++count;
		}
		catch ( Exception e) {
			Message.printWarning ( 2, routine,
			"WDID \"" + wdid + "\" not valid - ignoring.");
		}
	}
	
	where.append(")");
	q.addWhereClause(where.toString());
	q.addOrderByClause("structure.wd");
	q.addOrderByClause("structure.id");

	ResultSet rs = dmiSelect(q);
	Vector v = toStructureGeolocForWDIDList (rs);
	closeResultSet(rs);
	return v;
}

/**
Read the Structure-Geoloc data for a Vector of WDIDs
This is called by readStructureGeolocForWDID().
<p><b>Stored Procedures</b><p>
This method cals readStructureViewForWDID() and uses its SP.
@param WDIDs the Vector of WDIDs to query for.
@return a Vector of objects of type HydroBase_StructureGeoloc, or null if
no data are available.
@throws Exception if an error occurs.
*/
public Vector readStructureViewListForWDIDList(Vector WDIDs) 
throws Exception {
	String routine = "HydroBaseDMI.readStructureGeolocListForWDIDs";
	int size = 0;
	if (WDIDs != null) {
		size = WDIDs.size();
	}
	if (size == 0) {
		return null;
	}

	int [] wdid_parts = new int[2];
	String wdid = null;
	Vector results = new Vector();
	for (int i = 0; i < size; i++) {
		wdid = (String)WDIDs.elementAt(i);
		try {
			wdid_parts = HydroBase_WaterDistrict.parseWDID(
				wdid,wdid_parts);
			results.add(readStructureViewForWDID(wdid_parts[0],
				wdid_parts[1]));
		}
		catch ( Exception e) {
			Message.printWarning ( 2, routine,
			"WDID \"" + wdid + "\" not valid - ignoring.");
		}
	}
	return results;	
}

/**
Read the joined structure and irrig_summary tables for all data that match the
specified structure_num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_IrrigatedAcres.submitAndDisplayIrrigSummaryStructureQuery()
</li>
<li>HydroBase_GUI_IrrigatedAcresSummary.submitQuery()</li>
<li>HydroBase_Report_StructureSummary.submitIrrigatedAcresQuery()</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_Structure</li></ul>
@return a Vector of HydroBase_StructureIrrigSummary objects.
@throws Exception if an error occurs.
*/
public Vector readStructureIrrigSummaryListForStructure_num(int structure_num) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = new String[3];
		triplet[0] = "structure_num";
		triplet[1] = "EQ";
		triplet[2] = "" + structure_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
			
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Structure"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toStructureSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_STRUCTURE_VIEW);
		q.addWhereClause("structure.structure_num = " + structure_num);
		ResultSet rs = dmiSelect(q);
		Vector v = toStructureSPList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the joined structure and irrig_summary tables for all data that match the
specified WD and ID.<p>
This is called by:<ul>
<li>StateDMI</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses now views.  Use instead readStructureViewForWDID().
@return a Vector of HydroBase_StructureIrrigSummary objects.
@throws Exception if an error occurs.
@deprecated use readStructureViewForWDID().
*/
public HydroBase_StructureIrrigSummary readStructureIrrigSummaryForWDID(int wd, 
int id) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_STRUCTURE_IRRIG_SUMMARY_JOIN);
	q.addWhereClause("structure.wd = " + wd);
	q.addWhereClause("structure.id = " + id);
	ResultSet rs = dmiSelect(q);
	Vector v = toStructureIrrigSummaryList(rs);
	closeResultSet(rs);
	if ((v == null) || (v.size() == 0)) {
		return null;
	}
	return (HydroBase_StructureIrrigSummary)v.elementAt(0);
}

/**
Read the structure and irrig_summary_ts tables for all data with the matching
criteria.<p>
This is called by:<ul>
<li>readTimeSeries</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_StructureIrrigSummaryTS</li></ul>
@param panel the input filter panel to use for where clauses
@param orderby_clauses additional order by clauses to use for SQL queries.
@param structure_num the structure_num to query for.  If missing, will be
ignored.
@param wd the wd to query for.  If missing, will be ignored.
@param id the id to query for.  If missing, will be ignored.
@param str_name the structure name to query for.  If null, will be ignored.
@param land_use Land use to query for - can specify null or blank to ignore.
@param req_date1 First year to read - specify null to ignore.
@param req_date2 Last year to read - specify null to ignore.
@param distinct whether to do distinct queries.  Ignored for stored procedures.
@return a Vector of HydroBase_StructureView objects.
The objects are sorted by year, structure identifier (WDID), and 
land_use (crops).
@throws Exception if an error occurs
*/
public Vector readStructureIrrigSummaryTSList(InputFilter_JPanel panel,
Vector orderby_clauses, int structure_num, int wd, int id, String str_name,
String land_use, DateTime req_date1, DateTime req_date2, boolean distinct ) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			panel, null);
		String[] triplet = null;

		if (!DMIUtil.isMissing(structure_num)) {
			triplet = new String[3];
			triplet[0] = "structure_num";
			triplet[1] = "EQ";
			triplet[2] = "" + structure_num;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (!DMIUtil.isMissing(wd)) {
			triplet = new String[3];
			triplet[0] = "wd";
			triplet[1] = "EQ";
			triplet[2] = "" + wd;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
		
		if (!DMIUtil.isMissing(id)) {
			triplet = new String[3];
			triplet[0] = "id";
			triplet[1] = "EQ";
			triplet[2] = "" + id;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
			
		if (str_name != null && str_name.length() > 0) {
			triplet = new String[3];
			triplet[0] = "str_name";
			triplet[1] = "MA";
			triplet[2] = str_name;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (land_use != null && land_use.length() > 0) {
			triplet = new String[3];
			triplet[0] = "land_use";
			triplet[1] = "MA";
			triplet[2] = land_use;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date1 != null && !distinct) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "GE";
			triplet[2] = "" + req_date1.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date2 != null && !distinct) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "LE";
			triplet[2] = "" + req_date2.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
			
		int orderNumber = 48;
		String viewName = "vw_CDSS_StructureIrrigSummaryTS";
		if (distinct) {
			orderNumber = 47;
			viewName = 
			     "vw_CDSS_StructureIrrigSummaryTS_Distinct_LU";
		}
			
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber(viewName), orderNumber, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toStructureIrrigSummaryTSSPList(rs, distinct);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		if (distinct) {
			buildSQL(q,
				__S_STRUCTURE_IRRIG_SUMMARY_TS_DISTINCT_VIEW);
			q.selectDistinct(true);
		}
		else {
			buildSQL(q,
				__S_STRUCTURE_IRRIG_SUMMARY_TS_VIEW);
		}
	
		Vector where_clauses = null;
		if (panel != null) {
			where_clauses 
				= HydroBase_GUI_Util
				.getWhereClausesFromInputFilter(this, panel);
		}

		if (where_clauses != null) {
			q.addWhereClauses(where_clauses);
		}
//		if (orderby_clauses != null) {
//			q.addOrderByClauses(orderby_clauses);
//		}
//		else {
			// Default order...
			q.addOrderByClause("structure.wd");
			q.addOrderByClause("structure.id");
			q.addOrderByClause("irrig_summary_ts.land_use");
			if (!distinct) {
				q.addOrderByClause("irrig_summary_ts.cal_year");
			}
//		}
		if (!DMIUtil.isMissing(structure_num)) {
			q.addWhereClause("structure.structure_num = " 
				+ structure_num);
		}
		if (!DMIUtil.isMissing(wd)) {
			q.addWhereClause("structure.wd = " + wd);
		}
		if (!DMIUtil.isMissing(id)) {
			q.addWhereClause("structure.id = " + id);
		}
		if ((str_name != null) && (str_name.length() > 0)) {
			q.addWhereClause("structure.str_name = '" 
				+ str_name + "'");
		}
		if ((land_use != null) && (land_use.length() > 0)) {
			q.addWhereClause("irrig_summary_ts.land_use = '" 
				+ land_use+"'");
		}
		if (req_date1 != null && !distinct) {
			q.addWhereClause("irrig_summary_ts.cal_year >= " +
				req_date1.getYear());
			}
		if (req_date2 != null && !distinct) {
			q.addWhereClause("irrig_summary_ts.cal_year <= " + 
				req_date2.getYear());
		}
	
		ResultSet rs = dmiSelect(q);
		Vector v = toStructureIrrigSummaryTSSPList(rs, distinct);	
		closeResultSet(rs);
		return v;
	}
}

/**
Read the structure and irrig_summary_ts tables for all data with the matching
criteria.<p>
This is called by:<ul>
<li>readTimeSeries</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_Structure_Irrig_Summary_TS</li></ul>
@param landuse Land use to query for - can specify null or blank to ignore.
@param req_date1 First year to read - specify null to ignore.
@param req_date2 Last year to read - specify null to ignore.
@param distinct whether to do distinct queries.  Ignored for stored procedures.
@return a Vector of HydroBase_StructureView objects.
The objects are sorted by year, structure identifier (WDID), and 
landuse (crops).
@throws Exception if an error occurs
*/
public Vector readStructureIrrigSummaryTSList (InputFilter_JPanel panel,
Vector orderby_clauses, int structure_num, Vector wdids, String str_name,
String landuse, DateTime req_date1, DateTime req_date2, boolean distinct ) 
throws Exception {
	String routine = "readStructureIrrigSummaryTSList";
	int[] wdid_parts = null;
	int size = 0;
	int vsize = 0;
	String wdid = null;
	Vector v = null;
	Vector results = new Vector();
	
	if (wdids != null) {
		size = wdids.size();
		for (int i = 0; i < size; i++) {
			wdid = (String)wdids.elementAt(i);
			try {
				wdid_parts = HydroBase_WaterDistrict.parseWDID(
					wdid, wdid_parts);
			}
			catch (Exception e) {
				Message.printWarning(2, routine,
					"Invalid wdid: " + wdid);
				wdid_parts = null;
			}

			if (wdid_parts != null) {
				v = readStructureIrrigSummaryTSList(panel, 
					orderby_clauses, structure_num, 
					wdid_parts[0], wdid_parts[1],
					str_name, landuse, req_date1,
					req_date2, distinct);

				vsize = v.size();
				for (int j = 0; j < vsize; j++) {
					results.add(v.elementAt(j));
				}
			}
		}
		return results;
	}
	else {
		return readStructureIrrigSummaryTSList(panel, orderby_clauses,
			structure_num, -999, -999, str_name, landuse, req_date1,
			req_date2, distinct);
	}
}

/**
Read the structure table for the distinct wd values.<p>
This method is used by:<ul>
<li>HydroBaseDMI.readGlobalData()</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following stored procedures:<p><ul>
<li>usp_CDSS_Structure_Sel_WD_Distinct</li></ul>
@return a Vector of Integers, each of which is a unique wd.
@throws Exception if an error occurs.
*/
public Vector readStructureDistinctWDList() 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_STRUCTURE_DISTINCT_WD);
	q.selectDistinct(true);
	q.addOrderByClause("structure.wd");
	ResultSet rs = dmiSelect(q);
	Vector v = toStructureDistinctWDList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}

	HydroBase_Structure data = null;
	Vector wdv = new Vector(v.size());
	for (int i = 0; i < v.size(); i++) {
		data = (HydroBase_Structure)v.elementAt(i);
		wdv.add(new Integer(data.getWD()));
	}
	return wdv;
}

/**
Reads the structure table for all records that match the specified where clauses
and order by clauses.<p>
This method is used by:<ul>
<li>HydroBase_GUI_DailyWC.submitQuery()</li>
<li>HydroBase_GUI_IrrigatedAcres.submitAndDisplayStructureQuery()</li>
<li>HydroBase_GUI_IrrigatedAcresSummmay.displayResults()</li>
<li>HydroBase_GUI_MinimumFlowReach.submitAndDisplayMFReachQuery()</li>
<li>HydroBase_GUI_ReservoirMeasurement.submitStructureQuery()</li>
<li>HydroBase_GUI_Well.submitAndDisplayStructureQuery</li>
</ul>
<p><b>Stored Procedure</b><p>
<b>THIS METHOD USES NO STORED PROCEDURES</b>
@param structure_num the structure_num for which to return structure data.
@return the matching HydroBase_Structure record.
@throws Exception if an error occurs.
@deprecated use readStructureViewForStructure_num
*/
public HydroBase_Structure readStructureForStructure_num(int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_STRUCTURE_FOR_STRUCTURE_NUM);
	q.addWhereClause("structure.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = toStructureList(rs);	
	closeResultSet(rs);
	if (v == null || v.size() == 0) {
		return null;
	}
	return (HydroBase_Structure)v.elementAt(0);	
}

/**
Read the Structure data for a of WDID.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WIS.saveDiversionCoding()</li>
<li>HydroBase_GUI_WISDiagram.lookupLocation()</li>
</ul>
<p><b>Stored Procedure</b><p>
<b>THIS METHOD USES NO STORED PROCEDURES</b>
@param wd the wd to match with
@param id the id to match with
@return an object of type HydroBase_Structure or HydroBase_StructureView, 
or null if no matching records could be found.
@throws Exception if an error occurs.
@deprecated use readStructureViewForWDID
*/
public HydroBase_Structure readStructureForWDID(int wd, int id) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL (q, __S_STRUCTURE_LIST_FOR_WDID);
	q.addWhereClause("Structure.wd = " + wd);
	q.addWhereClause("Structure.id = " + id);
	ResultSet rs = dmiSelect(q);
	Vector v = toStructureList (rs);
	closeResultSet(rs);

	if (v == null || v.size() == 0) {
		return null;
	}
	return (HydroBase_Structure)v.elementAt(0);
}

/**
Reads the structuer table for all records that match the specified where clauses
and order by clauses.<p>
This method is used by:<ul>
<li>HydroBaseDMI.readWISStructures</li>
<li>HydroBase_GUI_Headgate.HydroBase_GUI_Headgate()</li>
</ul>
<p><b>Stored Procedures</b><p>
<b>THIS METHOD USES NO STORED PROCEDURES</b>
@param where a Vector of structure nums to query for (as strings).  Cannot 
be null.
@param order a Vector of order-by Strings to use in the query.  Can be null.
@return a Vector of matching HydroBase_Structure records, or 
HydroBase_StructureView records if stored procedures are being used.
@throws Exception if an error occurs.
*/
public Vector readStructureListForStructure_nums(Vector structureNums, 
Vector order) 
throws Exception {
	if (__useSP) {
		String num = null;
		int size = structureNums.size();
		Vector results = new Vector();
		for (int i = 0; i < size; i++) {
			num = (String)structureNums.elementAt(i);
			results.add(readStructureViewForStructure_num(
				StringUtil.atoi(num)));
		}
		return results;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_STRUCTURE);

		Vector wheres = new Vector();
		int size = structureNums.size();
		for (int i = 0; i < size; i++) {
			wheres.add("structure_num = " 
				+ structureNums.elementAt(i));
		}
                q.addWhereClause(DMIUtil.getOrClause(wheres));

		if (order != null) {
			size = order.size();
			for (int i = 0; i < size; i++) {
				q.addOrderByClause((String)order.elementAt(i));
			}
		}
		ResultSet rs = dmiSelect(q);
		Vector v = toStructureList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Reads the structure table for all records that match the specified where clauses
and order by clauses.<p>
This method is used by:<ul>
<li>HydroBase_GUI_DailyWC.submitQuery()</li>
<li>HydroBase_GUI_IrrigatedAcres.submitAndDisplayStructureQuery()</li>
<li>HydroBase_GUI_IrrigatedAcresSummmay.displayResults()</li>
<li>HydroBase_GUI_MinimumFlowReach.submitAndDisplayMFReachQuery()</li>
<li>HydroBase_GUI_ReservoirMeasurement.submitStructureQuery()</li>
<li>HydroBase_GUI_Well.submitAndDisplayStructureQuery</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_Structure</li></ul>
@param structure_num the structure_num for which to return structure data.
@return the matching HydroBase_Structure record.
@throws Exception if an error occurs.
*/
public HydroBase_StructureView readStructureViewForStructure_num(
int structure_num) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		String[] triplet = new String[3];
		triplet[0] = "structure_num";
		triplet[1] = "EQ";
		triplet[2] = "" + structure_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
			
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Structure"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toStructureSPList(rs);
		closeResultSet(rs, __lastStatement);
		if (v.size() > 0) {
			return (HydroBase_StructureView)v.elementAt(0);
		}
		else {
			return null;
		}
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL (q, __S_STRUCTURE_VIEW);
		q.addWhereClause("Structure.structure_num= " + structure_num);
		ResultSet rs = dmiSelect(q);
		Vector v = toStructureSPList(rs);
		closeResultSet(rs);
	
		if (v == null || v.size() == 0) {
			return null;
		}
		return (HydroBase_StructureView)v.elementAt(0);
	}
}

/**
Read the Structure data for a of WDID.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WIS.saveDiversionCoding()</li>
<li>HydroBase_GUI_WISDiagram.lookupLocation()</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_Structure</li></ul>
@param wd the wd to match with
@param id the id to match with
@return an object of type HydroBase_Structure or HydroBase_StructureView, 
or null if no matching records could be found.
@throws Exception if an error occurs.
*/
public HydroBase_StructureView readStructureViewForWDID(int wd, int id) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = new String[3];
		triplet[0] = "wd";
		triplet[1] = "EQ";
		triplet[2] = "" + wd;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
	
		triplet = new String[3];
		triplet[0] = "id";
		triplet[1] = "EQ";
		triplet[2] = "" + id;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
	
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Structure"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toStructureSPList(rs);
		closeResultSet(rs, __lastStatement);
		if (v.size() > 0) {
			return (HydroBase_StructureView)v.elementAt(0);
		}
		else {
			return null;
		}
	}
	else {
		if (getDatabaseEngine().equalsIgnoreCase("Access")) {
			return readStructureViewForWDIDForAccess(wd, id);
		}
	
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL (q, __S_STRUCTURE_VIEW);
		q.addWhereClause("Structure.wd = " + wd);
		q.addWhereClause("Structure.id = " + id);
		ResultSet rs = dmiSelect(q);
		Vector v = toStructureSPList(rs);
		closeResultSet(rs);
	
		if (v == null || v.size() == 0) {
			return null;
		}
		return (HydroBase_StructureView)v.elementAt(0);	
	}
}

/**
Read the Structure data for a Vector of WDIDs.<p>
This method is used by:<ul>
<li>HydroBase_Report_StructureSummary.createSummaryForWDID</li>
<li>HydroBase_NodeNetwork.setDescriptions</li>
</ul>
@param WDIDs the Vector of WDIDs to query for
@return a Vector of objects of type HydroBase_Structure
@throws Exception if an error occurs.
*/
public Vector readStructureListForWDIDs(Vector WDIDs) 
throws Exception {
	String routine = "HydroBaseDMI.readStructureListForWDIDs";

	Vector results = new Vector();
	
	int size = WDIDs.size();
	int [] wdid_parts = new int[2];
	String wdid = null;
	Object o = null;

	if (__useSP) {
		for (int i = 0; i < size; i++) {
			wdid = (String)WDIDs.elementAt(i);
			if (StringUtil.isLong(wdid) 
			    || StringUtil.isInteger(wdid)) {
				try {
					wdid_parts = 
						HydroBase_WaterDistrict
						.parseWDID(wdid, wdid_parts);
				}
				catch (Exception e) {
					Message.printWarning(2, routine,
						"WDID \"" + wdid 
						+ "\" not valid -- ignoring.");
					wdid_parts = null;
				}

				if (wdid_parts != null) {
					o = readStructureViewForWDID(
						wdid_parts[0], wdid_parts[1]);
					if (o != null) {
						results.add(o);
					}
				}
			}
		}
	}
	else {
		for (int i = 0; i < size; i++) {
			wdid = (String)WDIDs.elementAt(i);
			if (StringUtil.isLong(wdid) 
			    || StringUtil.isInteger(wdid)) {
				try {
					wdid_parts = 
						HydroBase_WaterDistrict
						.parseWDID(wdid, wdid_parts);
				}
				catch (Exception e) {
					Message.printWarning(2, routine,
						"WDID \"" + wdid 
						+ "\" not valid -- ignoring.");
					wdid_parts = null;
				}

				if (wdid_parts != null) {
					o = readStructureForWDID(
						wdid_parts[0], wdid_parts[1]);
					if (o != null) {
						results.add(o);
					}
				}
			}
		}
	}
	
	return results;
}

/**
Read the geoloc, structure, wd_water, person_details and rolodex tables for
all data where geoloc and structure have matching geoloc_num values, wd_water
and structure have matching wdwater_num values, person_details and structure
have matching structure_num values and person_details and rolodex have matching
rolodex_num values.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WaterRightsQuery.HydroBase_GUI_WaterRightsQuery()</li>
<li>HydroBase_GUI_WaterRightsQuery.formatOutputForNetAmounts()</li>
<li>HydroBase_Report_StructureSummary.submitStructureGeolocQuery()</li>
<li>HydroBase_GUI_StructureMoreInfo.submitAndDisplayStructureLocationQuery()
</ul>
<p><b>Stored Procedure</b><p>
<b>THIS METHOD USES NO STORED PROCEDURES</b><p>
Use readStructureViewForStructure_num() instead.
@param structure_num the structure_num for which to return the record.
@return a HydroBase_StructureGeoloc object or a HydroBase_StructureView object,
depending on whether stored procedures were used..
@throws Exception if an error occurs.
*/
public HydroBase_StructureGeoloc readStructureGeolocForStructure_num(
int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_STRUCTURE_GEOLOC_FOR_STRUCTURE_NUM);
	q.addWhereClause("structure.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = toStructureGeolocList(rs);
	closeResultSet(rs);
	if (v.size() > 0) {
		return (HydroBase_StructureGeoloc)v.elementAt(0);
	}
	else {
		return null;
	}
}

/**
Reads the database for the data necessary to fill structure geoloc struct
meas type information.  This method is called both for databases that use 
stored procedures and those that do not, and it handles calling SPFlex or
the readXXXList() method, as appropriate.
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_GroundWaterWellsGroundWaterWellsMeasType (if the database version
is VERSION_20050701 or greater)</li>
<li>vw_CDSS_StructureStructMeasType</li></ul>
@param panel the panel of InputFilters that hold the query constraints.
@param districtWhere the value returned by getWaterDistrictWhereClause().
@return a Vector of HydroBase_StructureGeolocStructMeasType or 
HydroBase_StructureGeolocStructMeasTypeView objects.
@throws Exception if there is an error running the query.
@deprecated rename!
*/
public Vector readUnpermittedWellStructMeasTypeList(InputFilter_JPanel panel, 
String[] districtWhere)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			panel, districtWhere);
		if (getDatabaseVersion() < VERSION_20050701) {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber(
				"vw_CDSS_UnpermittedWellStructMeasType"), 
				0, null);
		}
		else {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber(
			    "vw_CDSS_GroundWaterWellsGroundWaterWellsMeasType"),
				83, null);
		}
		ResultSet rs = runSPFlex(parameters);
		Vector v = toGroundWaterWellMeasTypeList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		Vector wheres 
			= HydroBase_GUI_Util.getWhereClausesFromInputFilter(
			this, panel, HydroBase_GUI_Util._GEOLOC_TABLE_NAME,
			HydroBase_GUI_Util.GROUND_WATER);
		if (districtWhere != null) {
			wheres.add(districtWhere[0]);
		}
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_UNPERMITTED_WELL_STRUCT_MEAS_TYPE_VIEW);
		
		if (wheres != null) {
			for (int i = 0; i < wheres.size(); i++) {
				q.addWhereClause(
					(String)wheres.elementAt(i));
			}
		}
		q.addOrderByClause("structure.wd");
		q.addOrderByClause("structure.id");
		q.addOrderByClause("struct_meas_type.meas_num");

		ResultSet rs = dmiSelect(q);
		// Not a distinct query...
		Vector v = toGroundWaterWellMeasTypeList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the struct_meas_type table for all data and join with data in geoloc
and structure.<p>
This method is used by:<ul>
<li>TSTool</li>
<li>HydroBase_Util</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_StructureStructMeasType</li></ul>
@param panel the panel of InputFilters that hold the query constraints.
@param meas_type the meas_num for which to return the record (specify null to
read all).
@param time_step the time_step for which to return the record (specify null to
read all).
@return a Vector of HydroBase_StructureGeolocStructMeasType objects.
@throws Exception if an error occurs.
@junit do it view
*/
public Vector readStructureGeolocStructMeasTypeList(InputFilter_JPanel panel, 
String meas_type, String time_step)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			panel, null);
		String[] triplet = null;
		if (meas_type != null && meas_type.length() > 0) {
			triplet = new String[3];
			triplet[0] = "meas_type";
			triplet[1] = "MA";
			triplet[2] = meas_type;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
			
		if (time_step != null && time_step.length() > 0) {
			triplet = new String[3];
			triplet[0] = "time_step";
			triplet[1] = "MA";
			triplet[2] = time_step;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_StructureStructMeasType"), 
			74, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toStructMeasTypeSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_STRUCT_MEAS_TYPE_VIEW);
		
		if ((meas_type != null) && (meas_type.length() > 0)) {
			q.addWhereClause("struct_meas_type.meas_type='" 
				+ meas_type+"'");
		}
		if ((time_step != null) && (time_step.length() > 0)) {
			q.addWhereClause("struct_meas_type.time_step='" 
				+ time_step+"'");
		}

		Vector wheres
			= HydroBase_GUI_Util.getWhereClausesFromInputFilter(
			this, panel);

		if (wheres != null) {
			for (int i = 0; i < wheres.size(); i++) {
				q.addWhereClause(
					(String)wheres.elementAt(i));
			}
		}
		q.addOrderByClause("structure.wd");
		q.addOrderByClause("structure.id");
		q.addOrderByClause("struct_meas_type.meas_num");

		ResultSet rs = dmiSelect(q);
		// Not a distinct query...
		Vector v = toStructMeasTypeSPList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
@deprecated use readStructureViewListForWDStream_numStr_type instead.
*/
public Vector readStructureGeolocListForWDStream_numStr_type(int wd, 
long stream_num, String str_type)
throws Exception {
	return readStructureViewListForWDStream_numStr_type(wd, stream_num,
		str_type);
}

/**
Read the geoloc, structure, wd_water, person_details and rolodex tables for
all data where geoloc and structure have matching wd, stream_num and type 
values.
This method is used by:<ul>
<li>HydroBase_GUI_StructureQuery.submitQuery()</li>
<li>HydroBase_GUI_WISBuilder.displayStructureList()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following views:<p>
<ul><li>vw_CDSS_Structure</li></ul>
@param wd the wd to match
@param stream_num the stream num to match.  Can be missing, in which case it
will not be used.  If set to -1, NULL stream nums will be return.
@param str_type the str_type to match against
@return a Vector of HydroBase_StructureGeoloc objects.
@throws Exception if an error occurs.
*/
public Vector readStructureViewListForWDStream_numStr_type(int wd, 
long stream_num, String str_type)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		String[] triplet = new String[3];
		triplet[0] = "wd";
		triplet[1] = "EQ";
		triplet[2] = "" + wd;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
			
		triplet = new String[3];
		triplet[0] = "str_type";
		triplet[1] = "MA";
		triplet[2] = str_type;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		if (!DMIUtil.isMissing(stream_num) && stream_num != -1) {
			triplet = new String[3];
			triplet[0] = "stream_num";
			triplet[1] = "EQ";
			triplet[2] = "" + stream_num;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}		
		else if (stream_num == -1) {
			triplet = new String[3];
			triplet[0] = "stream_num";
			triplet[1] = "NL";
			triplet[2] = "1";
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}			
	
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Structure"), 29, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toStructureSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_STRUCTURE_VIEW);
		q.addOrderByClause("structure.str_name");
		q.addWhereClause("structure.wd = " + wd);
		q.addWhereClause("structure.str_type = '" + str_type + "'");

		if (!DMIUtil.isMissing(stream_num) && stream_num != -1) {
			q.addWhereClause("geoloc.stream_num = " + stream_num);
		}
		else if (stream_num == -1) {
			q.addWhereClause("geoloc.stream_num IS NULL");
		}
		
		ResultSet rs = dmiSelect(q);
		Vector v = toStructureSPList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the mf_reach table for all data and join with data in the structure table.
<p>
This method is used by:<ul>
<li>HydroBase_GUI_MinimumFlowReach.submitAndDisplayMFReachQuery()</li>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_StructureMFReach_Sel_By_Structure_num</li>
</ul>
@return a Vector of HydroBase_StructureMFReach objects.
@throws Exception if an error occurs.
*/
public Vector readStructureMFReachListForStructure_num(int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_MF_REACH);
	q.addWhereClause("structure.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toStructureMFReachSPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toStructureMFReachList(rs);
		closeResultSet(rs);
	}
	return v;
}

/**
Read the reservoir table for the record matching the specified structure_num
and join with the matching record from the structure table.<p>
This method is used by:<ul>
<li>HydroBase_GUI_ReservoirData.submitAndDisplayReservoirData</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_StructureReservoir_Sel_By_Structure_num</li>
</ul>
@param structure_num the structure_num to match records with.
@return the HydroBase_StructureReservoir object filled with data from the 
record.
@throws Exception if an error occurs.
*/
public HydroBase_StructureReservoir readStructureReservoirForStructure_num(
int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_RESERVOIR_FOR_STRUCTURE_NUM);
	q.addWhereClause("reservoir.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toStructureReservoirSPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toStructureReservoirList(rs);
		closeResultSet(rs);
	}
	if (v == null || v.size() == 0) {
		return null;
	}
	return (HydroBase_StructureReservoir)(v.elementAt(0));
}

/**
Read the reservoir table for all data and join with data from the structure
table where the wd and id match the provided values.<p>
This is called by:<ul>
<li>StateDMI</li>
</ul>
<p><b>Stored Procedures</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_StructureReservoir_Sel_By_WDID</li>
</ul>
@param wd the wd to match.
@param id the id to match.
@return a Vector of HydroBase_StructureReservoir objects.
@throws Exception if an error occurs.
*/
public HydroBase_StructureReservoir readStructureReservoirForWDID(int wd, 
int id)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_RESERVOIR);
	q.addWhereClause("structure.wd = " + wd);
	q.addWhereClause("structure.id = " + id);
	
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toStructureReservoirSPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toStructureReservoirList(rs);
		closeResultSet(rs);
	}
	if (v == null || v.size() == 0) {
		return null;
	}
	return (HydroBase_StructureReservoir)v.elementAt(0);
}

/**
Read the small_dam table for the record with the specified structure_num
and join with data in the structure table.
This method is used by:<ul>
<li>HydroBase_GUI_ExemptDam.submitAndDisplayDamQuery</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_StructureSmallDam_Sel_By_Structure_num</li>
</ul>
@return a Vector of HydroBase_StructureSmallDam objects.
@throws Exception if an error occurs.
*/
public HydroBase_StructureSmallDam readStructureSmallDamForStructure_num(
int structure_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_SMALL_DAM);
	q.addWhereClause("structure.structure_num = " + structure_num);
	ResultSet rs = dmiSelect(q);
	Vector v = null;
	if (__useSP) {
		v = toStructureSmallDamSPList(rs);
		closeResultSet(rs, q);
	}
	else {
		v = toStructureSmallDamList(rs);	
		closeResultSet(rs);
	}
	if (v == null || v.size() == 0) {
		return null;
	}
	return (HydroBase_StructureSmallDam)(v.elementAt(0));
}

/**
Reads the wd_water and structure tables for all records with the matching
structure IDs.<p>
This method is used by:<ul>
<li>HydroBase_NodeNetwork.setNodeDescriptions()</li>
</ul>
@throws Exception if an error occurs.
*/
public Vector readStructureWDWaterListForStructureIDs(Vector ids) 
throws Exception {
	Vector results = new Vector();
	int size = ids.size();
	Object o = null;
	int[] wdid = null;
	for (int i = 0; i < size; i++) {
		wdid = HydroBase_WaterDistrict.parseWDID(
			(String)ids.elementAt(i));
		if (__useSP) {
			o = readStructureViewForWDID(wdid[0], wdid[1]);
		}
		else {
			o = readStructureWDWaterForWDID(wdid[0], wdid[1]);
		}
		if (o != null) {
			results.add(o);
		}
	}
	return results;
}

/**
Read the geoloc, structure, wd_water, person_details and rolodex tables for
all data with a matching wdid.<p>  This is used when not using stored 
procedures.
@param wd the wd to match
@param id the id to match
@return a HydroBase_StructureView object
@throws Exception if an error occurs.
*/
public HydroBase_StructureWDWater readStructureWDWaterForWDID(int wd, int id)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_STRUCTURE_WD_WATER);
	q.addWhereClause("structure.wd = " + wd + " AND structure.id = "
			+ id);
	ResultSet rs = dmiSelect(q);
	Vector v = toStructureWDWaterList(rs);
	closeResultSet(rs);
	if (v == null || v.size() == 0) {
		return null;
	}
	else {
		return (HydroBase_StructureWDWater)v.elementAt(0);
	}
}

/**
Read a time series matching a time series identifier.  The identifier follows
standard TSIdent conventions, where the location is either a structure.WDID,
station.station_id, etc.  See the TSTool HydroBase Input Type appendix for
more information.
<p><b>Stored Procedures</b><p>
<b>THIS METHOD USES NO STORED PROCEDURES</b>
@return a time series or null if the time series is not defined in the database.
If no data records are available within the requested period, a call to
hasData() on the returned time series will return false.
@param tsident_string TSIdent string indentifying the time series.
@param req_date1 Optional date to specify the start of the query (specify 
null to read the entire time series).
@param req_date2 Optional date to specify the end of the query (specify 
null to read the entire time series).
@param req_units requested data units (specify null or blank string to 
return units from the database).
@param read_data Indicates whether data should be read (specify false to 
only read header information).
@param props Properties to control the read, mainly for special cases (e.g.,
whether diversion records have comments applied to set more zero data).
<table width=100% cellpadding=10 cellspacing=0 border=2>
<tr>
<td><b>Property</b></td>	<td><b>Description</b></td>	<td><b>Default</b></td>
</tr>

<tr>
<td><b>FillDailyDiv</b></td>
<td><b>Indicates whether daily diversion time series (DivTotal and DivClass)
should be filled by carrying forward using the State's standard algorithm, with
the result being less missing data.  HydroBase (as of the 2005 version) only
stores months of daily data where observations were recorded.  Other months are
carried forward in the same irrigation year (Nov to Oct).  Full missing years
are missing.  Starts of years are zero until a value is found.
This property will only be applied to the DivTotal and DivClass data types.
</b>
<td>True</td>
</tr>

<td><b>FillDailyDivFlag</b></td>
<td><b>A single-character that will be used as a flag for values that are
filled with daily carry forward method.
</b>
<td>No flag will be set.</td>
</tr>

<tr>
<td><b>FillUsingDivComments</b></td>
<td><b>Indicates whether daily and monthly diversion time series (DivTotal and
DivClass) should be filled by setting additional values to zero, from diversion
comment data.  Only full missing years are processed.
This property will only be applied to the DivTotal and DivClass data types for
monthly data.
</b>
<td>False</td>
</tr>

<td><b>FillUsingDivCommentsFlag</b></td>
<td><b>A single-character that will be used as a flag for values that are
filled with diversion comments.
</b>
<td>No flag will be set.</td>
</tr>
</table>
@exception Exception if there is an error reading the time series.
@exception NoDataFoundException If no data are found for the time series,
currently only used when a structure "struct_meas_type" record is not found,
and therefore the time series header information cannot be initialized.
*/
public TS readTimeSeries (String tsident_string, DateTime req_date1,
			  DateTime req_date2, String req_units,
			  boolean read_data, PropList props )
throws Exception, NoDataFoundException
{
	// Read a time series from the database.
	// IMPORTANT - BECAUSE WE CAN'T GET THE LAST RECORD FROM A ResultSet
	// FOR TIME SERIES DATA RECORDS, WE CANNOT GET THE END DATES FOR MEMORY
	// ALLOCATION UP FRONT.  THEREFORE, IT IS REQUIRED THAT THE ResultSet
	// BE CONVERTED TO A VECTOR OF DATA OBJECTS, WHICH CAN THEN BE EXAMINED
	// TO GET THE DATE.  IF THIS WERE NOT THE CASE, THE CODE COULD BE
	// OPTIMIZED TO GO DIRECTLY FROM A ResultSet TO A TS.

	String message, routine = "HydroBaseDMI.readTimeSeries";

	// Define properties as non-null, to simplify later use...

	if ( props == null ) {
		props = new PropList ( "" );
	}

	// Make sure that no invalid properties have been specified (this should
	// also occur in higher level code (e.g., for DMI commands)...

	Vector valid_props = new Vector ();
	valid_props.addElement ( "FillDailyDiv" );
	valid_props.addElement ( "FillDailyDivFlag" );
	valid_props.addElement ( "FillUsingDivComments" );
	valid_props.addElement ( "FillUsingDivCommentsFlag" );
	Vector warnings = props.validatePropNames (
					valid_props,	// These are supported
					null,		// Deprecated props
					null,		// Deprecated notes
					null );		// Target descriptor

	if ( warnings != null ) {
		StringBuffer warning = new StringBuffer ();
		int size = warnings.size();
		// These errors could be due to bad code, but this should be
		// caught with unit testing.  It could also be caused by users
		// hand-editing commands and having a typo.
		warning.append ( "Trying to read HydroBase time series using " +
		"invalid properties:" );
		for ( int i = 0; i < size; i++ ) {
			warning.append ( "\n" + warnings.elementAt(i) );
		}
		Message.printWarning ( 3, routine, warning.toString() );
		throw new HydroBaseException (
		"Invalid properties used reading time series." );
	}

	// First determine the meas_type or struct_meas_type for the time
	// series...

	HydroBase_StructMeasTypeView str_mt_v = null;	// For structures

	int mt_meas_num = DMIUtil.MISSING_INT;

	int mt_start_year = 0;	// Used for both stations and structures to
	int mt_end_year = 0;	// indicate database period and set dates.

	TSIdent tsident = new TSIdent ( tsident_string);
	String data_source = tsident.getSource();	// TSID data source
	String data_type = tsident.getType();		// TSID data type 
	String sub_data_type = "";			// Sub-data type.
	String agstats_commodity = "";			// Agstats commodity
	String agstats_practice = "";			// Agstats practice
	String agstats_type = "";			// Agstats type
	String cupop_area_type = "";			//CUPopulation area type
	String cupop_area_name = "";			//CUPopulation area name
	String cupop_pop_type = "";			//CUPopulation pop. type
	Vector sheet_names = null;			// Vector of sheet_name
							// needed to get list
							// of wis_num for data
							// queries.
	Vector wis_formats = null;			// The list of formats
							// describing the rows
							// of interest.
	String wis_sheet_name = "";			// WIS sheet name, used
							// with WIS time series

	if (data_type.indexOf("-") > 0) {
		// Contains the vax_field or SFUT...
		sub_data_type = StringUtil.getToken ( data_type, "-", 0, 1);
		data_type = StringUtil.getToken ( data_type, "-", 0, 0);
	}
	String interval = tsident.getInterval();	// TSID data interval 

	// Convert the requested data type and interval to a HydroBase
	// meas_type and time_step for the queries...
	String [] hb_mt = HydroBase_Util.convertToHydroBaseMeasType(
			data_type, interval);
	String meas_type = hb_mt[0];
	String vax_field = hb_mt[1];
	String time_step = hb_mt[2];

	// First define the time series to be returned, based on the TSID
	// interval base and multiplier...

	TS ts = null;

	// REVISIT (SAM) - need to verify that there is no multiplier on the
	// following...
	if (	interval.equalsIgnoreCase("Min") ||
		interval.equalsIgnoreCase("Minute")) {
		ts = new MinuteTS ();
	}
	else if (interval.equalsIgnoreCase("Hour")) {
		ts = new HourTS ();
	}
	else if (interval.equalsIgnoreCase("Day")) {
		ts = new DayTS ();
		if (data_type.equalsIgnoreCase("Precip")) {
			// Allow data flags - HydroBase has 1 character flags...
			((DayTS)ts).hasDataFlags(true, 1);
		}
		else if (data_type.equalsIgnoreCase("DivTotal") ||
			data_type.equalsIgnoreCase("DivClass") ||
			data_type.equalsIgnoreCase("RelTotal") ||
			data_type.equalsIgnoreCase("RelClass")) {
			// Allow data flags - HydroBase has 2 character flags...
			((DayTS)ts).hasDataFlags(true,2);
		}
	}
	else if (interval.equalsIgnoreCase("Month")) {
		ts = new MonthTS ();
	}
	else if (interval.equalsIgnoreCase("Year")) {
		ts = new YearTS ();
		if (data_type.equalsIgnoreCase("DivComment")) {
			// Allow data flags - HydroBase has 1 character flags...
			((YearTS)ts).hasDataFlags(true,1);
		}
		else if (data_type.equalsIgnoreCase("DivClass") ||
			data_type.equalsIgnoreCase("DivTotal") ||
			data_type.equalsIgnoreCase("IDivClass") ||
			data_type.equalsIgnoreCase("IDivTotal") ||
			data_type.equalsIgnoreCase("IRelClass") ||
			data_type.equalsIgnoreCase("IRelTotal") ||
			data_type.equalsIgnoreCase("RelClass") ||
			data_type.equalsIgnoreCase("RelTotal")) {
			// Allow quality flags - HydroBase has 1 character
			// flags...
			((YearTS)ts).hasDataFlags(true,1);
		}
	}
	else if (interval.equalsIgnoreCase("Irreg") ||
		interval.equalsIgnoreCase("Irregular") ||
		interval.equalsIgnoreCase("RealTime")) {
		ts = new IrregularTS ();
	}
	else {
		Message.printWarning ( 3, routine,
		"Data interval \"" + interval + "\" is not supported.");
		return null;
	}
	int interval_base = ts.getDataIntervalBase();

	// Define the header information from station/meas_type or
	// structure/struct_meas_type...

	String wdid = "";
	int [] wdid_parts = null;
	HydroBase_StationView staView = null;
	HydroBase_StationView mtsView = null;
	HydroBase_StructureView strView = null;
	HydroBase_GroundWaterWellsView well = null;
	DateTime db_DateTime1 = null;
	DateTime db_DateTime2 = null;
				// Used for WIS to indicate database period
	
	if (HydroBase_Util.isStationTimeSeriesDataType(this, meas_type)) {
		// Data types associated with stations...
		// First get the station because the station_num is needed...
		String station_id = tsident.getLocation();
		staView = readStationViewForStation_id ( station_id);
		if (staView == null) {
			message = "Unable to find station \"" 
				+ station_id+"\"";
			Message.printWarning ( 3, routine, message);
			throw new Exception ( message);
		}
		// Next get the meas_type for the station...
		Vector mts = readMeasTypeList(staView.getStation_num(), 
			meas_type, vax_field, time_step, data_source);
		if ((mts == null) || (mts.size() == 0)) {
			message = "Unable to find meas_type for \"" +
				tsident_string + "\" station_num =" +
				staView.getStation_num() +" meas_type="+
				meas_type + " vax_field=" + vax_field +
				" time_step=" + time_step;
			Message.printWarning ( 3, routine, message);
			throw new Exception ( message);
		}
		mtsView = (HydroBase_StationView)
			mts.elementAt(0);
		mt_start_year = mtsView.getStart_year();
		mt_end_year = mtsView.getEnd_year();
		mt_meas_num = mtsView.getMeas_num();
		ts.setIdentifier ( tsident_string);
		ts.setDescription ( staView.getStation_name());
	}
	else if (HydroBase_Util.isStructureTimeSeriesDataType (
			this, meas_type)) {
		// Data types associated with structures...
		// First get the structure because the structure_num is
		// needed...

		// REVISIT (SAM 2004-01-14) START
		//	- Fix when well data redesign is done
		// If the data type is "WellLevel" and time step is "Day", then
		// the incoming data type may be a USGS, USGS, or WDID id.
		// Until HydroBase is redesigned, a work-around is in place
		// below to convert this back to a WDID, which is found in the
		// structure table.  There are not a lot of these time series 
		// so doing an extra lookup here is not much of a penalty.

		if (	data_type.equals("WellLevel") &&
			interval.equalsIgnoreCase("Day")) {
			// First try to get an unpermitted_wells record matching
			// the USGS id...
			HydroBase_GroundWaterWellsView tempWell = null;
			if (data_source.equalsIgnoreCase("USGS")) {
				tempWell = readUnpermittedWells(-999,
					tsident.getLocation(), null);
			}
			else if (data_source.equalsIgnoreCase("USBR")) {
				tempWell = readUnpermittedWells(-999,
					null, tsident.getLocation());
			}
			if (tempWell != null) {
				// An unpermitted well was found so try to get
				// the structure for it (so the WDID can be
				// determined)...
				HydroBase_StructureView well_str =
				      readStructureViewForStructure_num(
					tempWell.getStructure_num());
				wdid_parts = new int[2];
				wdid_parts[0] = well_str.getWD();
				wdid_parts[1] = well_str.getID();
			}
			else {
				// No unpermitted well so the original WDID is
				// OK and will be processed below...
				wdid = tsident.getLocation();
			}
		}
		else {
			// All other structures have the WDID in the location...
			wdid = tsident.getLocation();
		}

		try {
			if (wdid_parts == null) {
				// Need to parse it out...
				wdid_parts = HydroBase_WaterDistrict.parseWDID (
						wdid);
			}
		}
		catch ( Exception e) {
			message = "Cannot parse \"" + tsident.getLocation() +
			"\" into WD and ID - can't look up structure.";
			Message.printWarning ( 3, routine, message);
			throw new Exception ( message);
		}
		strView = readStructureViewForWDID(wdid_parts[0], 
			wdid_parts[1]);
		if (strView == null) {
			message = "Unable to find structure \"" 
				+ tsident.getLocation() +"\"";
			Message.printWarning(3, routine, message);
			throw new Exception(message);
		}
		// The identifier is the SFUT string which should have come in
		// as the sub data type...
		String identifier = sub_data_type;
		String identifier_adjusted = HydroBase_Util.adjustSFUTForHydroBaseVersion(
				this,wdid_parts[0],wdid_parts[1],identifier);
		// Next get the struct_meas_type for the structure...
		Vector mts = readStructMeasTypeListForStructure_num
			(strView.getStructure_num(), meas_type,
			identifier_adjusted,time_step, data_source);
		if ((mts == null) || (mts.size() == 0)) {
			message = "Unable to find struct_meas_type "
				+ "for \"" + tsident_string 
				+ "\" structure_num =" 
				+ strView.getStructure_num() 
				+ " meas_type=" + meas_type 
				+ " identifier=" + identifier 
				+ " time_step=" + time_step
				+ "  Structure does not have a time series "
				+ "in HydroBase.";
			if ( identifier.equals(identifier_adjusted) ) {
				 message += " (SFUT adjusted to be compatible with database version)";
			}
			Message.printWarning(3, routine, message);
			throw new NoDataFoundException(message);
		}
		str_mt_v = (HydroBase_StructMeasTypeView)
			mts.elementAt(0);
		mt_start_year = str_mt_v.getStart_year();
		mt_end_year = str_mt_v.getEnd_year();
		ts.setIdentifier(tsident_string);
		ts.setDescription(strView.getStr_name());
	}
	// XJTSX
	// added this because WellLevel as a MeasType was not being recognized
	// as one of the structure time series data types.
	else if (meas_type.equalsIgnoreCase("WellLevel")) {
		// REVISIT (SAM 2004-01-14) START
		//	- Fix when well data redesign is done
		// If the data type is "WellLevel" and time step is "Day", then
		// the incoming data type may be a USGS, USGS, or WDID id.
		// Until HydroBase is redesigned, a work-around is in place
		// below to convert this back to a WDID, which is found in the
		// structure table.  There are not a lot of these time series 
		// so doing an extra lookup here is not much of a penalty.

		// First try to get an unpermitted_wells record matching
		// the USGS id...

//Message.printStatus(1, "", "TSLOC: " + tsident.getLocation());
		
		well = readGroundWaterWellMeasType(tsident.getLocation());

//Message.printStatus(1, "", "WELL? " + well);

		mt_start_year = well.getStart_year();
		mt_end_year = well.getEnd_year();
		ts.setIdentifier(tsident_string);
		ts.setDescription(well.getWell_name());
	}
	else if (	HydroBase_Util.
			isAgriculturalCASSCropStatsTimeSeriesDataType(this,
			data_type)) {
		// The sub-datatype has the comodity and practice, separated
		// by an underscore
		agstats_commodity = StringUtil.getToken (
			sub_data_type, "_", 0, 0);
		agstats_practice = StringUtil.getToken (
			sub_data_type, "_", 0, 1);
		ts.setIdentifier ( tsident_string);
		ts.setDescription ( tsident.getLocation() + "," +
			agstats_commodity + "," + agstats_practice); 
	}
	else if (	HydroBase_Util.
			isAgriculturalCASSLivestockStatsTimeSeriesDataType(this,
			data_type)) {
		// The sub-datatype has the comodity and type, separated
		// by an underscore
		agstats_commodity = StringUtil.getToken (
			sub_data_type, "_", 0, 0);
		agstats_type = StringUtil.getToken (
			sub_data_type, "_", 0, 1);
		ts.setIdentifier ( tsident_string);
		ts.setDescription ( tsident.getLocation() + "," +
			agstats_commodity + "," + agstats_type); 
	}
	else if (	HydroBase_Util.
			isAgriculturalNASSCropStatsTimeSeriesDataType(this,
			data_type)) {
		// The sub-datatype has the comodity and practice, only referred
		// to as commodity by NASS
		agstats_commodity = sub_data_type;
		ts.setIdentifier ( tsident_string);
		ts.setDescription ( tsident.getLocation() + "," +
			agstats_commodity); 
	}
	else if (	HydroBase_Util.
			isCUPopulationTimeSeriesDataType(this, data_type)) {
		// The location has the area type and name.
		cupop_area_type = StringUtil.getToken (
			tsident.getLocation(), "-", 0, 0 );
		cupop_area_name = StringUtil.getToken (
			tsident.getLocation(), "-", 0, 1 );
		// The sub-datatype has the population type.
		cupop_pop_type = sub_data_type;
		ts.setIdentifier ( tsident_string);
		ts.setDescription ( cupop_area_name + "," + cupop_pop_type ); 
	}
	else if (HydroBase_Util.isIrrigSummaryTimeSeriesDataType(this,
			data_type)) {
		// Used for irrig_summary_ts.
		// Get the wdid_parts for later.
		// REVISIT (SAM 2004-02-08) - if the irrig_summary_ts table
		// only contains structure data, may include this with
		// structures above to get the structure information for time
		// series comments.
		wdid_parts = HydroBase_WaterDistrict.parseWDID (
					tsident.getLocation());
		// The location should correspond to a structure since only
		// ditches are currently associated with crop areas...
		strView = readStructureViewForWDID(wdid_parts[0], 
			wdid_parts[1]);
		if (strView == null) {
			message = "Unable to find structure \"" 
				+ tsident.getLocation() + "\"";
			Message.printWarning(3, routine, message);
			throw new Exception(message);
		}
		ts.setIdentifier(tsident_string);
		ts.setDescription(strView.getStr_name());
	}
	else if (HydroBase_Util.isWISTimeSeriesDataType(this, data_type)) {
		// The scenario has the sheet name...
		ts.setIdentifier ( tsident_string);
		wis_sheet_name = ts.getIdentifier().getScenario();
		// Read the sheet names to get the sheet number.  The wis_num is
		// used to join WIS tables...
		sheet_names = readWISSheetNameList(-999, -999, wis_sheet_name, 
			null);
		if ((sheet_names == null) || (sheet_names.size() == 0)) {
			message = "Unable to find sheet_name for \"" +
				tsident_string + "\" sheet name =\"" +
				wis_sheet_name + "\"";
			Message.printWarning ( 3, routine, message);
			throw new Exception ( message);
		}
		// Query for all the wis_format table for the given wis_num and
		// identifier.  This will provide the combination of wis_num and
		// wis_row needed to query the wis_data table later.  It also
		// provides the row label for the description.
		int wis_size = sheet_names.size();
		Vector wisNums = new Vector();
		Vector identifiers = new Vector();
		for ( int iwis = 0; iwis < wis_size; iwis++) {
			wisNums.add("" + ((HydroBase_WISSheetName)
				sheet_names.elementAt(iwis)).getWis_num());
			identifiers.add(tsident.getLocation());
		}
		wis_formats = readWISFormatListForWis_numIdentifierList(
			wisNums, identifiers);
		if ((wis_formats == null) || (wis_formats.size() == 0)) {
			message = "Unable to find wis_format for \"" +
				tsident_string + "\" sheet name =\"" +
				wis_sheet_name + "\"";
			Message.printWarning ( 3, routine, message);
			throw new Exception ( message);
		}
		// Set the description using the first record - if the name
		// changed, there is a chance that this will not be consistent
		// with the current sheet since the records are not sorted by
		// date.
		ts.setDescription (
			((HydroBase_WISFormat)wis_formats.elementAt(0)).
			getRow_label());
		// Read the vector of wis_comments for the sheet name, in order
		// to get available dates...
		Vector temp = readWISSheetNameList(DMIUtil.MISSING_INT,
			DMIUtil.MISSING_INT, wis_sheet_name, null);
		Vector wis_nums	= new Vector();
		int sz = temp.size();
		HydroBase_WISSheetName wss = null;
		for (int i = 0; i < sz; i++) {
			wss = (HydroBase_WISSheetName)temp.elementAt(i);
			wis_nums.add("" + wss.getWis_num());
		}
		Vector wis_comments = readWISCommentsList(wis_nums, null);
		if ((wis_comments == null) || (wis_comments.size() == 0)) {
			message = "Unable to find wis_comments for \"" +
				tsident_string + "\" sheet name =\"" +
				wis_sheet_name + "\"";
			Message.printWarning ( 3, routine, message);
			throw new Exception ( message);
		}
		db_DateTime1 = new DateTime ( ((HydroBase_WISComments)
			wis_comments.elementAt(0)).getSet_date());
		db_DateTime2 = new DateTime ( ((HydroBase_WISComments)
			wis_comments.elementAt(wis_comments.size() - 1)).
			getSet_date());
	}
	else {
		message = "Unrecognized meas_type \"" + meas_type +
			"\" from data type \"" + data_type + "\"";
		Message.printWarning ( 3, routine, message);
		throw new Exception ( message);
	}

	// Set the time series dates from available header information (may be
	// reset below when data are read).

	if (req_date1 != null) {
		ts.setDate1 ( req_date1);
	}
	else if (db_DateTime1 != null) {
		// WIS...
		ts.setDate1 ( db_DateTime1);
	}
	else {
		// Assume the precision based on the time step...
		if (interval_base == TimeInterval.YEAR) {
			DateTime date1 = new DateTime(DateTime.PRECISION_YEAR);
			date1.setYear ( mt_start_year);
			ts.setDate1 ( date1);
		}
		else if (interval_base == TimeInterval.MONTH) {
			DateTime date1 = new DateTime(DateTime.PRECISION_MONTH);
			date1.setYear ( mt_start_year);
			date1.setMonth ( 1);
			ts.setDate1 ( date1);
		}
		else if (interval_base == TimeInterval.DAY) {
			DateTime date1 = new DateTime ( DateTime.PRECISION_DAY);
			date1.setYear ( mt_start_year);
			date1.setMonth ( 1);
			date1.setDay ( 1);
			ts.setDate1 ( date1);
		}
		/* Irregular real-time does not have dates in meas_type
		else {
			// Real time to minute...
			DateTime date1 =new DateTime(DateTime.PRECISION_MINUTE);
			date1.setYear ( mt_start_year);
			date1.setMonth ( 1);
			date1.setDay ( 1);
			ts.setDate1 ( date1);
		}
		*/
	}
	if (req_date2 != null) {
		ts.setDate2 ( req_date2);
	}
	else if (db_DateTime2 != null) {
		// WIS...
		ts.setDate2 ( db_DateTime2);
	}
	else {
		// Assume the precision based on the time step...
		if (interval_base == TimeInterval.YEAR) {
			DateTime date2 = new DateTime(DateTime.PRECISION_YEAR);
			date2.setYear ( mt_end_year);
			ts.setDate2 ( date2);
		}
		else if (interval_base == TimeInterval.MONTH) {
			DateTime date2 = new DateTime(DateTime.PRECISION_MONTH);
			date2.setYear ( mt_end_year);
			date2.setMonth ( 12);
			ts.setDate2 ( date2);
		}
		else if (interval_base == TimeInterval.DAY) {
			DateTime date2 = new DateTime (DateTime.PRECISION_DAY);
			date2.setYear ( mt_end_year);
			date2.setMonth ( 12);
			date2.setDay ( TimeUtil.numDaysInMonth(date2));
			ts.setDate2 ( date2);
		}
		/* Irregular does not have dates in meas_type
		else {
			// Real time to minute...
			DateTime date2 =new DateTime(DateTime.PRECISION_MINUTE);
			date2.setYear ( mt_end_year);
			date2.setMonth ( 1);
			date2.setDay ( TimeUtil.numDaysInMonth(date2));
			ts.setDate2 ( date2);
		}
		*/
	}
	// Set the original dates from the database.  These dates are often not
	// available because the data records must be read.  However, some
	// data types will have database dates up front...

	if (db_DateTime1 != null) {
			ts.setDate1Original ( db_DateTime1);
	}
	if (db_DateTime2 != null) {
			ts.setDate2Original ( db_DateTime2);
	}

	// Return if no data are requested...

	if (!read_data) {
		return ts;
	}

	// Read the data.
	// Currently HydroBase does not have an easy way to automate the
	// following because tables have specific formats and more than one
	// time series is in a table, as columns.
	//
	// List alphabetized by data type but check the interval first since it
	// is an integer (fast check).

	Vector v = null;	// Vector of time series data records.
	if ((interval_base == TimeInterval.DAY) &&
			data_type.equalsIgnoreCase("AdminFlow")) {
			ts.setDataUnits (
				HydroBase_Util.getTimeSeriesDataUnits (
				this, data_type, interval ));
			ts.setDataUnitsOriginal ( ts.getDataUnits());
			ts.setInputName ( "HydroBase DailyAdminFlow.day*");
			v = readDailyStationData ( __S_DAILY_ADMIN_FLOW,
						mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
			data_type.equalsIgnoreCase("AdminFlow")) {

			ts.setDataUnits (
				HydroBase_Util.getTimeSeriesDataUnits (
				this, data_type, interval ));
			ts.setDataUnitsOriginal ( ts.getDataUnits());
			ts.setInputName ( "HydroBase MonthlyAdminFlow.total_q_af");
			v = readMonthlyStationData ( __S_MONTHLY_TOTAL_ADMIN_FLOW,
						mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
			data_type.equalsIgnoreCase("AdminFlowMax")) {

			ts.setDataUnits (
				HydroBase_Util.getTimeSeriesDataUnits (
				this, data_type, interval ));
			ts.setDataUnitsOriginal ( ts.getDataUnits());
			ts.setInputName ( "HydroBase MonthlyAdminFlow.max_q_cfs");
			v = readMonthlyStationData ( __S_MONTHLY_MAX_ADMIN_FLOW,
						mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
			data_type.equalsIgnoreCase("AdminFlowMin")) {

			ts.setDataUnits (
				HydroBase_Util.getTimeSeriesDataUnits (
				this, data_type, interval ));
			ts.setDataUnitsOriginal ( ts.getDataUnits());
			ts.setInputName ( "HydroBase MonthlyAdminFlow.min_q_cfs");
			v = readMonthlyStationData ( __S_MONTHLY_MIN_ADMIN_FLOW,
						mt_meas_num, req_date1, req_date2);
	}
	else if (	(interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropArea")) {
		// Units determined from data below.
		ts.setInputName (
			"HydroBase agricultural_NASS_crop_stats.harvested");
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		v = readAgriculturalNASSCropStatsList (
			null,	// panel
			tsident.getLocation(),	// County
			agstats_commodity,
			req_date1, req_date2, false);
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropAreaHarvested")) {
		// Units determined from data below.
		ts.setInputName (
			"HydroBase agricultural_CASS_crop_stats.harvested");
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		v = readAgriculturalCASSCropStatsList (
			(InputFilter_JPanel)null,	// panel 
			tsident.getLocation(),	// County
			agstats_commodity,
			agstats_practice,
			req_date1, req_date2, false);
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropAreaPlanted")) {
		ts.setInputName (
			"HydroBase agricultural_CASS_crop_stats.planted");
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		v = readAgriculturalCASSCropStatsList (
			(InputFilter_JPanel)null,	// panel 
			tsident.getLocation(),	// County
			agstats_commodity,
			agstats_practice,
			req_date1, req_date2, false);
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropAreaAllIrrigation")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase irrig_summary_ts.acres_total");
		v = readStructureIrrigSummaryTSList (
			null,	// panel
			null,	// order by clauses
			-999,	// structure_num
			wdid_parts[0],	// Parsed above
			wdid_parts[1],	// parsed above
			null,	// str_name
			sub_data_type,	// Land use (crop type)
			req_date1,
			req_date2,
			false);	// Not distinct
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropAreaDrip")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase irrig_summary_ts.acres_by_drip");
		v = readStructureIrrigSummaryTSList (
			null,	// panel
			null,	// order by clauses
			-999,	// structure_num
			wdid_parts[0],	// Parsed above
			wdid_parts[1],	// parsed above
			null,	// str_name
			sub_data_type,	// Land use (crop type)
			req_date1,
			req_date2,
			false);	// Not distinct
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropAreaFlood")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase irrig_summary_ts.acres_by_flood");
		v = readStructureIrrigSummaryTSList (
			null,	// panel
			null,	// order by clauses
			-999,	// structure_num
			wdid_parts[0],	// Parsed above
			wdid_parts[1],	// parsed above
			null,	// str_name
			sub_data_type,	// Land use (crop type)
			req_date1,
			req_date2,
			false);	// Not distinct
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropAreaFurrow")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase irrig_summary_ts.acres_by_furrow");
		v = readStructureIrrigSummaryTSList (
			null,	// panel  
			null,	// order by clauses
			-999,	// structure_num
			wdid_parts[0],	// Parsed above
			wdid_parts[1],	// parsed above
			null,	// str_name
			sub_data_type,	// Land use (crop type)
			req_date1,
			req_date2,
			false);	// Not distinct
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropAreaSprinkler")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName (
			"HydroBase irrig_summary_ts.acres_by_sprinkler");
		v = readStructureIrrigSummaryTSList (
			null,	// panel
			null,	// order by clauses
			-999, 	// structure_num
			wdid_parts[0],	// Parsed above
			wdid_parts[1],	// parsed above
			null,	// str_name
			sub_data_type,	// Land use (crop type)
			req_date1,
			req_date2,
			false);	// Not distinct
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("DivClass")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase daily_wc.amt_*, daily_wc.obs_*");
		v = readDailyWCList(str_mt_v.getMeas_num(),
			req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		(data_type.equalsIgnoreCase("DivClass") ||
		data_type.equalsIgnoreCase("IDivClass")) ) {

		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase annual_wc.amt_*");
		v = readAnnualWCList(str_mt_v.getMeas_num(),
			req_date1,req_date2);
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("DivClass") ||
		data_type.equalsIgnoreCase("IDivClass")) ) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase annual_wc.ann_amt");
		v = readAnnualWCList(str_mt_v.getMeas_num(),
			req_date1,req_date2);
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("DivComment")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName (
		"HydroBase diversion_comment.not_used, " +
		"diversion_comment.acres_irrig");
		v = readDiversionCommentList(
			str_mt_v.getMeas_num(),req_date1,req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("DivTotal")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase daily_amt.amt_*, daily_amt.obs_*");
		v = readDailyAmtList(str_mt_v.getMeas_num(),
			req_date1,req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("DivTotal") ||
		(data_type.equalsIgnoreCase("IDivTotal")) ) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase annual_amt.amt_*");
		v = readAnnualAmtList(str_mt_v.getMeas_num(),
			req_date1,req_date2);
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("DivTotal") ||
		data_type.equalsIgnoreCase("IDivTotal")) ) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase annual_amt.ann_amt");
		v = readAnnualAmtList(str_mt_v.getMeas_num(),
			req_date1,req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("EvapPan")) {

		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase monthly_evap.total_evap");
		v = readMonthlyStationData ( __S_MONTHLY_TOTAL_EVAP,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("EvapPan")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase daily_evap.day*");
		v = readDailyStationData ( __S_DAILY_EVAP,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("FrostDateF32F") ||
		data_type.equalsIgnoreCase("FrostDateF28F") ||
		data_type.equalsIgnoreCase("FrostDateL32S") ||
		data_type.equalsIgnoreCase("FrostDateL28S"))) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase frost_dates");
		v = readFrostDatesList (mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("HumanPopulation")) {
		// CU Population...
		ts.setInputName (
			"HydroBase CUPopulation.population");
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		v = readCUPopulationList (
			(InputFilter_JPanel)null,	// panel 
			cupop_area_type,		//literal "County", etc.
			cupop_area_name,
			cupop_pop_type,
			req_date1, req_date2, false);
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("LivestockHead")) {
		// CASS agstats...
		ts.setInputName (
			"HydroBase agricultural_CASS_livestock_stats.head");
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		v = readAgriculturalCASSLivestockStatsList (
			(InputFilter_JPanel)null,	// panel 
			tsident.getLocation(),	// County
			agstats_commodity,
			agstats_type,
			req_date1, req_date2, false);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("NaturalFlow")) {

		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase monthly_nflow.total_q_af");
		v = readMonthlyStationData ( __S_MONTHLY_TOTAL_NFLOW,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("Precip")) {

		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase monthly_pcpn.total_evap");
		v = readMonthlyStationData ( __S_MONTHLY_TOTAL_PCPN,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Precip")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ("HydroBase daily_pcpn.day*, daily_pcpn.flag*");
		v = readDailyStationData ( __S_DAILY_PCPN,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("RelClass")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase daily_wc.amt_*, daily_wc.obs_*");
		v = readDailyWCList(str_mt_v.getMeas_num(),
			req_date1,req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		(data_type.equalsIgnoreCase("RelClass") ||
		data_type.equalsIgnoreCase("IRelClass")) ) {

		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase annual_wc.amt_*");
		v = readAnnualWCList(str_mt_v.getMeas_num(),
			req_date1,req_date2);
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("RelClass") ||
		data_type.equalsIgnoreCase("IRelClass")) ) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase annual_wc.ann_amt");
		v = readAnnualWCList(str_mt_v.getMeas_num(),
			req_date1,req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("RelTotal")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase daily_amt.amt_*, daily_amt.obs_*");
		v = readDailyAmtList(str_mt_v.getMeas_num(),
			req_date1,req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		(data_type.equalsIgnoreCase("RelTotal") ||
		data_type.equalsIgnoreCase("IRelTotal"))) {

		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase annual_amt.amt_*");
		v = readAnnualAmtList(str_mt_v.getMeas_num(),
			req_date1,req_date2);
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("RelTotal") ||
		data_type.equalsIgnoreCase("IRelTotal")) ) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase annual_amt.ann_amt");
		v = readAnnualAmtList(str_mt_v.getMeas_num(),
			req_date1,req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("ResEOM")) {

		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase res_eom.total_af");
		v = readResEOMList(str_mt_v.getMeas_num(), 
			req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("ResEOY")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase annual_res.ann_amt");
		v = readAnnualResList(str_mt_v.getMeas_num(),
			req_date1,req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("ResMeasElev")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase res_meas.gage_height");
		v = readResMeasList(str_mt_v.getMeas_num(), 
			req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("ResMeasEvap")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase res_meas.evap_loss_amt");
		v = readResMeasList(str_mt_v.getMeas_num(), 
			req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("ResMeasFill")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase res_meas.fill_amt");
		v = readResMeasList(str_mt_v.getMeas_num(), 
			req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("ResMeasRelease")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase res_meas.release_amt");
		v = readResMeasList(str_mt_v.getMeas_num(), 
			req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("ResMeasStorage")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase res_meas.storage_amt");
		v = readResMeasList(str_mt_v.getMeas_num(), 
			req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("Snow")) {

		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase monthly_snow.total_snow");
		v = readMonthlyStationData ( __S_MONTHLY_TOTAL_SNOW,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Snow")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase daily_snow.day*");
		v = readDailyStationData ( __S_DAILY_SNOW,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		(data_type.equalsIgnoreCase("SnowCourseDepth") ||
		data_type.equalsIgnoreCase("SnowCourseSWE"))) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase monthly_snow.depth");
		v = readSnowCrseList(mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Solar")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase daily_solar.day*");
		v = readDailyStationData ( __S_DAILY_SOLAR,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Streamflow")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase daily_flow.day*");
		v = readDailyStationData ( __S_DAILY_FLOW,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("Streamflow")) {

		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase monthly_flow.total_q_af");
		v = readMonthlyStationData ( __S_MONTHLY_TOTAL_FLOW,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("StreamflowMax")) {

		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase monthly_flow.max_q_cfs");
		v = readMonthlyStationData ( __S_MONTHLY_MAX_FLOW,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("StreamflowMin")) {

		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase monthly_flow.min_q_cfs");
		v = readMonthlyStationData ( __S_MONTHLY_MIN_FLOW,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("TempMax")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase daily_max_t.day*");
		v = readDailyStationData ( __S_DAILY_MAX_T,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("TempMean")) {

		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase monthly_temp.mean_t");
		v = readMonthlyStationData ( __S_MONTHLY_MEAN_T,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("TempMeanMax")) {

		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase monthly_temp.avg_max_t");
		v = readMonthlyStationData ( __S_MONTHLY_AVG_MAX_T,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("TempMeanMin")) {

		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase monthly_temp.avg_min_t");
		v = readMonthlyStationData ( __S_MONTHLY_AVG_MIN_T,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("TempMin")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase daily_min_t.day*");
		v = readDailyStationData ( __S_DAILY_MIN_T,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("VaporPressure")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase daily_vp.day*");
		v = readDailyStationData ( __S_DAILY_VP,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("WellLevel")) {
		// XJTSX
		if (getDatabaseVersion() < VERSION_20050701) {
		// XJTSX
			ts.setDataUnits (
				HydroBase_Util.getTimeSeriesDataUnits (
				this, data_type, interval ));
			ts.setDataUnitsOriginal ( ts.getDataUnits());
			ts.setInputName ( "HydroBase well_meas.wat_level");
			v = readWellMeasList (str_mt_v.getMeas_num(),
				req_date1,req_date2);
		}
		// XJTSX
		else {
			ts.setDataUnits (
				HydroBase_Util.getTimeSeriesDataUnits (
				this, data_type, interval ));
			ts.setDataUnitsOriginal ( ts.getDataUnits());
			ts.setInputName ( "HydroBase well_meas.wat_level");
			v = readWellMeasList (well.getWell_meas_num(),
				req_date1, req_date2);
		}
		// XJTSX
		
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Wind")) {
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase daily_wind.day*");
		v = readDailyStationData ( __S_DAILY_WIND,
					mt_meas_num, req_date1, req_date2);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.regionMatches(true,0,"WIS",0,3)) {
		// Water information sheets.  Records must be read from
		// the wis_data table using the wis_num/row_num pair list
		// determined above, sorted by date.  If for some reason a value
		// exists in more than one wis_num for the same date (it should
		// not, the later value will be used).
		ts.setDataUnits (
			HydroBase_Util.getTimeSeriesDataUnits (
			this, data_type, interval ));
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		ts.setInputName ( "HydroBase wis_data for wis_num/wis_row");
		int wis_size = sheet_names.size();
		// Now query for the data records from the wis_data table
		// corresponding to the wis_num and wis_row pairs..
		Vector wisNums = new Vector();
		Vector wisRows = new Vector();
		HydroBase_WISFormat format = null;
		for ( int iwis = 0; iwis < wis_size; iwis++) {
			format = (HydroBase_WISFormat)wis_formats.elementAt(
				iwis);
			wisNums.add("" + format.getWis_num());
			wisRows.add("" + format.getWis_row());
		}
		Vector order = new Vector();
		order.add("wis_data.set_date");
		v = readWISDataListForWis_numWis_rowList(wisNums, wisRows,
			order);
	}
	// Real-time data...
	else if ((interval_base == TimeInterval.IRREGULAR) &&
		(data_type.equalsIgnoreCase("AdminFlow") ||
		data_type.equalsIgnoreCase("Battery") ||
		data_type.equalsIgnoreCase("PoolElev") ||
		data_type.equalsIgnoreCase("Precip") ||
		data_type.equalsIgnoreCase("Release") ||
		data_type.equalsIgnoreCase("Stage") ||
		data_type.equalsIgnoreCase("Storage") ||
		data_type.equalsIgnoreCase("Streamflow") ||
		data_type.equalsIgnoreCase("Temp") ||
		data_type.equalsIgnoreCase("WatTemp") ||
		data_type.equalsIgnoreCase("WellLevel"))) {
		// Data units must be set from data records.
		ts.setInputName ( "HydroBase RT_meas.amt");
		Message.printStatus ( 2, routine,
		"Reading from meas_num" + mt_meas_num +
		" for " + req_date1 + " to " + req_date2);
		// XJTSX 
		// nothing to read realtime for wells?

		v = readRTMeasList(mt_meas_num, req_date1, req_date2,
			true, false);
	}

	// Now set the returned data dates, which will be used further below...

	int size = 0;
	if (v != null) {
		size = v.size();
	}

	// If no data, return the TS because there are no data to set dates.
	// The header will be complete other than dates but no data will be
	// filled in.  The following code is roughly in alphabetical order with
	// realtime data at the end.

	Message.printStatus ( 2, routine,
	"Read " + size + " records for time series " + tsident_string);
	if (size == 0) {
		return ts;
	}

	DateTime data_date1 = null;	// Starting date/time from data records.
	DateTime data_date2 = null;	// Ending date/time from data records.
					// Note that the db_DateTime* values
					// set above should be used for original
					// dates if available.
	boolean has_data_flags = false;	// Indicate whether data flags should
					// be managed in memory.

	if ((interval_base == TimeInterval.MONTH) &&
		(data_type.equalsIgnoreCase("AdminFlow") ||
		data_type.equalsIgnoreCase("AdminFlowMax") ||
		data_type.equalsIgnoreCase("AdminFlowMin"))) {
		// Get the first and last dates...
		HydroBase_MonthlyFlow data = (HydroBase_MonthlyFlow)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data = (HydroBase_MonthlyFlow)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("AdminFlow")) {
		// Get the first and last dates...
		HydroBase_DailyTS data =
			(HydroBase_DailyTS)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_DAY);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data_date1.setDay ( 1);
		data = (HydroBase_DailyTS)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_DAY);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
		data_date2.setDay ( TimeUtil.numDaysInMonth(data_date2));
	}
	else if (	(interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropArea")) {
		// Get the first and last dates...
		HydroBase_AgriculturalNASSCropStats data =
			(HydroBase_AgriculturalNASSCropStats)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date1.setYear ( data.getCal_year());
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		data = (HydroBase_AgriculturalNASSCropStats)v.elementAt(size-1);
		data_date2 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date2.setYear ( data.getCal_year());
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("CropAreaHarvested") ||
		data_type.equalsIgnoreCase("CropAreaPlanted"))) {
		// Get the first and last dates...
		HydroBase_AgriculturalCASSCropStats data =
			(HydroBase_AgriculturalCASSCropStats)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date1.setYear ( data.getCal_year());
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		data = (HydroBase_AgriculturalCASSCropStats)v.elementAt(size-1);
		data_date2 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date2.setYear ( data.getCal_year());
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("CropAreaAllIrrigation") ||
		data_type.equalsIgnoreCase("CropAreaDrip") ||
		data_type.equalsIgnoreCase("CropAreaFlood") ||
		data_type.equalsIgnoreCase("CropAreaFurrow") ||
		data_type.equalsIgnoreCase("CropAreaSprinkler"))) {
		// Get the first and last dates...
		if (getDatabaseVersion() < VERSION_20050701) {		
			HydroBase_StructureIrrigSummaryTS data =
				(HydroBase_StructureIrrigSummaryTS)
				v.elementAt(0);
			data_date1 = new DateTime ( DateTime.PRECISION_YEAR);
			data_date1.setYear ( data.getCal_year());
			// Set the units here also
			data = (HydroBase_StructureIrrigSummaryTS)v.elementAt(
				size - 1);
			data_date2 = new DateTime ( DateTime.PRECISION_YEAR);
			data_date2.setYear ( data.getCal_year());
		}
		else {
			HydroBase_StructureView data =
				(HydroBase_StructureView)v.elementAt(0);
			data_date1 = new DateTime ( DateTime.PRECISION_YEAR);
			data_date1.setYear ( data.getCal_year());
			// Set the units here also
			data = (HydroBase_StructureView)v.elementAt(size - 1);
			data_date2 = new DateTime ( DateTime.PRECISION_YEAR);
			data_date2.setYear ( data.getCal_year());
		}		
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		(data_type.equalsIgnoreCase("DivClass") ||
		data_type.equalsIgnoreCase("IDivClass")) ) {
		// Get the first and last dates...
		HydroBase_AnnualWC data =
			(HydroBase_AnnualWC)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date1.setYear ( data.getIrr_year() - 1);
		data_date1.setMonth ( 11);
		data = (HydroBase_AnnualWC)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date2.setYear ( data.getIrr_year());
		data_date2.setMonth ( 10);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("DivClass")) {
		// Get the first and last dates...
		HydroBase_DailyWC data =
			(HydroBase_DailyWC)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_DAY);
		data_date1.setYear ( data.getIrr_year() - 1);
		data_date1.setMonth ( 11);
		data_date1.setDay ( 1);
		data = (HydroBase_DailyWC)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_DAY);
		data_date2.setYear ( data.getIrr_year());
		data_date2.setMonth ( 10);
		data_date2.setDay ( TimeUtil.numDaysInMonth(data_date2));
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("DivClass") ||
		data_type.equalsIgnoreCase("IDivClass")) ) {
		// Get the first and last dates...
		HydroBase_AnnualWC data =
			(HydroBase_AnnualWC)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date1.setYear ( data.getIrr_year());
		data = (HydroBase_AnnualWC)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date2.setYear ( data.getIrr_year());
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("DivComment")) {
		// Get the first and last dates...
		HydroBase_DiversionComment data =
			(HydroBase_DiversionComment)v.elementAt(0);
		// Dates are typically Oct 31 of the irrigation year.
		// Therefore the year corresponds to the irrigation year.
		data_date1 = new DateTime(data.getComm_date());
		data_date1.setPrecision ( DateTime.PRECISION_YEAR);
		data = (HydroBase_DiversionComment)v.elementAt(size - 1);
		data_date2 = new DateTime(data.getComm_date());
		data_date2.setPrecision ( DateTime.PRECISION_YEAR);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		(data_type.equalsIgnoreCase("DivTotal")||
		data_type.equalsIgnoreCase("IDivTotal")) ) {
		// Get the first and last dates...
		HydroBase_AnnualAmt data =
			(HydroBase_AnnualAmt)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date1.setYear ( data.getIrr_year() - 1);
		data_date1.setMonth ( 11);
		data = (HydroBase_AnnualAmt)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date2.setYear ( data.getIrr_year());
		data_date2.setMonth ( 10);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("DivTotal")) {
		// Get the first and last dates...
		HydroBase_DailyAmt data =
			(HydroBase_DailyAmt)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_DAY);
		data_date1.setYear ( data.getIrr_year() - 1);
		data_date1.setMonth ( 11);
		data_date1.setDay ( 1);
		data = (HydroBase_DailyAmt)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_DAY);
		data_date2.setYear ( data.getIrr_year());
		data_date2.setMonth ( 10);
		data_date2.setDay ( TimeUtil.numDaysInMonth(data_date2));
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("DivTotal") ||
		data_type.equalsIgnoreCase("IDivTotal")) ) {
		// Get the first and last dates...
		HydroBase_AnnualAmt data =
			(HydroBase_AnnualAmt)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date1.setYear ( data.getIrr_year());
		data = (HydroBase_AnnualAmt)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date2.setYear ( data.getIrr_year());
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("EvapPan")) {
		// Get the first and last dates...
		HydroBase_MonthlyEvap data =
			(HydroBase_MonthlyEvap)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data = (HydroBase_MonthlyEvap)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("EvapPan")) {
		// Get the first and last dates...
		HydroBase_DailyTS data =
			(HydroBase_DailyTS)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_DAY);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data_date1.setDay ( 1);
		data = (HydroBase_DailyTS)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_DAY);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
		data_date2.setDay ( TimeUtil.numDaysInMonth(data_date2));
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("FrostDateF32F") ||
		data_type.equalsIgnoreCase("FrostDateF28F") ||
		data_type.equalsIgnoreCase("FrostDateL32S") ||
		data_type.equalsIgnoreCase("FrostDateL28S"))) {
		// Get the first and last dates...
		HydroBase_FrostDates data =
			(HydroBase_FrostDates)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date1.setYear ( data.getCal_year());
		data = (HydroBase_FrostDates)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date2.setYear ( data.getCal_year());
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("HumanPopulation") ) ) {
		// Get the first and last dates...
		HydroBase_CUPopulation data =
			(HydroBase_CUPopulation)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date1.setYear ( data.getCal_year());
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		data = (HydroBase_CUPopulation)v.elementAt(size-1);
		data_date2 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date2.setYear ( data.getCal_year());
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("LivestockHead") ) ) {
		// Get the first and last dates...
		HydroBase_AgriculturalCASSLivestockStats data =
			(HydroBase_AgriculturalCASSLivestockStats)
			v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date1.setYear ( data.getCal_year());
		ts.setDataUnitsOriginal ( ts.getDataUnits());
		data = (HydroBase_AgriculturalCASSLivestockStats)
			v.elementAt(size-1);
		data_date2 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date2.setYear ( data.getCal_year());
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("NaturalFlow")) {
		// Get the first and last dates...
		HydroBase_MonthlyNflow data =
			(HydroBase_MonthlyNflow)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data = (HydroBase_MonthlyNflow)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("Precip")) {
		// Get the first and last dates...
		HydroBase_MonthlyPcpn data =
			(HydroBase_MonthlyPcpn)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data = (HydroBase_MonthlyPcpn)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Precip")) {
		// Get the first and last dates...
		HydroBase_DailyPcpn data =
			(HydroBase_DailyPcpn)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_DAY);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data_date1.setDay ( 1);
		data = (HydroBase_DailyPcpn)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_DAY);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
		data_date2.setDay ( TimeUtil.numDaysInMonth(data_date2));
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		(data_type.equalsIgnoreCase("RelClass") ||
		data_type.equalsIgnoreCase("IRelClass")) ) {
		// Get the first and last dates...
		HydroBase_AnnualWC data =
			(HydroBase_AnnualWC)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date1.setYear ( data.getIrr_year() - 1);
		data_date1.setMonth ( 11);
		data = (HydroBase_AnnualWC)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date2.setYear ( data.getIrr_year());
		data_date2.setMonth ( 10);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("RelClass")) {
		// Get the first and last dates...
		HydroBase_DailyWC data =
			(HydroBase_DailyWC)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_DAY);
		data_date1.setYear ( data.getIrr_year() - 1);
		data_date1.setMonth ( 11);
		data_date1.setDay ( 1);
		data = (HydroBase_DailyWC)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_DAY);
		data_date2.setYear ( data.getIrr_year());
		data_date2.setMonth ( 10);
		data_date2.setDay ( TimeUtil.numDaysInMonth(data_date2));
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("RelClass") ||
		data_type.equalsIgnoreCase("IRelClass")) ) {
		// Get the first and last dates...
		HydroBase_AnnualWC data =
			(HydroBase_AnnualWC)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date1.setYear ( data.getIrr_year());
		data = (HydroBase_AnnualWC)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date2.setYear ( data.getIrr_year());
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		(data_type.equalsIgnoreCase("RelTotal") ||
		data_type.equalsIgnoreCase("IRelTotal")) ) {
		// Get the first and last dates...
		HydroBase_AnnualAmt data =
			(HydroBase_AnnualAmt)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date1.setYear ( data.getIrr_year() - 1);
		data_date1.setMonth ( 11);
		data = (HydroBase_AnnualAmt)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date2.setYear ( data.getIrr_year());
		data_date2.setMonth ( 10);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("RelTotal")) {
		// Get the first and last dates...
		HydroBase_DailyAmt data =
			(HydroBase_DailyAmt)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_DAY);
		data_date1.setYear ( data.getIrr_year() - 1);
		data_date1.setMonth ( 11);
		data_date1.setDay ( 1);
		data = (HydroBase_DailyAmt)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_DAY);
		data_date2.setYear ( data.getIrr_year());
		data_date2.setMonth ( 10);
		data_date2.setDay ( TimeUtil.numDaysInMonth(data_date2));
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("RelTotal") ||
		data_type.equalsIgnoreCase("IRelTotal")) ) {
		// Get the first and last dates...
		HydroBase_AnnualAmt data =
			(HydroBase_AnnualAmt)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date1.setYear ( data.getIrr_year());
		data = (HydroBase_AnnualAmt)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date2.setYear ( data.getIrr_year());
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("ResEOM")) {
		// Get the first and last dates...
		HydroBase_ResEOM data =
			(HydroBase_ResEOM)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data = (HydroBase_ResEOM)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("ResEOY")) {
		// Get the first and last dates...
		HydroBase_AnnualRes data =
			(HydroBase_AnnualRes)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date1.setYear ( data.getIrr_year());
		data = (HydroBase_AnnualRes)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_YEAR);
		data_date2.setYear ( data.getIrr_year());
	}
	else if ((interval_base == TimeInterval.DAY) &&
		(data_type.equalsIgnoreCase("ResMeasElev") ||
		data_type.equalsIgnoreCase ( "ResMeasEvap" ) ||
		data_type.equalsIgnoreCase ( "ResMeasFill" ) ||
		data_type.equalsIgnoreCase ( "ResMeasRelease" ) ||
		data_type.equalsIgnoreCase ( "ResMeasStorage" ))) {
		// Get the first and last dates...
		HydroBase_ResMeas data =
			(HydroBase_ResMeas)v.elementAt(0);
		data_date1 = new DateTime ( data.getDate_time());
		data_date1.setPrecision ( DateTime.PRECISION_DAY);
		data = (HydroBase_ResMeas)v.elementAt(size - 1);
		data_date2 = new DateTime ( data.getDate_time());
		data_date2.setPrecision ( DateTime.PRECISION_DAY);
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("Snow")) {
		// Get the first and last dates...
		HydroBase_MonthlySnow data =
			(HydroBase_MonthlySnow)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data = (HydroBase_MonthlySnow)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Snow")) {
		// Get the first and last dates...
		HydroBase_DailyTS data =
			(HydroBase_DailyTS)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_DAY);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data_date1.setDay ( 1);
		data = (HydroBase_DailyTS)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_DAY);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
		data_date2.setDay ( TimeUtil.numDaysInMonth(data_date2));
	}
	else if ((interval_base == TimeInterval.DAY) &&
		(data_type.equalsIgnoreCase("SnowCourseDepth") ||
		data_type.equalsIgnoreCase("SnowCourseSWE"))) {
		// Get the first and last dates...
		HydroBase_SnowCrse data =
			(HydroBase_SnowCrse)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_DAY);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data_date1.setDay ( 1);
		data = (HydroBase_SnowCrse)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_DAY);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
		data_date2.setDay ( TimeUtil.numDaysInMonth(data_date2));
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Solar")) {
		// Get the first and last dates...
		HydroBase_DailyTS data =
			(HydroBase_DailyTS)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_DAY);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data_date1.setDay ( 1);
		data = (HydroBase_DailyTS)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_DAY);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
		data_date2.setDay ( TimeUtil.numDaysInMonth(data_date2));
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		(data_type.equalsIgnoreCase("Streamflow") ||
		data_type.equalsIgnoreCase("StreamflowMax") ||
		data_type.equalsIgnoreCase("StreamflowMin"))) {
		// Get the first and last dates...
		HydroBase_MonthlyFlow data =
			(HydroBase_MonthlyFlow)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data = (HydroBase_MonthlyFlow)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Streamflow")) {
		// Get the first and last dates...
		HydroBase_DailyTS data =
			(HydroBase_DailyTS)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_DAY);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data_date1.setDay ( 1);
		data = (HydroBase_DailyTS)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_DAY);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
		data_date2.setDay ( TimeUtil.numDaysInMonth(data_date2));
	}
	else if ((interval_base == TimeInterval.DAY) &&
		(data_type.equalsIgnoreCase("TempMax") ||
		data_type.equalsIgnoreCase("TempMin"))) {
		// Get the first and last dates...
		HydroBase_DailyTS data =
			(HydroBase_DailyTS)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_DAY);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data_date1.setDay ( 1);
		data = (HydroBase_DailyTS)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_DAY);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
		data_date2.setDay ( TimeUtil.numDaysInMonth(data_date2));
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		(data_type.equalsIgnoreCase("TempMean") ||
		data_type.equalsIgnoreCase("TempMeanMax") ||
		data_type.equalsIgnoreCase("TempMeanMin"))) {
		// Get the first and last dates...
		HydroBase_MonthlyTemp data =
			(HydroBase_MonthlyTemp)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data = (HydroBase_MonthlyTemp)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_MONTH);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("VaporPressure")) {
		// Get the first and last dates...
		HydroBase_DailyTS data =
			(HydroBase_DailyTS)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_DAY);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data_date1.setDay ( 1);
		data = (HydroBase_DailyTS)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_DAY);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
		data_date2.setDay ( TimeUtil.numDaysInMonth(data_date2));
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("WellLevel")) {
		// Get the first and last dates...
		HydroBase_WellMeas data =
			(HydroBase_WellMeas)v.elementAt(0);
		data_date1 = new DateTime ( data.getMeas_date());
		data_date1.setPrecision ( DateTime.PRECISION_DAY);
		data = (HydroBase_WellMeas)v.elementAt(size - 1);
		data_date2 = new DateTime ( data.getMeas_date());
		data_date2.setPrecision ( DateTime.PRECISION_DAY);
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Wind")) {
		// Get the first and last dates...
		HydroBase_DailyTS data =
			(HydroBase_DailyTS)v.elementAt(0);
		data_date1 = new DateTime ( DateTime.PRECISION_DAY);
		data_date1.setYear ( data.getCal_year());
		data_date1.setMonth ( data.getCal_mon_num());
		data_date1.setDay ( 1);
		data = (HydroBase_DailyTS)v.elementAt(size - 1);
		data_date2 = new DateTime ( DateTime.PRECISION_DAY);
		data_date2.setYear ( data.getCal_year());
		data_date2.setMonth ( data.getCal_mon_num());
		data_date2.setDay ( TimeUtil.numDaysInMonth(data_date2));
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.regionMatches(true,0,"WIS",0,3)) {
		// Get the first and last dates...
		HydroBase_WISData data =
			(HydroBase_WISData)v.elementAt(0);
		data_date1 = new DateTime ( data.getSet_date(),
			DateTime.PRECISION_DAY);
		data = (HydroBase_WISData)v.elementAt(size - 1);
		data_date2 = new DateTime ( data.getSet_date(),
			DateTime.PRECISION_DAY);
	}
	// Real-time data...
	else if ((interval_base == TimeInterval.IRREGULAR) &&
		(data_type.equalsIgnoreCase("AdminFlow") ||
		data_type.equalsIgnoreCase("Battery") ||
		data_type.equalsIgnoreCase("PoolElev") ||
		data_type.equalsIgnoreCase("Precip") ||
		data_type.equalsIgnoreCase("Release") ||
		data_type.equalsIgnoreCase("Stage") ||
		data_type.equalsIgnoreCase("Storage") ||
		data_type.equalsIgnoreCase("Streamflow") ||
		data_type.equalsIgnoreCase("Temp") ||
		data_type.equalsIgnoreCase("WatTemp") ||
		data_type.equalsIgnoreCase("WellLevel"))) {
		// Get the first and last dates...
		HydroBase_RTMeas data =
			(HydroBase_RTMeas)v.elementAt(0);
		data_date1 = new DateTime ( data.getDate_time());
		data_date1.setPrecision ( DateTime.PRECISION_MINUTE);
		data = (HydroBase_RTMeas)v.elementAt(size - 1);
		data_date2 = new DateTime ( data.getDate_time());
		data_date2.setPrecision ( DateTime.PRECISION_MINUTE);
		// Units are found here also...
		ts.setDataUnits ( data.getUnit());
		ts.setDataUnitsOriginal ( data.getUnit());
	}

	// Set the start and end dates and allocate memory...

	if ((req_date1 != null) && (req_date2 != null)) {
		// Allocate the memory regardless of whether there was data.  If
		// no data have been found then missing data will be
		// initialized...
		//
		// The original dates may be unknown so use the requested
		// dates.
		ts.setDate1(req_date1);
		if (db_DateTime1 == null) {
			ts.setDate1Original(req_date1);
		}
		ts.setDate2(req_date2);
		if (db_DateTime2 == null) {
			ts.setDate2Original(req_date2);
		}
	}
	else {
		// Set the date from the records...
		ts.setDate1(new DateTime(data_date1));
		if (db_DateTime1 == null) {
			ts.setDate1Original(new DateTime(data_date1));
		}
		ts.setDate2(new DateTime(data_date2));
		if (db_DateTime2 == null) {
			ts.setDate2Original(new DateTime(data_date2));
		}
	}
    
    // Allocate the data space for the time series.  If data flags are used, the information will
    // have been specified above.
	ts.allocateDataSpace();

	// Now transfer the data records into the time series.  This depends on
	// the type of record.

	DateTime date = new DateTime ( ts.getDate1());
	double value = 0.0;	// Data value being transferred.
	int iday = 0;		// Index for days.
	int ndays = 0;		// Number of days in a month.
	
	// The following is alphabetized by the data type as close as
	// convenient.  All real-time data types are at the bottom and share
	// code...

	if ((interval_base == TimeInterval.MONTH) &&
			data_type.equalsIgnoreCase("AdminFlow")) {
			HydroBase_MonthlyFlow data;
			for ( int i = 0; i < size; i++) {
				// Loop through and assign the data...
				data = (HydroBase_MonthlyFlow)v.elementAt(i);
				date.setYear ( data.getCal_year());
				date.setMonth ( data.getCal_mon_num());
				value = data.getTotal_q_af();
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
		else if ((interval_base == TimeInterval.DAY) &&
			data_type.equalsIgnoreCase("AdminFlow")) {
			HydroBase_DailyTS data;
			// Loop through each month...
			for ( int i = 0; i < size; i++) {
				// Loop through and assign the data...
				data = (HydroBase_DailyTS)v.elementAt(i);
				date.setYear ( data.getCal_year());
				date.setMonth ( data.getCal_mon_num());
				ndays = TimeUtil.numDaysInMonth ( date);
				for ( iday = 1; iday <= ndays; iday++) {
					date.setDay ( iday);
					value = data.getDay ( iday);
					//Message.printStatus ( 2, routine,
					//"Date:  " + date + " value: " + value);
					if (!DMIUtil.isMissing(value)) {
						ts.setDataValue ( date, value);
					}
				}
			}
		}
		else if ((interval_base == TimeInterval.MONTH) &&
			data_type.equalsIgnoreCase("AdminFlowMax")) {
			HydroBase_MonthlyFlow data;
			for ( int i = 0; i < size; i++) {
				// Loop through and assign the data...
				data = (HydroBase_MonthlyFlow)v.elementAt(i);
				date.setYear ( data.getCal_year());
				date.setMonth ( data.getCal_mon_num());
				value = data.getMax_q_cfs();
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
		else if ((interval_base == TimeInterval.MONTH) &&
			data_type.equalsIgnoreCase("AdminFlowMin")) {
			HydroBase_MonthlyFlow data;
			for ( int i = 0; i < size; i++) {
				// Loop through and assign the data...
				data = (HydroBase_MonthlyFlow)v.elementAt(i);
				date.setYear ( data.getCal_year());
				date.setMonth ( data.getCal_mon_num());
				value = data.getMin_q_cfs();
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
	else if (	(interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropArea")) {
		HydroBase_AgriculturalNASSCropStats data;
		String flag;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data.  Only transfer data
			// that have a flag of "" or "0" since other flag values
			// indicate missing or problematic data...
			data = (HydroBase_AgriculturalNASSCropStats)
				v.elementAt(i);
			date.setYear ( data.getCal_year());
			value = data.getAg_amt();
			flag = data.getFlag();
			if (	(flag.length() == 0) || flag.equals("0") &&
				!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropAreaHarvested")) {
		HydroBase_AgriculturalCASSCropStats data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_AgriculturalCASSCropStats)
				v.elementAt(i);
			date.setYear ( data.getCal_year());
			value = data.getHarvested();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropAreaPlanted")) {
		HydroBase_AgriculturalCASSCropStats data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_AgriculturalCASSCropStats)
				v.elementAt(i);
			date.setYear ( data.getCal_year());
			value = data.getPlanted();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropAreaAllIrrigation")) {
		if (getDatabaseVersion() < VERSION_20050701) {		
			HydroBase_StructureIrrigSummaryTS data;
			for ( int i = 0; i < size; i++) {
				// Loop through and assign the data...
				data = (HydroBase_StructureIrrigSummaryTS)
				v.elementAt(i);
				date.setYear ( data.getCal_year());
				value = data.getAcres_total();
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
		else {
			HydroBase_StructureView data;
			for ( int i = 0; i < size; i++) {
				// Loop through and assign the data...
				data = (HydroBase_StructureView)
				v.elementAt(i);
				date.setYear ( data.getCal_year());
				value = data.getAcres_total();
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}		
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropAreaDrip")) {
		if (getDatabaseVersion() < VERSION_20050701) {		
			HydroBase_StructureIrrigSummaryTS data;
			for ( int i = 0; i < size; i++) {
				// Loop through and assign the data...
				data = (HydroBase_StructureIrrigSummaryTS)
				v.elementAt(i);
				date.setYear ( data.getCal_year());
				value = data.getAcres_by_drip();
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
		else {
			HydroBase_StructureView data;
			for ( int i = 0; i < size; i++) {
				// Loop through and assign the data...
				data = (HydroBase_StructureView)
				v.elementAt(i);
				date.setYear ( data.getCal_year());
				value = data.getAcres_by_drip();
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}		
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropAreaFlood")) {
		if (getDatabaseVersion() < VERSION_20050701) {		
			HydroBase_StructureIrrigSummaryTS data;
			for ( int i = 0; i < size; i++) {
				// Loop through and assign the data...
				data = (HydroBase_StructureIrrigSummaryTS)
				v.elementAt(i);
				date.setYear ( data.getCal_year());
				value = data.getAcres_by_flood();
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
		else {
			HydroBase_StructureView data;
			for ( int i = 0; i < size; i++) {
				// Loop through and assign the data...
				data = (HydroBase_StructureView)
				v.elementAt(i);
				date.setYear ( data.getCal_year());
				value = data.getAcres_by_flood();
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropAreaFurrow")) {
		if (getDatabaseVersion() < VERSION_20050701) {		
			HydroBase_StructureIrrigSummaryTS data;
			for ( int i = 0; i < size; i++) {
				// Loop through and assign the data...
				data = (HydroBase_StructureIrrigSummaryTS)
				v.elementAt(i);
				date.setYear ( data.getCal_year());
				value = data.getAcres_by_furrow();
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
		else {
			HydroBase_StructureView data;
			for ( int i = 0; i < size; i++) {
				// Loop through and assign the data...
				data = (HydroBase_StructureView)
				v.elementAt(i);
				date.setYear ( data.getCal_year());
				value = data.getAcres_by_furrow();
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}		
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("CropAreaSprinkler")) {
		if (getDatabaseVersion() < VERSION_20050701) {		
			HydroBase_StructureIrrigSummaryTS data;
			for ( int i = 0; i < size; i++) {
				// Loop through and assign the data...
				data = (HydroBase_StructureIrrigSummaryTS)
				v.elementAt(i);
				date.setYear ( data.getCal_year());
				value = data.getAcres_by_sprinkler();
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
		else {
			HydroBase_StructureView data;
			for ( int i = 0; i < size; i++) {
				// Loop through and assign the data...
				data = (HydroBase_StructureView)
				v.elementAt(i);
				date.setYear ( data.getCal_year());
				value = data.getAcres_by_sprinkler();
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}		
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		(data_type.equalsIgnoreCase("DivClass") ||
		data_type.equalsIgnoreCase("IDivClass") ||
		data_type.equalsIgnoreCase("IRelClass") ||
		data_type.equalsIgnoreCase("RelClass"))) {
		HydroBase_AnnualWC data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_AnnualWC)v.elementAt(i);
			date.setYear ( data.getIrr_year() -1);
			date.setMonth ( 11);
			value = data.getAmt_nov();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_dec();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_jan();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_feb();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_mar();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_apr();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_may();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_jun();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_jul();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_aug();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_sep();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_oct();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		(data_type.equalsIgnoreCase("DivClass") ||
		data_type.equalsIgnoreCase("RelClass"))) {
		HydroBase_DailyWC data;
		String obs;
		// Loop through each month...
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_DailyWC)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon());
			ndays = TimeUtil.numDaysInMonth ( date);
			for ( iday = 1; iday <= ndays; iday++) {
				date.setDay ( iday);
				value = data.getAmountForDay ( iday);
				obs = data.getObservationForDay ( iday);
				if (obs == null) {
					obs = "";
				}
				//Message.printStatus ( 2, routine,
				//"Date:  " + date + " value: " + value);
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value, obs, 1);
				}
			}
		}
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("DivClass") ||
		data_type.equalsIgnoreCase("IDivClass") ||
		data_type.equalsIgnoreCase("IRelClass") ||
		data_type.equalsIgnoreCase("RelClass"))) {
		HydroBase_AnnualWC data;
		String quality;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data - only interested
			// in the annual amount...
			data = (HydroBase_AnnualWC)v.elementAt(i);
			date.setYear ( data.getIrr_year());
			value = data.getAnn_amt();
			quality = data.getQuality();
			if (quality == null) {
				quality = "";
			}
			if (	!DMIUtil.isMissing(value) ||
				(quality.length() > 0)) {
				ts.setDataValue ( date, value, quality, 1);
			}
		}
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("DivComment")) {
		HydroBase_DiversionComment data;
		DateTime dt;
		String not_used;
		ts.addToComments (
		"Data from diversion_comment (year is irrigation year) ...");
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_DiversionComment)v.elementAt(i);
			dt = new DateTime(data.getComm_date());
			dt.setPrecision (DateTime.PRECISION_DAY);
			value = data.getAcres_irrig();
			not_used = data.getNot_used();
			if (not_used == null) {
				not_used = "";
			}
			// Only set if the data value or flag is not missing...
			if (	!DMIUtil.isMissing(value) ||
				(not_used.length() > 0)) {
				ts.setDataValue ( dt, value, not_used, 1);
			}
			// Always add to the time series comments...
			if (!DMIUtil.isMissing(value)) {
				ts.addToComments ( "" + dt.getYear() +
				" Not used=" +
				not_used + ", acres_irrig=" +
				StringUtil.formatString(value,"%.2f") +
				", comment=\"" + data.getDiver_comment() +"\"");
			}
			else {
				ts.addToComments ( "" + dt.getYear() +
				" Not used=" + not_used +
				", acres_irrig=, comment=\"" +
				data.getDiver_comment() +"\"");
			}
		}
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		(data_type.equalsIgnoreCase("DivTotal") ||
		data_type.equalsIgnoreCase("IDivTotal") ||
		data_type.equalsIgnoreCase("IRelTotal") ||
		data_type.equalsIgnoreCase("RelTotal"))) {
		HydroBase_AnnualAmt data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_AnnualAmt)v.elementAt(i);
			date.setYear ( data.getIrr_year() -1);
			date.setMonth ( 11);
			value = data.getAmt_nov();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_dec();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_jan();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_feb();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_mar();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_apr();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_may();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_jun();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_jul();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_aug();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_sep();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			date.addMonth(1);
			value = data.getAmt_oct();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		(data_type.equalsIgnoreCase("DivTotal") ||
		data_type.equalsIgnoreCase("RelTotal"))) {
		HydroBase_DailyAmt data;
		String obs;
		// Loop through each month...
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_DailyAmt)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon());
			ndays = TimeUtil.numDaysInMonth ( date);
			for ( iday = 1; iday <= ndays; iday++) {
				date.setDay ( iday);
				value = data.getAmountForDay ( iday);
				obs = data.getObservationForDay ( iday);
				if (obs == null) {
					obs = "";
				}
				//Message.printStatus ( 2, routine,
				//"Date:  " + date + " value: " + value);
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value, obs, 1);
				}
			}
		}
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		(data_type.equalsIgnoreCase("DivTotal") ||
		data_type.equalsIgnoreCase("IDivTotal") ||
		data_type.equalsIgnoreCase("IRelTotal") ||
		data_type.equalsIgnoreCase("RelTotal"))) {
		HydroBase_AnnualAmt data;
		String quality;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data - only interested
			// in the annual amount...
			data = (HydroBase_AnnualAmt)v.elementAt(i);
			date.setYear ( data.getIrr_year());
			value = data.getAnn_amt();
			quality = data.getQuality();
			if (quality == null) {
				quality = "";
			}
			if (	!DMIUtil.isMissing(value) ||
				(quality.length() > 0)) {
				ts.setDataValue ( date, value, quality, 1);
			}
		}
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("EvapPan")) {
		HydroBase_MonthlyEvap data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_MonthlyEvap)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			value = data.getTotal_evap();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("EvapPan")) {
		HydroBase_DailyTS data;
		// Loop through each month...
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_DailyTS)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			ndays = TimeUtil.numDaysInMonth ( date);
			for ( iday = 1; iday <= ndays; iday++) {
				date.setDay ( iday);
				value = data.getDay ( iday);
				//Message.printStatus ( 2, routine,
				//"Date:  " + date + " value: " + value);
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("FrostDateL28S")) {
		HydroBase_FrostDates data;
		Date date2;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_FrostDates)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date2 = data.getL28s();
			if (date2 != null) {
				ts.setDataValue ( date,
				(double)TimeUtil.dayOfYear(
				new DateTime(date2)));
			}
		}
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("FrostDateL32S")) {
		HydroBase_FrostDates data;
		Date date2;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_FrostDates)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date2 = data.getL32s();
			if (date2 != null) {
				ts.setDataValue ( date,
				(double)TimeUtil.dayOfYear(
				new DateTime(date2)));
			}
		}
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("FrostDateF32F")) {
		HydroBase_FrostDates data;
		Date date2;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_FrostDates)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date2 = data.getF32f();
			if (date2 != null) {
				ts.setDataValue ( date,
				(double)TimeUtil.dayOfYear(
				new DateTime(date2)));
			}
		}
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("FrostDateF28F")) {
		HydroBase_FrostDates data;
		Date date2;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_FrostDates)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date2 = data.getF28f();
			if (date2 != null) {
				ts.setDataValue ( date,
				(double)TimeUtil.dayOfYear(
				new DateTime(date2)));
			}
		}
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("HumanPopulation")) {
		HydroBase_CUPopulation data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_CUPopulation)v.elementAt(i);
			date.setYear ( data.getCal_year());
			value = (double)data.getPopulation();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("LivestockHead")) {
		HydroBase_AgriculturalCASSLivestockStats data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_AgriculturalCASSLivestockStats)
				v.elementAt(i);
			date.setYear ( data.getCal_year());
			value = (double)data.getHead();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("NaturalFlow")) {
		HydroBase_MonthlyNflow data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_MonthlyNflow)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			value = data.getTotal_q_af();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("Precip")) {
		HydroBase_MonthlyPcpn data;
		boolean units_set = false;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_MonthlyPcpn)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			value = data.getTotal_pcpn();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			if ( !units_set ) {
				ts.setDataUnits ( data.getUnit() );
				ts.setDataUnitsOriginal ( data.getUnit() );
				units_set = true;
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Precip")) {
		HydroBase_DailyPcpn data;
		String flag;
		boolean units_set = false;
		// Loop through each month...
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_DailyPcpn)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			ndays = TimeUtil.numDaysInMonth ( date);
			for ( iday = 1; iday <= ndays; iday++) {
				date.setDay ( iday);
				value = data.getDay ( iday);
				flag = data.getFlaga ( iday);
				if (flag == null) {
					flag = "";
				}
				//Message.printStatus ( 2, routine,
				//"Date:  " + date + " value: " + value);
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value, flag, 1);
				}
				if ( !units_set ) {
					ts.setDataUnits ( data.getUnit() );
					ts.setDataUnitsOriginal(data.getUnit());
					units_set = true;
				}
			}
		}
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("ResEOM")) {
		HydroBase_ResEOM data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_ResEOM)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			value = data.getTotal_af();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.YEAR) &&
		data_type.equalsIgnoreCase("ResEOY")) {
		HydroBase_AnnualRes data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_AnnualRes)v.elementAt(i);
			date.setYear ( data.getIrr_year());
			value = data.getAnn_amt();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("ResMeasElev")) {
		HydroBase_ResMeas data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_ResMeas)v.elementAt(i);
			date = new DateTime ( data.getDate_time());
			date.setPrecision ( DateTime.PRECISION_DAY);
			value = data.getGage_height ();
			//Message.printStatus ( 2, routine,
			//"Date:  " + date + " value: " + value);
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("ResMeasEvap")) {
		HydroBase_ResMeas data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_ResMeas)v.elementAt(i);
			date = new DateTime ( data.getDate_time());
			date.setPrecision ( DateTime.PRECISION_DAY);
			value = data.getEvap_loss_amt ();
			//Message.printStatus ( 2, routine,
			//"Date:  " + date + " value: " + value);
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("ResMeasFill")) {
		HydroBase_ResMeas data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_ResMeas)v.elementAt(i);
			date = new DateTime ( data.getDate_time());
			date.setPrecision ( DateTime.PRECISION_DAY);
			value = data.getFill_amt ();
			//Message.printStatus ( 2, routine,
			//"Date:  " + date + " value: " + value);
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("ResMeasRelease")) {
		HydroBase_ResMeas data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_ResMeas)v.elementAt(i);
			date = new DateTime ( data.getDate_time());
			date.setPrecision ( DateTime.PRECISION_DAY);
			value = data.getRelease_amt ();
			//Message.printStatus ( 2, routine,
			//"Date:  " + date + " value: " + value);
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("ResMeasStorage")) {
		HydroBase_ResMeas data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_ResMeas)v.elementAt(i);
			date = new DateTime ( data.getDate_time());
			date.setPrecision ( DateTime.PRECISION_DAY);
			value = data.getStorage_amt ();
			//Message.printStatus ( 2, routine,
			//"Date:  " + date + " value: " + value);
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("Snow")) {
		HydroBase_MonthlySnow data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_MonthlySnow)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			value = data.getTotal_snow();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Snow")) {
		HydroBase_DailyTS data;
		// Loop through each month...
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_DailyTS)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			ndays = TimeUtil.numDaysInMonth ( date);
			for ( iday = 1; iday <= ndays; iday++) {
				date.setDay ( iday);
				value = data.getDay ( iday);
				//Message.printStatus ( 2, routine,
				//"Date:  " + date + " value: " + value);
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("SnowCourseDepth")) {
		HydroBase_SnowCrse data;
		String day;
		// Data records are monthly but data are actually daily...
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_SnowCrse)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			day = data.getDay();
			if (!StringUtil.isInteger(day)) {
				continue;
			}
			date.setDay ( StringUtil.atoi(day));
			value = data.getDepth ();
			//Message.printStatus ( 2, routine,
			//"Date:  " + date + " value: " + value);
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("SnowCourseSWE")) {
		HydroBase_SnowCrse data;
		String day;
		// Data records are monthly but data are actually daily...
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_SnowCrse)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			day = data.getDay();
			if (!StringUtil.isInteger(day)) {
				continue;
			}
			date.setDay ( StringUtil.atoi(day));
			value = data.getSwe ();
			//Message.printStatus ( 2, routine,
			//"Date:  " + date + " value: " + value);
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Solar")) {
		HydroBase_DailyTS data;
		// Loop through each month...
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_DailyTS)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			ndays = TimeUtil.numDaysInMonth ( date);
			for ( iday = 1; iday <= ndays; iday++) {
				date.setDay ( iday);
				value = data.getDay ( iday);
				//Message.printStatus ( 2, routine,
				//"Date:  " + date + " value: " + value);
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("Streamflow")) {
		HydroBase_MonthlyFlow data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_MonthlyFlow)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			value = data.getTotal_q_af();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Streamflow")) {
		HydroBase_DailyTS data;
		// Loop through each month...
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_DailyTS)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			ndays = TimeUtil.numDaysInMonth ( date);
			for ( iday = 1; iday <= ndays; iday++) {
				date.setDay ( iday);
				value = data.getDay ( iday);
				//Message.printStatus ( 2, routine,
				//"Date:  " + date + " value: " + value);
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("StreamflowMax")) {
		HydroBase_MonthlyFlow data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_MonthlyFlow)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			value = data.getMax_q_cfs();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("StreamflowMin")) {
		HydroBase_MonthlyFlow data;
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_MonthlyFlow)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			value = data.getMin_q_cfs();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("TempMean")) {
		HydroBase_MonthlyTemp data;
		boolean units_set = false;	// Units are in data records
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_MonthlyTemp)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			value = data.getMean_t();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			if ( !units_set ) {
				ts.setDataUnits ( data.getUnit() );
				ts.setDataUnitsOriginal(data.getUnit());
				units_set = true;
			}
		}
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("TempMeanMax")) {
		HydroBase_MonthlyTemp data;
		boolean units_set = false;	// Units are in data records
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_MonthlyTemp)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			value = data.getAvg_max_t();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			if ( !units_set ) {
				ts.setDataUnits ( data.getUnit() );
				ts.setDataUnitsOriginal(data.getUnit());
				units_set = true;
			}
		}
	}
	else if ((interval_base == TimeInterval.MONTH) &&
		data_type.equalsIgnoreCase("TempMeanMin")) {
		HydroBase_MonthlyTemp data;
		boolean units_set = false;	// Units are in data records
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_MonthlyTemp)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			value = data.getAvg_min_t();
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
			if ( !units_set ) {
				ts.setDataUnits ( data.getUnit() );
				ts.setDataUnitsOriginal(data.getUnit());
				units_set = true;
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		(data_type.equalsIgnoreCase("TempMax") ||
		data_type.equalsIgnoreCase("TempMin"))) {
		HydroBase_DailyTS data;
		boolean units_set = false;	// Units are in data records
		// Loop through each month...
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_DailyTS)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			ndays = TimeUtil.numDaysInMonth ( date);
			for ( iday = 1; iday <= ndays; iday++) {
				date.setDay ( iday);
				value = data.getDay ( iday);
				//Message.printStatus ( 2, routine,
				//"Date:  " + date + " value: " + value);
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
				if ( !units_set ) {
					ts.setDataUnits ( data.getUnit() );
					ts.setDataUnitsOriginal(data.getUnit());
					units_set = true;
				}
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("VaporPressure")) {
		HydroBase_DailyTS data;
		// Loop through each month...
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_DailyTS)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			ndays = TimeUtil.numDaysInMonth ( date);
			for ( iday = 1; iday <= ndays; iday++) {
				date.setDay ( iday);
				value = data.getDay ( iday);
				//Message.printStatus ( 2, routine,
				//"Date:  " + date + " value: " + value);
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("WellLevel")) {
		HydroBase_WellMeas data;
		double elevation = DMIUtil.MISSING_DOUBLE;
		// XJTSX
		boolean newFormat = false;
		if (well != null) {
			elevation = well.getElev();
			newFormat = true;
		}
		else {
		// XJTSX
			elevation = strView.getElevation();
		}
		if (DMIUtil.isMissing(elevation)) {
			ts.setDescription ( ts.getDescription() +
			" (no elevation datum)");
			elevation = 0.0;
		}
		else {
			ts.setDescription ( ts.getDescription() +
			" (datum " + StringUtil.formatString(elevation,"%.1f") +
			" FT)");
		}
		ts.addToGenesis (
			"Time series values = HydroBase geoloc.elevation - " +
			"well_meas.wat_level (" +
			StringUtil.formatString(elevation,"%.1f") + ")");

		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_WellMeas)v.elementAt(i);
			date = new DateTime ( data.getMeas_date());
			date.setPrecision ( DateTime.PRECISION_DAY);

			if (newFormat) {
				value = data.getWl_depth();
			}
			else {
				value = data.getWat_level();
			}
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, (elevation - value));
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.equalsIgnoreCase("Wind")) {
		HydroBase_DailyTS data;
		// Loop through each month...
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_DailyTS)v.elementAt(i);
			date.setYear ( data.getCal_year());
			date.setMonth ( data.getCal_mon_num());
			ndays = TimeUtil.numDaysInMonth ( date);
			for ( iday = 1; iday <= ndays; iday++) {
				date.setDay ( iday);
				value = data.getDay ( iday);
				//Message.printStatus ( 2, routine,
				//"Date:  " + date + " value: " + value);
				if (!DMIUtil.isMissing(value)) {
					ts.setDataValue ( date, value);
				}
			}
		}
	}
	else if ((interval_base == TimeInterval.DAY) &&
		data_type.regionMatches(true,0,"WIS",0,3)) {
		HydroBase_WISData data;
		// Figure out the column, to speed up code...
		int pos = 0;
		if (data_type.equalsIgnoreCase("WISPointFlow")) {
			pos = 0;
		}
		else if (data_type.equalsIgnoreCase("WISNaturalFlow")) {
			pos = 1;
		}
		else if (data_type.equalsIgnoreCase("WISDeliveryFlow")) {
			pos = 2;
		}
		else if (data_type.equalsIgnoreCase("WISGainLoss")) {
			pos = 3;
		}
		else if (data_type.equalsIgnoreCase("WISPriorityDiversion")) {
			pos = 4;
		}
		else if (data_type.equalsIgnoreCase("WISDeliveryDiversion")) {
			pos = 5;
		}
		else if (data_type.equalsIgnoreCase("WISRelease")) {
			pos = 6;
		}
		else if (data_type.equalsIgnoreCase("WISTribNatualFlow")) {
			pos = 7;
		}
		else if (data_type.equalsIgnoreCase("WISTribDeliveryFlow")) {
			pos = 8;
		}
		// Loop through each record...
		for ( int i = 0; i < size; i++) {
			// Loop through and assign the data...
			data = (HydroBase_WISData)v.elementAt(i);
			date = new DateTime ( data.getSet_date(),
				DateTime.PRECISION_DAY);
			if (pos == 0) {
				value = data.getPoint_flow ();
			}
			else if (pos == 1) {
				value = data.getNat_flow ();
			}
			else if (pos == 2) {
				value = data.getDelivery_flow ();
			}
			else if (pos == 3) {
				value = data.getGain ();
			}
			else if (pos == 4) {
				value = data.getPriority_divr ();
			}
			else if (pos == 5) {
				value = data.getDelivery_divr ();
			}
			else if (pos == 6) {
				value = data.getRelease ();
			}
			else if (pos == 7) {
				value = data.getTrib_natural ();
			}
			else if (pos == 8) {
				value = data.getTrib_delivery ();
			}
			//Message.printStatus ( 2, routine,
			//"Date:  " + date + " value: " + value);
			if (!DMIUtil.isMissing(value)) {
				ts.setDataValue ( date, value);
			}
		}
	}
	// Realtime data...
	else if ((interval_base == TimeInterval.IRREGULAR) &&
		(data_type.equalsIgnoreCase("AdminFlow") ||
		data_type.equalsIgnoreCase("Battery") ||
		data_type.equalsIgnoreCase("PoolElev") ||
		data_type.equalsIgnoreCase("Precip") ||
		data_type.equalsIgnoreCase("Release") ||
		data_type.equalsIgnoreCase("Stage") ||
		data_type.equalsIgnoreCase("Storage") ||
		data_type.equalsIgnoreCase("Streamflow") ||
		data_type.equalsIgnoreCase("Temp") ||
		data_type.equalsIgnoreCase("WatTemp") ||
		data_type.equalsIgnoreCase("WellLevel"))) {
		HydroBase_RTMeas data;
		for ( int i = 0; i < size; i++) {
			data = (HydroBase_RTMeas)v.elementAt(i);
			date = new DateTime ( data.getDate_time());
			date.setPrecision ( DateTime.PRECISION_MINUTE);
			// Set all data, even missing...
			ts.setDataValue (date, data.getAmt(), data.getFlag(),1);
		}
	}

	// Add to the genesis to explain where the time series were read from...

	ts.addToGenesis("Read HydroBase time series from " + ts.getDate1() +
		" to " + ts.getDate2() + ".");

	// Set the comments, consistent with previous CDSS work...
	// REVISIT (SAM) - this is somewhat redundant
	if (((mtsView != null)) && (staView != null)) {
		// Set comments for station data.  Some comments may have been
		// added above so manipulate to add at the end...

		// Get old comments so they can be added at the end...
		Vector old_header = ts.getComments();
		Vector header = new Vector ( 10, 5);
		header.add (
		"Station and time series information from HydroBase "+
		"determined at time of query:" );
		header.add (
		"Time series identifier         = " + ts.getIdentifierString());
		header.add (
		"Description                    = " + ts.getDescription());
		// The following may not work for older databases where
		// data_source was not packaged with the database...
		String data_source_desc = null;
		if (	isDatabaseVersionAtLeast(VERSION_20010326)) {
			data_source_desc = "";
		}
		else if (isDatabaseVersionAtLeast(VERSION_19990305)) {
			// Should limit to the main database until the Access
			// databases are updated...
			/* REVISIT (SAM)
			try {
				data_source_desc = HBDataSource.getComment (
					dmi, ts.getIdentifier().getSource());
			}
			catch ( Exception e) {
				// Just handled as null...
				data_source_desc = null;
			}
			*/
		}
		if (data_source_desc == null) {
			data_source_desc = "";
		}
		else if (!data_source_desc.equals ("")) {
			data_source_desc = " (" + data_source_desc + ")";
		}
		header.add(
		"Data source                    = "
		+ ts.getIdentifier().getSource() + data_source_desc);
		header.add (
		"Data type                      = "
		+ ts.getIdentifier().getType());
		header.add (
		"Data interval                  = "
		+ ts.getIdentifier().getInterval());
		header.add (
		"Data units                     = "
		+ ts.getDataUnits());
		if ((req_date1 != null) && (req_date2 != null)) {
			header.add (
			"HydroBase query period         = " +
			req_date1.toString() +
			" to " + req_date2.toString());
		}
		else {
			// Not available...
			header.add (
			"HydroBase query period         = Query All");
		}
		header.add (
			"HydroBase available period     = " +
			mt_start_year + " to " + mt_end_year);

		ts.setComments ( header);
		String abbrev = staView.getAbbrev();
		int wd = staView.getWD();
		int div = staView.getDiv();
		String county = staView.getCounty();
		String state = staView.getST();
		String huc = staView.getHUC();
		double latitude = staView.getLatdecdeg();
		double longitude = staView.getLongdecdeg();
		double drainage = staView.getDrain_area();
		double elevation = staView.getElevation();
		double contrib = staView.getContr_area();

		if (abbrev.length() > 0) {
			ts.addToComments (
			"State of CO abbreviation       = " + abbrev);
		}
		if (!DMIUtil.isMissing(wd) && !DMIUtil.isMissing(div)) {
			ts.addToComments (
			"Located in water div, district = " + div + ", " + wd);
		}
		else {
			ts.addToComments (
			"Located in water div, district = ");
		}
		if ((county != null) && (state != null)) {
			ts.addToComments (
			"Located in county, state       = " +
			county + ", " + state);
		}
		else {
			ts.addToComments (
			"Located in county, state       = ");
		}
		if ((huc != null) && (huc.length() > 0)) {
			ts.addToComments (
			"Located in HUC                 = " + huc);
		}
		else {
			ts.addToComments (
			"Located in HUC                 = ");
		}
		if (	!DMIUtil.isMissing(latitude) &&
			!DMIUtil.isMissing(longitude)) {
			ts.addToComments (
			"Latitude, longitude            = " +
			StringUtil.formatString(latitude,"%11.6f") + ", " +
			StringUtil.formatString(longitude,"%11.6f"));
		}
		else {
			ts.addToComments (
			"Latitude, longitude            = NA");
		}
		if (!DMIUtil.isMissing(drainage)) {
			ts.addToComments (
			"Drainage area                  = " +
			StringUtil.formatString(drainage,"%.2f") +
				" SQ MI");
		}
		else {
			ts.addToComments (
			"Drainage area                  = NA");
		}
		if (!DMIUtil.isMissing(contrib)) {
			ts.addToComments (
			"Non-natural contributing area  = " +
			StringUtil.formatString(contrib,"%.2f") +
			" SQ MI");
		}
		else {
			ts.addToComments (
			"Non-natural contributing area  = NA");
		}
		if (!DMIUtil.isMissing(elevation)) {
			ts.addToComments (
			"Elevation                      = " +
			StringUtil.formatString(elevation,"%.2f") +
				" FT");
		}
		else {
			ts.addToComments (
				"Elevation                      = NA");
		}

		// Add previous comments at the end, if any exist.  These are
		// notes about the data...

		if (old_header != null) {
			ts.addToComments ( "");
			size = old_header.size();
			for ( int i = 0; i < size; i++) {
				ts.addToComments (
				(String) old_header.elementAt(i));
			}
		}
	}
	else if (strView != null) {
		// Set comments for structure data.  Crop types will have a
		// null str_mt since they are not managed in struct_meas_type...
		// Get old comments so they can be added at the end...
		Vector old_header = ts.getComments();

		Vector header = new Vector ( 10, 5);
		header.add (
		"Structure and time series information from HydroBase...");
		header.add (
		"Time series identifier         = " +
		ts.getIdentifier().getIdentifier());
		header.add (
		"Description                    = " + ts.getDescription());
		header.add (
		"Data source                    = "
		+ ts.getIdentifier().getSource());
		header.add (
		"Data type                      = "
		+ ts.getIdentifier().getType());
		header.add (
		"Data interval                  = "
		+ ts.getIdentifier().getInterval());
		header.add (
		"Data units                     = " + ts.getDataUnits());
		if ((req_date1 != null) && (req_date2 != null)) {
			header.add (
			"HydroBase query period         = " +
			req_date1 + " to " + req_date2);
		}
		else {
			header.add (
			"Requested period               = Query All");
		}
		if (str_mt_v != null) {
			header.add(
				"HydroBase available period     = " 
				+ str_mt_v.getStart_year() + " to " 
				+ str_mt_v.getEnd_year());
		}
		else {
			header.add (
				"HydroBase available period     "
				+ "= UNKNOWN");
		}
	
		ts.setComments ( header);
		int wd = strView.getWD();
		int div = strView.getDiv();
		if (!DMIUtil.isMissing(wd) && !DMIUtil.isMissing(div)) {
			ts.addToComments (
			"Located in water div, district = " + div + ", " + wd);
		}
		else {
			ts.addToComments (
				"Located in water div, district = ");
		}
		ts.addToComments (
		"Located in county, state       = " +
		strView.getCounty() + ", " + strView.getST());
		ts.addToComments (
		"Located in HUC                 = " + strView.getHUC());
		double latitude = strView.getLatdecdeg();
		double longitude = strView.getLongdecdeg();
		if (	!DMIUtil.isMissing(latitude) &&
			!DMIUtil.isMissing(longitude)) {
			ts.addToComments (
			"Latitude, longitude            = " +
			StringUtil.formatString(latitude,"%11.6f") + ", " +
			StringUtil.formatString(longitude,"%11.6f"));
		}
		else {
			ts.addToComments (
			"Latitude, longitude            = ");
		}

		// Add previous comments at the end, if any exist.  These are
		// notes about the data...

		if (old_header != null) {
			ts.addToComments ( "");
			size = old_header.size();
			for ( int i = 0; i < size; i++) {
				ts.addToComments (
				(String) old_header.elementAt(i));
			}
		}
	}	
	// XJTSX
	else if (well != null) {
		// Set comments for structure data.  Crop types will have a
		// null str_mt since they are not managed in struct_meas_type...
		// Get old comments so they can be added at the end...
		Vector old_header = ts.getComments();

		Vector header = new Vector ( 10, 5);
		header.add (
		"Structure and time series information from HydroBase...");
		header.add (
		"Time series identifier         = " +
		ts.getIdentifier().getIdentifier());
		header.add (
		"Description                    = " + ts.getDescription());
		header.add (
		"Data source                    = "
		+ ts.getIdentifier().getSource());
		header.add (
		"Data type                      = "
		+ ts.getIdentifier().getType());
		header.add (
		"Data interval                  = "
		+ ts.getIdentifier().getInterval());
		header.add (
		"Data units                     = " + ts.getDataUnits());
		if ((req_date1 != null) && (req_date2 != null)) {
			header.add (
			"HydroBase query period         = " +
			req_date1 + " to " + req_date2);
		}
		else {
			header.add (
			"Requested period               = Query All");
		}
		if (str_mt_v != null) {
			header.add(
				"HydroBase available period     = " 
				+ str_mt_v.getStart_year() + " to " 
				+ str_mt_v.getEnd_year());
		}
		else {
			header.add (
				"HydroBase available period     "
				+ "= UNKNOWN");
		}
	
		ts.setComments ( header);
		int wd = well.getWD();
		int div = well.getDiv();
		if (!DMIUtil.isMissing(wd) && !DMIUtil.isMissing(div)) {
			ts.addToComments (
			"Located in water div, district = " + div + ", " + wd);
		}
		else {
			ts.addToComments (
				"Located in water div, district = ");
		}
		ts.addToComments (
			"Located in county, state       = " 
			+ well.getCounty() + ", " + "CO");
			//+ well.getST());
		ts.addToComments (
		"Located in HUC                 = " + well.getHUC());
		double latitude = well.getLatdecdeg();
		double longitude = well.getLongdecdeg();
		if (	!DMIUtil.isMissing(latitude) &&
			!DMIUtil.isMissing(longitude)) {
			ts.addToComments (
			"Latitude, longitude            = " +
			StringUtil.formatString(latitude,"%11.6f") + ", " +
			StringUtil.formatString(longitude,"%11.6f"));
		}
		else {
			ts.addToComments (
			"Latitude, longitude            = ");
		}

		// Add previous comments at the end, if any exist.  These are
		// notes about the data...

		if (old_header != null) {
			ts.addToComments ( "");
			size = old_header.size();
			for ( int i = 0; i < size; i++) {
				ts.addToComments (
				(String) old_header.elementAt(i));
			}
		}
	}	
	// XJTSX

	// For diversion time series, read additional data or autofill.  These
	// data will be considered as original data and will therefore be
	// included in original data limits.

	// Fill daily diversion data by carrying forward within irrigation
	// years...

	if (	(interval_base == TimeInterval.DAY) &&
		(data_type.equalsIgnoreCase("DivTotal") ||
		data_type.equalsIgnoreCase("DivClass") ||
		data_type.equalsIgnoreCase("RelTotal") ||
		data_type.equalsIgnoreCase("RelClass"))) {
		String FillDailyDiv = props.getValue ( "FillDailyDiv" );
		if ( (FillDailyDiv == null) || FillDailyDiv.equals("") ) {
			FillDailyDiv = "true";	// Default is to fill.
		}
		if ( FillDailyDiv.equalsIgnoreCase("true") ) {
			String FillDailyDivFlag = props.getValue (
				"FillDailyDivFlag" );
			// REVISIT SAM 2006-04-25
			// This throws an Exception.  Leave it for now but need
			// to evaluate how to handle errors..
			HydroBase_Util.fillTSIrrigationYearCarryForward (
					(DayTS)ts, FillDailyDivFlag );
		}
	}

	// Fill with diversion comments (after observations)...

	if (	((interval_base == TimeInterval.DAY) ||
		(interval_base == TimeInterval.MONTH) ||
		(interval_base == TimeInterval.YEAR)) &&
		(data_type.equalsIgnoreCase("DivTotal") ||
		data_type.equalsIgnoreCase("DivClass") ||
		data_type.equalsIgnoreCase("RelTotal") ||
		data_type.equalsIgnoreCase("RelClass"))) {
		String FillUsingDivComments =
			props.getValue ( "FillUsingDivComments" );
		if (	(FillUsingDivComments == null) ||
			FillUsingDivComments.equals("") ) {
			FillUsingDivComments = "false";
						// Default is NOT to fill.
		}
		if ( FillUsingDivComments.equalsIgnoreCase("true") ) {
			String FillUsingDivCommentsFlag = props.getValue (
				"FillUsingDivCommentsFlag" );
			// REVISIT SAM 2006-04-25
			// This throws an Exception.  Leave it for now but need
			// to evaluate how to handle errors..
			HydroBase_Util.fillTSUsingDiversionComments (
				this, ts, req_date1, req_date2,
				FillUsingDivCommentsFlag,
				true );	// Extend period if diversion comments
					// are available
		}
	}

	return ts;
}

/**
Reads the database for the data necessary to fill the table in the 
transact query GUI.  This method is called both for databases that use 
stored procedures and those that do not, and it handles calling SPFlex or
the readXXXList() method, as appropriate.
@param panel the panel of InputFilters that hold the query constraints.
@param districtWhere the value returned by getWaterDistrictWhereClause().
@param mapQueryLimits the GRLimits defining the geographical area for which
to query.
@return a Vector of HydroBase_Transact objects.
@throws Exception if there is an error running the query.
*/
public Vector readTransactList(InputFilter_JPanel panel, 
String[] districtWhere, GRLimits mapQueryLimits)
throws Exception {
	return readTransactList(panel, districtWhere, mapQueryLimits, -1);
}

/**
Reads the database for the data necessary to fill the table in the 
transact query GUI.  This method is called both for databases that use 
stored procedures and those that do not, and it handles calling SPFlex or
the readXXXList() method, as appropriate.
<p><b>Stored Procedures</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_Transact</li></ul>
@param panel the panel of InputFilters that hold the query constraints.
@param districtWhere the value returned by getWaterDistrictWhereClause().
@param mapQueryLimits the GRLimits defining the geographical area for which
to query.
@param type the type of report being generated (to know which order by clause
group to use).
@return a Vector of HydroBase_Transact objects.
@throws Exception if there is an error running the query.
*/
public Vector readTransactList(InputFilter_JPanel panel, 
String[] districtWhere, GRLimits mapQueryLimits, int type)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			panel, districtWhere);

		int orderNumber = 31;

		switch (type) {
			case HydroBase_Report_Transaction.STANDARD_1:
			case HydroBase_Report_Transaction.EXTENDED_1:
				orderNumber = 31;
				break;
			case HydroBase_Report_Transaction.STANDARD_2:
			case HydroBase_Report_Transaction.EXTENDED_2:
				orderNumber = 32;
				break;
			case HydroBase_Report_Transaction.STANDARD_3:
			case HydroBase_Report_Transaction.EXTENDED_3:
				orderNumber = 33;
				break;
			case HydroBase_Report_Transaction.STANDARD_4:
			case HydroBase_Report_Transaction.EXTENDED_4:
				orderNumber = 34;
				break;
			case HydroBase_Report_Transaction.STANDARD_5:
			case HydroBase_Report_Transaction.EXTENDED_5:
				orderNumber = 35;
				break;
			case HydroBase_Report_Transaction.STANDARD_6:
			case HydroBase_Report_Transaction.EXTENDED_6:
				orderNumber = 36;
				break;
			default:
				break;
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Transact"), orderNumber, 
			mapQueryLimits);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toTransactSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		Vector wheres 
			= HydroBase_GUI_Util.getWhereClausesFromInputFilter(
			this, panel, HydroBase_GUI_Util._TRANS_TABLE_NAME,
			HydroBase_GUI_Util.WATER_RIGHT);
		if (districtWhere != null) {
			wheres.add(districtWhere[0]);
		}

		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_TRANSACT);
		int size = wheres.size();
		for (int i = 0; i < size; i++) {
			q.addWhereClause(convertCounty(
				(String)wheres.elementAt(i)));
		}

		switch (type) {
			case HydroBase_Report_Transaction.STANDARD_1:
			case HydroBase_Report_Transaction.EXTENDED_1:
				q.addOrderByClause("transact.[id]");
				q.addOrderByClause("transact.admin_no");
				q.addOrderByClause("transact.trans_num");
				break;
			case HydroBase_Report_Transaction.STANDARD_2:
			case HydroBase_Report_Transaction.EXTENDED_2:
				q.addOrderByClause("transact.xwr_stream_no");
				q.addOrderByClause("transact.[id]");
				q.addOrderByClause("transact.admin_no");
				q.addOrderByClause("transact.trans_num");
				break;
			case HydroBase_Report_Transaction.STANDARD_3:
			case HydroBase_Report_Transaction.EXTENDED_3:
				q.addOrderByClause("transact.wr_name");
				q.addOrderByClause("transact.admin_no");
				q.addOrderByClause("transact.trans_num");
				break;
			case HydroBase_Report_Transaction.STANDARD_4:
			case HydroBase_Report_Transaction.EXTENDED_4:
				q.addOrderByClause("transact.ts");
				q.addOrderByClause("transact.rng");
				q.addOrderByClause("transact.sec");
				q.addOrderByClause("transact.q10");
				q.addOrderByClause("transact.q40");
				q.addOrderByClause("transact.q160");
				q.addOrderByClause("transact.trans_num");
				break;
			case HydroBase_Report_Transaction.STANDARD_5:
			case HydroBase_Report_Transaction.EXTENDED_5:
				q.addOrderByClause("transact.admin_no");
				q.addOrderByClause("transact.wr_name");
				q.addOrderByClause("transact.trans_num");
				break;
			case HydroBase_Report_Transaction.STANDARD_6:
			case HydroBase_Report_Transaction.EXTENDED_6:
				q.addOrderByClause("transact.xwr_stream_no");
				q.addOrderByClause("transact.admin_no");
				q.addOrderByClause("transact.[id]");
				q.addOrderByClause("transact.trans_num");
				break;
			default:
				q.addOrderByClause("transact.xwr_stream_no");
				q.addOrderByClause("transact.[id]");
				q.addOrderByClause("transact.admin_no");
				q.addOrderByClause("transact.trans_num");
				break;
		}
		
		ResultSet rs = dmiSelect(q);
		Vector v = toTransactList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the transact table for all data associated with a structure_num.<p>
This method is used by:<ul>
<li>HydroBase_Report_StructureSummary.submitWaterRightTransactionQuery()</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_Transact</li></ul>
@param structure_num the structure_num for which to return records.
@return a Vector of HydroBase_Transact objects.
@throws Exception if an error occurs.
*/
public Vector readTransactListForStructure_num(int structure_num) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		String[] triplet = new String[3];
		triplet[0] = "structure_num";
		triplet[1] = "EQ";
		triplet[2] = "" + structure_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
			
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Transact"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toTransactSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		q.addWhereClause("transact.structure_num = " + structure_num);
		buildSQL(q, __S_TRANSACT_FOR_STRUCTURE_NUM);
		ResultSet rs = dmiSelect(q);
		Vector v = toTransactList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Reads the TS Product table for the record that matches the specified identifier
and user_num.<p>
This is called by:<ul>
<li>HydroBaseDMI.deleteTSProductForIdentifier()</li>
<li>HydroBaseDMI.writeTSProduct()</li>
<li>HydroBase_GUI_SelectTSProduct.newClicked()</li>
<li>HydroBase_GUI_SelectTSProduct.openTSProduct()</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following stored procedures:<p><ul>
<li>vw_CDSS_TSProduct</li></ul>
@param identifier the identifier for which to search.
@param user_num the user_num for which to search.
@return a HydroBase_TSProduct object, or null if no matching records could be
found.
@throws Exception if an error occurs.
*/
public HydroBase_TSProduct readTSProductForIdentifier(String identifier, 
int user_num) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		String[] triplet = new String[3];
		triplet[0] = "identifier";
		triplet[1] = "MA";
		triplet[2] = identifier;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		triplet = new String[3];
		triplet[0] = "user_num";
		triplet[1] = "EQ";
		triplet[2] = "" + user_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
		
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_TSProduct"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toTSProductSPList(rs);
		closeResultSet(rs, __lastStatement);
		if (v == null || v.size() == 0) {
			return null;
		}
		else {
			return (HydroBase_TSProduct)v.elementAt(0);
		}
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_TSPRODUCT_FOR_IDENTIFIER);
	
		q.addWhereClause("TSProduct.identifier = '" + identifier + "'");
		q.addWhereClause("TSProduct.user_num = " + user_num);
	
		ResultSet rs = dmiSelect(q);
		Vector v = toTSProductList(rs);
		closeResultSet(rs);
	
		if (v == null || v.size() == 0) {
			return null;
		}
		else {
			return (HydroBase_TSProduct)v.elementAt(0);
		}
	}
}

public Vector readTSProductDMITSProductList(boolean newProduct) {
	try {
		return 
		      readTSProductListForTSProduct_numProductGroup_numUser_num(
			DMIUtil.MISSING_INT, DMIUtil.MISSING_INT, __userNum);
	}
	catch (Exception e) {
		Message.printWarning(2, "", 
			"Error reading time series.");
		Message.printWarning(2, "", e);
		return new Vector();
	}
}

/**
Reads the TS Product table for all records that matches the specified 
tsproduct_num, productgroup_num and user_num.<p>
This is called by:<ul>
<li>HydroBase_GUI_SelectTSProduct.readTSProducts()</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following stored procedures:<p><ul>
<li>vw_CDSS_TSProduct</li></ul>
@param tsproduct_num the tsproduct_num for which to search.  If not missing,
then productgroup_num MUST be missing.
@param productgroup_num the productgroup_num for which to search.  If not 
missing, then tsproduct_num MUST be missing.
@param user_num the user_num for which to search.
@return a Vector of matching HydroBase_TSProduct records.
@throws Exception if an error occurs.
*/
public Vector readTSProductListForTSProduct_numProductGroup_numUser_num(
int tsproduct_num, int productgroup_num, int user_num) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		if (!DMIUtil.isMissing(tsproduct_num)
		    && !DMIUtil.isMissing(productgroup_num)) {
		    	throw new Exception(
				"One and only one value can be non-missing."
				+ "  TSProduct_num: " + tsproduct_num 
				+ "  ProductGroup_num: " + productgroup_num);
		}
		else if (!DMIUtil.isMissing(tsproduct_num)) {
			String[] triplet = new String[3];
			triplet[0] = "tsproduct_num";
			triplet[1] = "EQ";
			triplet[2] = "" + tsproduct_num;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
		else if (!DMIUtil.isMissing(productgroup_num)) {
			String[] triplet = new String[3];
			triplet[0] = "productgroup_num";
			triplet[1] = "EQ";
			triplet[2] = "" + productgroup_num;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
		
		String[] triplet = new String[3];
		triplet[0] = "user_num";
		triplet[1] = "EQ";
		triplet[2] = "" + user_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
		
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_TSProduct"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toTSProductSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_TSPRODUCT);

		if (!DMIUtil.isMissing(tsproduct_num)
		    && !DMIUtil.isMissing(productgroup_num)) {
		    	throw new Exception(
				"One and only one value can be non-missing."
				+ "  TSProduct_num: " + tsproduct_num 
				+ "  ProductGroup_num: " + productgroup_num);
		}
		if (DMIUtil.isMissing(tsproduct_num)
		    && DMIUtil.isMissing(productgroup_num)) {
			// query for all
		}
		else if (!DMIUtil.isMissing(tsproduct_num)) {
			q.addWhereClause("TSProduct.tsproduct_num = " 
				+ tsproduct_num);
		}
		else {
			q.addWhereClause("TSProduct.productgroup_num = " 
				+ productgroup_num);
		}
	
		q.addWhereClause("TSProduct.user_num = " + user_num);
	
		ResultSet rs = dmiSelect(q);
		Vector v = toTSProductList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Reads the TS Product Props table for all records that matches the specified 
tsproduct_num.<p>
This is called by:<ul>
<li>HydroBase_GUI_SelectTSProduct.openTSProduct()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_TSProductProps_Sel_By_TSProduct_num</li>
</ul>
@param tsproduct_num the tsproduct_num to match props by.
@return a Vector of the matching HydroBase_TSProductProps records.
@throws Exception if an error occurs.
*/
public Vector readTSProductPropsListForTSProduct_num(int tsproduct_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_TSPRODUCTPROPS);
	if (tsproduct_num < 0) {
		throw new Exception("TSProduct_num (" + tsproduct_num + ") "
			+ "must be greater than -1");
	}
	q.addWhereClause("TSProductProps.tsproduct_num = " + tsproduct_num);
	ResultSet rs = dmiSelect(q);
	// checked the stored procedure
	Vector v = toTSProductPropsList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read a record from the unpermitted_wells table.<p>
<b>This method should only be used with pre-20050701 databases</b><p>
This is called by TSTool and HydroBase_Util.
This is called by:<ul>
<li>readTimeSeries</li>
<li>HydroBase_Util.addAlternateWellIdentifiers()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_Unpermitted_Wells</li></ul>
@return a HydroBase_StructureGeolocStructMeasTypeView object, with only the
unpermitted wells information filled in (no join to structure), or null if no
match is found.
@param structure_num If &gt; 0, a structure_num value to query for.  If missing,
will not be used.
@param usgs_id If not null, a usgs_id value to query for.
@param usbr_id If not null, a usbr_id value to query for.
@throws Exception if an error occurs.
*/
public HydroBase_GroundWaterWellsView readUnpermittedWells(
int structure_num, String usgs_id, String usbr_id) 
throws Exception {
	Vector v = null;

	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = null;
		if (!DMIUtil.isMissing(structure_num)) {
			triplet = new String[3];
			if (getDatabaseVersion() < VERSION_20050701) {
				triplet[0] = "structure_num";
			}
			else {
				triplet[1] = "well_num";
			}
			triplet[1] = "EQ";
			triplet[2] = "" + structure_num;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (usgs_id != null && usgs_id.length() > 0) {
			triplet = new String[3];
			triplet[0] = "usgs_id";
			triplet[1] = "MA";
			triplet[2] = usgs_id;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (usbr_id != null && usbr_id.length() > 0) {
			triplet = new String[3];
			triplet[0] = "usbr_id";
			triplet[1] = "MA";
			triplet[2] = usbr_id;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (getDatabaseVersion() < VERSION_20050701) {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber(
				"vw_CDSS_UnpermittedWellStructMeasType"), 
				0, null);
		}
		else {
			HydroBase_GUI_Util.fillSPParameters(parameters, 
				getViewNumber(
			    "vw_CDSS_GroundWaterWellsGroundWaterWellsMeasType"),
				83, null);
		}
		ResultSet rs = runSPFlex(parameters);
		v = toGroundWaterWellMeasTypeList(rs);
		closeResultSet(rs, __lastStatement);
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_UNPERMITTED_WELLS);
		if (!DMIUtil.isMissing(structure_num)) {
			q.addWhereClause("unpermitted_wells.structure_num = " 
				+ structure_num);
		}
		if ((usgs_id != null) && (usgs_id.length() > 0)) {
			q.addWhereClause("unpermitted_wells.usgs_id = '" 
				+ usgs_id + "'");
		}
		if ((usbr_id != null) && (usbr_id.length() > 0)) {
			q.addWhereClause("unpermitted_wells.usbr_id = '" 
				+ usbr_id + "'");
		}
		ResultSet rs = dmiSelect(q);
		v = toStructureUnpermittedWellsList(rs);
		closeResultSet(rs);
	}

	if ((v == null) || (v.size() == 0)) {
		return null;
	}
	else {
		return (HydroBase_GroundWaterWellsView)
			v.elementAt(0);
	}	
}

/**
Read the use table for all data.  Used in generating Water Rights reports.<p>
This method is used by:<ul>
<li>HydroBaseDMI.readGlobalData</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_refUse_Sel</li>
</ul>
@return a Vector of HydroBase_Use objects.
*/
public Vector readUseList() 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_USE);
	ResultSet rs = dmiSelect(q);
	Vector v = toUseList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the user_preferences table for all data and use the user_security table.<p>
This method is used by:<ul>
<li>HydroBaseDMI.readUserPreferencesPropList</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_UserPreferences_Sel_By_User_num</li>
</ul>
@param user_num the user_num for which to read preferences.
@return a Vector of HydroBase_UserPreferences objects.
@throws Exception if an error occurs.
*/
public Vector readUserPreferencesListForUser_num(int user_num)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_USER_PREFERENCES);
	q.addWhereClause("user_security.user_num = " + user_num);

	ResultSet rs = dmiSelect(q);
	Vector v = toUserPreferencesList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Reads user preferences from the database and loads them into an internal
proplist.
@param login the user application login to use for looking up user prefs.
@param password the password to use for looking up user prefs.
@throws Exception if the dmi connection is not open or is null, or if the 
method could not log in to the database due to a user name/password error.
*/
public void readUserPreferencesPropList(String login, String password)
throws Exception {
	String application = IOUtil.getProgramName();
	if (application.equalsIgnoreCase("StateView")) {
		// HydroBase properties for CWRAT and StateView are both stored
		// under the CWRAT application...
		application = "CWRAT";
	}
	HydroBase_UserSecurity us = readUserSecurityForLoginPasswordApplication(
		login, password, application);
	if (us == null) {
		// unsuccessful login
		throw new Exception ("Unable to read user security information "
			+ "for the specified user.");
	}		
	
	if (login.equalsIgnoreCase("guest")) {
		__isGuest = true;
	}
	else {
		__isGuest = false;
	}
	
	__userNum = us.getUser_num();
	__userSecurityPermissions = us.getPermissions();
		
	Vector v = readUserPreferencesListForUser_num(__userNum);
	
	if (v == null) {
		throw new Exception("Unable to read user preferences from "
			+ "database; HydroBaseDMI.readUserPreferencesList"
			+ "ForUser_numApplication() returned null.");
	}

	String pref = "";
	String prefValue = "";
	__prefsProps = new PropList(application + "UserPreferences.proplist");
	__prefsProps.setHowSet(Prop.SET_FROM_PERSISTENT);
	int size = v.size();
	for (int i = 0; i < size; i++) {
		HydroBase_UserPreferences up = 
			(HydroBase_UserPreferences)v.elementAt(i);
		pref = up.getPreference();
		prefValue = up.getPref_value();
		Prop prop = new Prop(pref, i, prefValue, 
			Prop.SET_FROM_PERSISTENT);
		__prefsProps.set(prop);
	}
	// Props added after this point will be setup with the following 
	// HOW-SET
	__prefsProps.setHowSet(Prop.SET_AT_RUNTIME_BY_USER);
}

/**
Read the user_security table for the user that matches the supplied parameters.
This method is used by:<ul>
<li>HydroBase_GUI_Options.changeClicked()</li>
<li>HydroBaseDMI.readUserPreferencesPropList</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_UserSecurity_Sel_By_Login_Password_Application</li>
</ul>
@param login the user login to read data for
@param password the password of the user.  
@param application the application for which to return data.
@return a HydroBase_UserSecurity object.
@throws Exception if an error occurs.
*/
public HydroBase_UserSecurity readUserSecurityForLoginPasswordApplication(
String login, String password, String application)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	// Turn off printing of the Stored Procedure or SQL string to 
	// Debug 30, for the sake of security. 
	__printQueryStrings = false;
	buildSQL(q, __S_USER_SECURITY);
	q.addWhereClause("user_security.login like '" + login + "'");
	q.addWhereClause("user_security.password like '" + password + "'");
	q.addWhereClause("user_security.application = '" + application + "'");
	ResultSet rs = dmiSelect(q);
	Vector v = toUserSecurityList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}

	// Turn back on printing of Stored Procedure or SQL strings to 
	// Debug 30.
	__printQueryStrings = true;

	if (v.size() != 0) {
		return (HydroBase_UserSecurity)v.elementAt(0);
	}
	else {
		return null;
	}
}

/**
Read the user_security table for the user that matches the supplied parameters.
This is called by:<ul>
<li>HydroBase_GUI_SelectTSProduct()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_UserSecurity_Sel_By_User_num</li>
</ul>	
@param user_num the user_num to search for
@return a HydroBase_UserSecurity object.
@throws Exception if an error occurs.
*/
public HydroBase_UserSecurity readUserSecurityForUser_num(int user_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	// Turn off printing of the Stored Procedure or SQL string to 
	// Debug 30, for the sake of security. 
	__printQueryStrings = false;
	buildSQL(q, __S_USER_SECURITY_FOR_USER_NUM);
	q.addWhereClause("user_security.user_num = " + user_num);

	ResultSet rs = dmiSelect(q);
	// checked the stored procedure
	Vector v = toUserSecurityList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}

	// Turn back on printing of Stored Procedure or SQL strings to 
	// Debug 30.
	__printQueryStrings = true;
	
	if (v.size() != 0) {
		return (HydroBase_UserSecurity)v.elementAt(0);
	}
	else {
		return null;
	}
}

/**
Read the water_district table for all data.<p>
This method is used by:<ul>
<li>HydroBaseDMI.readGlobalData()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_refWaterDistrict_Sel</li>
<li>usp_CDSS_refWaterDistrict_Sel_Div</li>
</ul>
@param byDivision if true, data is sorted by water district AND division.  If
false, it is just sorted by water district.
@return a Vector of HydroBase_WaterDistrict objects.
@throws Exception if an error occurs.
*/
public Vector readWaterDistrictList(boolean byDivision) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	if (byDivision) {
		buildSQL(q, __S_WATER_DISTRICT_BY_DIV);
		q.addOrderByClause("water_district.div");
	}
	else {
		buildSQL(q, __S_WATER_DISTRICT);
	}
	q.addOrderByClause("water_district.wd");
	ResultSet rs = dmiSelect(q);
	Vector v = toWaterDistrictList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the water_division table for all data.<p>
This method is used by:<ul>
<li>HydroBaseDMI.readGlobalData()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_refWaterDivision_Sel</li>
</ul>
@return a Vector of HydroBase_WaterDivision objects.
@throws Exception if an error occurs.
*/
public Vector readWaterDivisionList () 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_WATER_DIVISION);
	q.addOrderByClause("water_division.div");
	ResultSet rs = dmiSelect(q);
	Vector v = toWaterDivisionList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Queries the database for the WD and ID that match the given structure_num.<p>
This method is used by:<ul>
<li>HydroBase_Report_StructureSummary.HydroBase_Report_StructureSummary()</li>
</ul>
@param structure_num the structure_num for which to find WD and ID.
@return a two-cell array.  The first cell contains the WD and the second 
contains the ID.  If an error occurs or the structure_num does not match in 
the database, these cells will contain DMIUtil.MISSING_INT.
@throws Exception if an error occurs.
*/
public int[] readWDIDForStructure_num(int structure_num) 
throws Exception {
	if (__useSP) {
		HydroBase_StructureView view 
			= readStructureViewForStructure_num(structure_num);
		int[] wdid = new int[2];
		wdid[0] = view.getWD();
		wdid[1] = view.getID();
		return wdid;
	}
	else {
		HydroBase_Structure structure
			= readStructureForStructure_num(structure_num);
		int[] wdid = new int[2];
		wdid[0] = structure.getWD();
		wdid[1] = structure.getID();
		return wdid;
	}
}

/**
Reads the wd_water table for table that matches the given where and order 
clauses (if non-null), but does not join to the structure table.<p>
This method is used by:<ul>
<li>HydroBase_GUI_SetCall.structureListClicked()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_WDWater</li></ul>
Change this to return a Vector of _WDWater and not be named with all that
silly NoStructureJoin stuff.
@param wdwater_num the wdwater_num for which to query
@return a Vector HydroBase_WDWater objects.
@throws Exception if an error occurs.
*/
public Vector readWDWaterListForWDWater_num(int wdwater_num)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		String[] triplet = new String[3];
		triplet[0] = "wdwater_num";
		triplet[1] = "EQ";
		triplet[2] = "" + wdwater_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WDWater"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWDWaterSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WD_WATER_NO_STRUCTURE);
		q.addWhereClause("wdwater_num = " + wdwater_num);
		ResultSet rs = dmiSelect(q);
		Vector v = toWDWaterList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the well_application table for all data, using the geoloc table in the
where clause.<p>
This method is used by:<ul>
<li>HydroBase_NodeNetwork.setDescriptions</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_WellApplications</li></ul>
@return a Vector of HydroBase_WellApplication objects.
@throws Exception if an error occurs.
*/
public Vector readWellApplicationList(String permitno, 
String permitrpl, String permitsuf)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = null;
		if (permitno != null && permitno.length() > 0) {
			triplet = new String[3];
			triplet[0] = "permitno";
			triplet[1] = "MA";
			triplet[2] =  "" + permitno;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (permitrpl != null && permitrpl.length() > 0) {
			triplet = new String[3];
			triplet[0] = "permitrpl";
			triplet[1] = "MA";
			triplet[2] = "" + permitrpl;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (permitsuf != null && permitsuf.length() > 0) {
			triplet = new String[3];
			triplet[0] = "permitsuf";
			triplet[1] = "MA";
			triplet[2] = "" + permitsuf;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WellApplications"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWellApplicationSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);	
		buildSQL(q, __S_WELL_APPLICATION_VIEW);
		if (permitno != null && permitno.length() > 0) {
			q.addWhereClause("well_application.permitno = '" 
				+ permitno + "'");
		}
		if (permitsuf != null && permitsuf.length() > 0) {
			q.addWhereClause("well_application.permitsuf = '" 
				+ permitsuf + "'");
		}
		if (permitrpl != null && permitrpl.length() > 0) {
			q.addWhereClause("well_application.permitrpl = '" 
				+ permitrpl + "'");
		}
		ResultSet rs = dmiSelect(q);
		Vector v = toWellApplicationSPList(rs);
		closeResultSet(rs);
		return v;
	}	
}

/**
Read the well_application table for all data, using the geoloc table in the
where clause.<p>
This method is used by:<ul>
<li>HydroBase_NodeNetwork.setDescriptions</li>
</ul>
@param permitData a Vector of permit identifiers.
@return a Vector of HydroBase_WellApplication objects.
@throws Exception if an error occurs.
*/
public Vector readWellApplicationListForPermitData(Vector permitData) 
throws Exception {
	Vector results = new Vector();
	Object o;
	if (permitData != null) {
		boolean isPermit = false;
		int size = permitData.size();
		String 	compos,
			permitno = null,
			permitrpl = null,
			permitsuf = null,
			where = "";
		Vector v = null;
		for (int i = 0; i < size; i++) {
			if (i > 0) {
				where += " OR ";
			}
			isPermit = true;
			compos = (String)permitData.elementAt(i);
			if (compos.length() > 0) {
				// Check for invalid permit identifier...
				if (compos.charAt(0) == 'P') {
					v = StringUtil.breakStringList(
						compos.substring(1), "_", 0);
				}	
				else {
					v = StringUtil.breakStringList(
						compos, "_", 0);
				}
				
				if (v == null) {
					isPermit = false;
				}
			}
			else {
				isPermit = false;
			}
			
			if (isPermit) {
				// If there are any characters in the permit 
				// number, then do not query...
				permitno = "";
				permitsuf = "";
				permitrpl = "";
				if (v.size() > 0) {
					permitno = (String)v.elementAt(0);
				}
				if (v.size() > 1) {
					permitsuf = (String)v.elementAt(1);
				}
				if (v.size() > 2) {
					permitrpl = (String)v.elementAt(2);
				}
				if (!StringUtil.isInteger(permitno)) {
					isPermit = false;
				}
			}
			if (isPermit) {
				o = readWellApplicationList(permitno,
					permitsuf, permitrpl);
				if (o != null) {
					results.add(o);
				}
			}
		}
	}
	return results;
}

/**
Reads the database for the data necessary to fill the table in the 
well application query GUI.  This method is called both for databases that use 
stored procedures and those that do not, and it handles calling SPFlex or
the readXXXList() method, as appropriate.
<p><b>Stored Procedures</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_Well_Appplications</li></ul>
@param panel the panel of InputFilters that hold the query constraints.
@param districtWhere the value returned by getWaterDistrictWhereClause().
@param mapQueryLimits the GRLimits defining the geographical area for which
to query.
@return a Vector of HydroBase_WellApplication or HydroBase_WellApplicationView
Objects, depending on whether SPFlex was used or not.
@throws Exception if there is an error running the query.
*/
public Vector readWellApplicationGeolocList(InputFilter_JPanel panel, 
String[] districtWhere, GRLimits mapQueryLimits)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			panel, districtWhere);
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WellApplications"), 0, 
			mapQueryLimits);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWellApplicationSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		Vector orderBys 
			= HydroBase_GUI_Util.getOrderBysFromInputFilter_JPanel(
			panel, false);
		Vector wheres 
			= HydroBase_GUI_Util.getWhereClausesFromInputFilter(
			this, panel);
		if (districtWhere != null) {
			wheres.add(districtWhere[0]);
		}
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WELL_APPLICATION_VIEW);
		if (wheres != null) {
			int size = wheres.size();
			for (int i = 0; i < size; i++) {
				q.addWhereClause((String)wheres.elementAt(i));
			}
		}
		if (orderBys != null) {
			int size = orderBys.size();
			for (int i = 0; i < size; i++) {
				q.addOrderByClause(
					(String)orderBys.elementAt(i));
			}
		}	
		
		ResultSet rs = dmiSelect(q);
		Vector v = toWellApplicationSPList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the well_meas table for all data and join with data in structure and geoloc
where well_meas and structure share the same structure_num and structure and
geoloc share the same geoloc_num.<p>
This is used by readTimeSeries().
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_Well
@param meas_num the struct_meas_type.meas_num key for this time series.
@param req_date1 If not null, specify the start date for the query.
@param req_date2 If not null, specify the end date for the query.
@return a Vector of HydroBase_WellMeas objects.
@throws Exception if an error occurs.
*/
public Vector readWellMeasList(int meas_num, DateTime req_date1, 
DateTime req_date2) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);

		String[] triplet = null;
	
		if (getDatabaseVersion() < VERSION_20050701) {
			triplet = new String[3];
			triplet[0] = "meas_num";
			triplet[1] = "EQ";
			triplet[2] = "" + meas_num;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
		else {
			triplet = new String[3];
			triplet[0] = "well_meas_num";
			triplet[1] = "EQ";
			triplet[2] = "" + meas_num;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (req_date1 != null) {
			if (req_date1.getPrecision() ==DateTime.PRECISION_DAY) {
				triplet = new String[3];
				triplet[0] = "meas_date";
				triplet[1] = "GE";
				triplet[2] = "" + DMIUtil.formatDateTime(this,
					req_date1);
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);
			}
			else {
				DateTime req_date1_copy=new DateTime(req_date1);
				req_date1_copy.setPrecision(
					DateTime.PRECISION_DAY);
				req_date1_copy.setDay(1);
			
				triplet = new String[3];
				triplet[0] = "meas_date";
				triplet[1] = "GE";
				triplet[2] = "" + DMIUtil.formatDateTime(this,
					req_date1_copy);
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);			
			}
		}

		if (req_date2 != null) {
			if (req_date2.getPrecision() ==DateTime.PRECISION_DAY) {
				triplet = new String[3];
				triplet[0] = "meas_date";
				triplet[1] = "LE";
				triplet[2] = "" + DMIUtil.formatDateTime(this,
					req_date2);
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);			
			}
			else {
				DateTime req_date2_copy=new DateTime(req_date2);
				req_date2_copy.setPrecision( 
					DateTime.PRECISION_DAY);
				req_date2_copy.setDay(
					TimeUtil.numDaysInMonth(
					req_date2_copy));
			
				triplet = new String[3];
				triplet[0] = "meas_date";
				triplet[1] = "LE";
				triplet[2] = "" + DMIUtil.formatDateTime(this,
					req_date2_copy);
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);			
			}
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WellMeas"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWellMeasSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WELL_MEAS);
		q.addWhereClause("well_meas.meas_num=" + meas_num);
		if (req_date1 != null) {
			if (req_date1.getPrecision() 
				== DateTime.PRECISION_DAY) {
				q.addWhereClause("well_meas.meas_date >=" +
				DMIUtil.formatDateTime(this,req_date1));
			}
			else {
				DateTime req_date1_copy 
					= new DateTime ( req_date1);
				req_date1_copy.setPrecision ( 
					DateTime.PRECISION_DAY);
				req_date1_copy.setDay ( 1);
				q.addWhereClause("well_meas.meas_date >=" +
					DMIUtil.formatDateTime(this,
					req_date1_copy));
			}
		}
		if (req_date2 != null) {
			if (req_date2.getPrecision() 
				== DateTime.PRECISION_DAY) {
				q.addWhereClause("well_meas.meas_date <=" +
					DMIUtil.formatDateTime(this,req_date2));
			}
			else {
				DateTime req_date2_copy 
					= new DateTime ( req_date2);
				req_date2_copy.setPrecision ( 
					DateTime.PRECISION_DAY);
				req_date2_copy.setDay (
					TimeUtil.numDaysInMonth(
					req_date2_copy));
				q.addWhereClause("well_meas.meas_date <=" +
					DMIUtil.formatDateTime(this,
					req_date2_copy));
			}
		}
		q.addOrderByClause("well_meas.meas_date");
		ResultSet rs = dmiSelect(q);
		Vector v = toWellMeasList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the wells table for all data.<p>
This is called by:<ul>
<li>StateDMI</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_Wells</li>
@return a Vector of HydroBase_Wells objects.
@throws Exception if an error occurs.
*/
public Vector readWellsList() 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_Wells"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWellsSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WELLS);
		ResultSet rs = dmiSelect(q);
		Vector v = toWellsList(rs, __S_WELLS);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the wells and well_to_layer table for all data where the tables share
the same well_id. <p>
This is called by:<ul>
<li>StateDMI</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_WellsWellToLayer</li>
@return a Vector of HydroBase_Wells objects.
@throws Exception if an error occurs.
*/
public Vector readWellsWellToLayerList() 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WellsWellToLayer"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWellsWellToLayerSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WELLS_LAYER);
		ResultSet rs = dmiSelect(q);
		Vector v = toWellsList(rs, __S_WELLS_LAYER);
		closeResultSet(rs);
		return v;
	}
}

// REVISIT (SAM 2004-09-22) The HydroBase_Wells class is a join of all the well*
// table data.  This is OK for now since it such esoteric data; however, it does
// not follow the standard for classes for joined tables.
/**
Read the wells and well_to_parcel table for all data where the tables share
the same well_id.  Possibly use irrig_acre<p>
This is called by:<ul>
<li>StateDMI</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_WellsWellToParcel</li></ul>
@return a Vector of HydroBase_Wells objects.
--------------------
REVISIT (JTS - 2005-03-04)
change the following to use -999 instead of -1
--------------------
@param parcel_id If >= 0, the parcel_id will be used to filter the query.
@param cal_year If >= 0, the cal_year will be used to filter the query.
@param div If >= 0, the div will be used to filter the query.
@throws Exception if an error occurs.
*/
public Vector readWellsWellToParcelList(int parcel_id, int cal_year, int div) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = null;

		if (parcel_id != -1) {
			triplet = new String[3];
			triplet[0] = "parcel_id";
			triplet[1] = "EQ";
			triplet[2] = "" + parcel_id;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (cal_year != -1) {
			triplet = new String[3];
			triplet[0] = "cal_year";
			triplet[1] = "EQ";
			triplet[2] = "" + cal_year;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (div != -1) {
			triplet = new String[3];
			triplet[0] = "div";
			triplet[1] = "EQ";
			triplet[2] = "" + div;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		// REVISIT (JTS - 2005-02-16)
		// if set_date is provided, should sort on set_date DESC

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WellsWellToParcel"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWellsWellToParcelSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WELLS_PARCEL);
		if (parcel_id >= 0) {
			q.addWhereClause("well_to_parcel.parcel_id=" 
				+ parcel_id);
		}
		if (cal_year >= 0) {
			q.addWhereClause("well_to_parcel.cal_year=" + cal_year);
		}
		if (div >= 0) {
			q.addWhereClause("well_to_parcel.div=" + div);
		}
		ResultSet rs = dmiSelect(q);
		Vector v = toWellsList(rs, __S_WELLS_PARCEL);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the wells and well_to_structure table for all data where the tables share
the same well_id.<p>
This is called by:<ul>
<li>StateDMI</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_WellsWellToStructure</li></ul>
@return a Vector of HydroBase_Wells objects.
@throws Exception if an error occurs.
*/
public Vector readWellsWellToStructureList() 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WellsWellToStructure"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWellsWellToStructureSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WELLS_STRUCTURE);
		ResultSet rs = dmiSelect(q);
		Vector v = toWellsList(rs, __S_WELLS_STRUCTURE);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the wells, well_to_parcel, and well_to_structure table for all data where
the tables all share the same well_id.  Possibly use irrig_acre clause.<p>
This is called by:<ul>
<li>StateDMI</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_WellsWellToParcelWellToStructure</li></ul>
@return a Vector of HydroBase_Wells objects.
@throws Exception if an error occurs.
*/
public Vector readWellsWellToParcelWellToStructureList() 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber(
			"vw_CDSS_WellsWellToParcelWellToStructure"), 0, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWellsWellToParcelWellToStructureSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WELLS_PARCEL_STRUCTURE);
		ResultSet rs = dmiSelect(q);
		Vector v = toWellsList(rs, __S_WELLS_PARCEL_STRUCTURE);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the wis_comments table for all data that matches the given Vectors of
where and order by clauses.  Either can be null.<p>
This method is used by:<ul>
<li>HydroBase_GUI_LoadWIS.generateDates()</li>
<li>HydroBase_GUI_WISBuilder.getRecentFormatWISNum()</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_WISComments</li></ul>
@param wis_nums a Vector of wis_nums for which to query the database.  If null,
they will not be used.
@param set_date a date string preformatted with DMIUtil.formatDate().  If
null, it will not be used.
@return a Vector of HydroBase_WISComments objects.
@throws Exception if an error occurs.
*/
public Vector readWISCommentsList(Vector wis_nums, DateTime set_date)
throws Exception {
	if (wis_nums == null) {
		return readWISCommentsList(-999, set_date);
	}

	int size = wis_nums.size();
	int size2 = -1;
	int wis_num = -1;
	String s = null;
	Vector v = null;

	Vector results = new Vector();
	
	for (int i = 0; i < size; i++) {
		s = (String)wis_nums.elementAt(i);
		wis_num = StringUtil.atoi(s);
		v = readWISCommentsList(wis_num, set_date);
		size2 = v.size();
		for (int j = 0; j < size2; j++) {
			if (v.elementAt(j) != null) {
				results.add(v.elementAt(j));
			}
		}
	}
	return results;
}

/**
Read the wis_comments table for all data with the given wis_num and set_date.
This method is used by:<ul>
<li>HydroBase_GUI_WIS.loadWISData()</li>
<li>HydroBase_GUI_LoadWIS.getWISSheets()</li>
<li>HydroBase_GUI_LoadWIS.generateDates()</li>
<li>HydroBase_GUI_WISImportWizard.generateWISSheets()</li>
<li>HydroBase_GUI_WISDiversionCoding.viewHistoryClicked()</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_WISComments</li></ul>
@param wis_num the wis_num for which to read comments.  If -999, it will not
be used.
@param set_date a date string preformatted with DMIUtil.formatDate().  If
null, it will not be used.
@return a Vector of HydroBase_WISComments objects.
@throws Exception if an error occurs.
*/
public Vector readWISCommentsList(int wis_num, DateTime set_date) 
throws Exception {	
	return readWISCommentsList(wis_num, set_date, -1);
}

/**
Read the wis_comments table for all data with the given wis_num and set_date.
This method is used by:<ul>
<li>HydroBase_GUI_WIS.loadWISData()</li>
<li>HydroBase_GUI_LoadWIS.getWISSheets()</li>
<li>HydroBase_GUI_LoadWIS.generateDates()</li>
<li>HydroBase_GUI_WISImportWizard.generateWISSheets()</li>
<li>HydroBase_GUI_WISDiversionCoding.viewHistoryClicked()</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_WISComments</li></ul>
@param wis_num the wis_num for which to read comments.  If -999, it will not
be used.
@param sheet_name the sheet_name for which to read comments.  If null, it 
will not be used.
@param set_date a date string preformatted with DMIUtil.formatDate().  If
null, it will not be used.
@param orderNumber the orderNumber to use for SP queries.
@return a Vector of HydroBase_WISComments objects.
@throws Exception if an error occurs.
*/
public Vector readWISCommentsList(int wis_num, DateTime set_date, 
int orderNumber) 
throws Exception {	
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = null;
		if (!DMIUtil.isMissing(wis_num)) {
			triplet = new String[3];
			triplet[0] = "wis_num";
			triplet[1] = "EQ";
			triplet[2] = "" + wis_num;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (set_date != null) {
			DateTime dt = new DateTime(set_date);
			dt.setPrecision(DateTime.PRECISION_DAY);
			triplet = new String[3];
			triplet[0] = "set_date";
			triplet[1] = "MA";
			triplet[2] = DMIUtil.formatDateTime(this, dt, false);
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
			orderNumber = 42;
		}

		// REVISIT (JTS - 2005-02-16)
		// if set_date is provided, should sort on set_date DESC

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WISComments"), orderNumber, 
			null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWISCommentsList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);	
		buildSQL(q, __S_WIS_COMMENTS_FOR_WIS_NUM_SET_DATE);
		if (!DMIUtil.isMissing(wis_num)) {
			q.addWhereClause("wis_comments.wis_num = " + wis_num);
		}
		if (set_date != null) {
			DateTime dt = new DateTime(set_date);
			dt.setPrecision(DateTime.PRECISION_DAY);
			q.addWhereClause("wis_comments.set_date = " 
				+ DMIUtil.formatDateTime(this, dt));
			q.addOrderByClause("set_date DESC");
		}
		ResultSet rs = dmiSelect(q);
		Vector v = toWISCommentsList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the wis_daily_wc table for all data and use struct_meas_type.
Order results first by wis_daily_wc.irr_year and then by wis_daily_wc.irr_mon.
<p>
This method is used by:<ul>
<li>HydroBase_GUI_WIS.initializeDiversionCoding()</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_WISDailyWC</li></ul>
@param wis_num the wis_num to select for
@param wis_column the wis_column to select for
@param wd the wd to select for
@param id the id to select for
@param detailDate the date to query against the irr_year with.  If null, 
the method will fail immediately and return a null Vector;
@param s OPTIONAL - source to query against.  If null, won't be used.
@param f OPTIONAL - from to query against.  If MISSING_INT, won't be used.
@param u OPTIONAL - use to query against.  If null, won't be used.
@param t OPTIONAL - type to query against.  If null, won't be used
@param queryType Indicates what type of query is being executed.  If 0 then all
the most recent SFUT records matching the wis_num and are
&lt;= the detailDate are returned (use this to get records when opening a WIS).
If 1, then the detailDate is exactly matched (use this to get records when
trying to save back to the database).
If 2, then the start_date and detail date are used to query all SFUT records
between the two dates for the specified structure.  Use this to get the
structure history for the "View History" button in 
Hydrobase_GUI_WISDiversionCoding.
@return a Vector of HydroBase_DailyWC objects.
@throws Exception if an error occurs.
*/
public Vector readWISDailyWCList(int wis_num, String wis_column, int wd,
int id, DateTime detailDate, String s, int f, String u,
String t, int queryType) 
throws Exception {
	if (detailDate == null) {
		return new Vector();
	}
	
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		
		String[] triplet = null;
		triplet = new String[3];
		triplet[0] = "wis_num";
		triplet[1] = "EQ";
		triplet[2] = "" + wis_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);
		
		triplet = new String[3];
		triplet[0] = "wis_column";
		triplet[1] = "MA";
		triplet[2] = wis_column;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		triplet = new String[3];
		triplet[0] = "wd";
		triplet[1] = "EQ";
		triplet[2] = "" + wd;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		triplet = new String[3];
		triplet[0] = "id";
		triplet[1] = "EQ";
		triplet[2] = "" + id;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		if (queryType == 0 && detailDate != null) {
			triplet = new String[3];
			triplet[0] = "irr_year";
			triplet[1] = "EQ";
			triplet[2] = "" + TimeUtil.irrigationYearFromCalendar(
				detailDate.getMonth(), detailDate.getYear());

			HydroBase_GUI_Util.addTriplet(parameters, triplet);
			
			triplet = new String[3];
			triplet[0] = "irr_mon";
			triplet[1] = "LE";
			triplet[2] = "" + TimeUtil.irrigationMonthFromCalendar(
				detailDate.getMonth());
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
		else if (queryType == 1 && detailDate != null) {
			triplet = new String[3];
			triplet[0] = "irr_year";
			triplet[1] = "EQ";
			triplet[2] = "" + detailDate.getYear();
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
			
			triplet = new String[3];
			triplet[0] = "irr_mon";
			triplet[1] = "EQ";
			triplet[2] = "" + TimeUtil.irrigationMonthFromCalendar(
				detailDate.getMonth());
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
		else if (queryType == 2 && detailDate != null) {
			triplet = new String[3];
			triplet[0] = "irr_year";
			triplet[1] = "GE";
			triplet[2] = "" + TimeUtil.irrigationYearFromCalendar(
				detailDate.getMonth(), detailDate.getYear());

			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (s != null && !DMIUtil.isMissing(f) && u != null
		    && t != null) {
			int meas_num = readWISDailyWCForWDIDSFUT(wd, id,
				s, f, u, t);
			if (meas_num > -1) {
				triplet = new String[3];
				triplet[0] = "meas_num";
				triplet[1] = "EQ";
				triplet[2] = "" + meas_num;
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);
			}	
		}
		else {
			// chances are that 99.99999999% of the time these
			// values will either ALL be null or ALL be filled in,
			// no middle ground.  But just in case ...
			if (s != null && s.length() > 0) {
				triplet = new String[3];
				triplet[0] = "s";
				triplet[1] = "MA";
				triplet[2] = s;
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);
			}
			
			if (!DMIUtil.isMissing(f)) {
				triplet = new String[3];
				triplet[0] = "f";
				triplet[1] = "EQ";
				triplet[2] = "" + f;
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);
			}

			if (u != null && u.length() > 0) {
				triplet = new String[3];
				triplet[0] = "u";
				triplet[1] = "MA";
				triplet[2] = u;
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);
			}
			
			if (t != null && t.length() > 0) {
				triplet = new String[3];
				triplet[0] = "t";
				triplet[1] = "MA";
				triplet[2] = t;
				HydroBase_GUI_Util.addTriplet(parameters, 
					triplet);
			}
			
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WISDailyWC"), 37, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWISDailyWCSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;		
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);	
		buildSQL(q, __S_WIS_DAILY_WC);
	
		q.addWhereClause("wis_daily_wc.wis_num = " + wis_num);
		q.addWhereClause("wis_daily_wc.wis_column = '" + wis_column 
			+ "'");
		q.addWhereClause("wis_daily_wc.wd = " + wd);
		q.addWhereClause("wis_daily_wc.id = " + id);
	
		if (queryType == 0) {
			q.addWhereClause("wis_daily_wc.irr_year = "
				+ TimeUtil.irrigationYearFromCalendar(
				detailDate.getMonth(), detailDate.getYear()));
			q.addWhereClause("wis_daily_wc.irr_mon <= "
				+ TimeUtil.irrigationMonthFromCalendar(
				detailDate.getMonth()));
		}
		else if (queryType == 1) {
			q.addWhereClause("wis_daily_wc.irr_year = "
				+ TimeUtil.irrigationYearFromCalendar(
				detailDate.getMonth(), detailDate.getYear()));
			q.addWhereClause("wis_daily_wc.irr_mon = "
				+ TimeUtil.irrigationMonthFromCalendar(
				detailDate.getMonth()));
		}
		else if (queryType == 2) {
			q.addWhereClause("wis_daily_wc.irr_year >= " 
				+ TimeUtil.irrigationYearFromCalendar(
				detailDate.getMonth(), 
				detailDate.getYear()));
		}
	
		if (s != null) {
			q.addWhereClause("wis_daily_wc.S = '" + s + "'");
		}
		if (!DMIUtil.isMissing(f)) {
			q.addWhereClause("wis_daily_wc.F = " + f);
		}
		if (u != null) {
			q.addWhereClause("wis_daily_wc.U = '" + u + "'");
		}
		if (t != null) {
			q.addWhereClause("wis_daily_wc.T = '" + t + "'");
		}
				
		q.addOrderByClause("wis_daily_wc.irr_year");
		q.addOrderByClause("wis_daily_wc.irr_mon");	
		ResultSet rs = dmiSelect(q);	
		Vector v = toWISDailyWCList(rs);
		closeResultSet(rs);
	
		if (v == null || v.size() == 0) {
			return new Vector();
		}
	
		if (queryType > 0) {
			return v;
		}
	
		int size = v.size();
		HydroBase_WISDailyWC wdw = (HydroBase_WISDailyWC)v.elementAt(
			size - 1);

		// Now have the latest results.  Requery using the latest date,
		// which will have the last SFUT combinations available...
		q = new DMISelectStatement(this);	
		buildSQL(q, __S_WIS_DAILY_WC);
	
		q.addWhereClause("wis_daily_wc.wis_num = " + wis_num);
		q.addWhereClause("wis_daily_wc.wis_column = '" + wis_column 
			+ "'");
		q.addWhereClause("wis_daily_wc.wd = " + wd);
		q.addWhereClause("wis_daily_wc.id = " + id);
		String where = "((wis_daily_wc.cal_year = " + wdw.getCal_year() 
			+ ") AND (wis_daily_wc.cal_mon = " + wdw.getCal_mon() 
			+ "))";
		q.addWhereClause(where);
		
		q.addOrderByClause("wis_daily_wc.irr_year");
		q.addOrderByClause("wis_daily_wc.irr_mon");	
	
		rs = dmiSelect(q);
		v = toWISDailyWCList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the wis_daily_wc table for the record that matches all the criteria
(none are ignored) and return the meas_num from that record.  This is only
used when stored procedures are being done.<p>
This method is used by:<ul>
<li>readWISDailyWCList()</li>
</ul>
<p><b>Stored Procedure</b><p>
The following views are used by this method:<p><ul>
<li>vw_CDSS_StructureStructMeasType</li></ul>
@param wd the wd to query for.  
@param id the id to query for.  
@param s the s to query for.  
@param f the f to query for.  
@param u the u to query for.  
@param t the t to query for.  
@return the meas_num that matches all the values, or -1 if none could be found.
*/
private int readWISDailyWCForWDIDSFUT(int wd, int id, String s, int f,
String u, String t)
throws Exception {
	String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
		null, null);
		
	String[] triplet = null;
	triplet = new String[3];
	triplet[0] = "wd";
	triplet[1] = "EQ";
	triplet[2] = "" + wd;
	HydroBase_GUI_Util.addTriplet(parameters, triplet);

	triplet = new String[3];
	triplet[0] = "id";
	triplet[1] = "EQ";
	triplet[2] = "" + id;
	HydroBase_GUI_Util.addTriplet(parameters, triplet);

	triplet = new String[3];
	triplet[0] = "s";
	triplet[1] = "MA";
	triplet[2] = s;
	HydroBase_GUI_Util.addTriplet(parameters, triplet);

	triplet = new String[3];
	triplet[0] = "f";
	triplet[1] = "EQ";
	triplet[2] = "" + f;
	HydroBase_GUI_Util.addTriplet(parameters, triplet);

	triplet = new String[3];
	triplet[0] = "u";
	triplet[1] = "MA";
	triplet[2] = u;
	HydroBase_GUI_Util.addTriplet(parameters, triplet);

	triplet = new String[3];
	triplet[0] = "t";
	triplet[1] = "MA";
	triplet[2] = t;
	HydroBase_GUI_Util.addTriplet(parameters, triplet);

	HydroBase_GUI_Util.fillSPParameters(parameters, 
		getViewNumber("vw_CDSS_WISDailyWC"), 37, null);
	ResultSet rs = runSPFlex(parameters);
		// use the toStructureStructMeas...
	Vector v = toWISDailyWCSPList(rs);
	closeResultSet(rs, __lastStatement);

	if (v == null || v.size() == 0) {
		return -1;
	}
	else {
		HydroBase_WISDailyWC wc = (HydroBase_WISDailyWC)v.elementAt(0);
		return wc.getMeas_num();
	}
}

/**
Read the wis_data table for all data.<p>
This method is used by:<ul>
<li>HydroBase_WIS_Util.getWISValue()</li>
</ul>
<p><b>Stored Procedures</b><p>
<b>THIS METHOD USES NO STORED PROCEDURES</b>
@param wisNums a Vector of numbers (as Strings) of the wis nums to query for.
Cannot be null.  Vector elements at position X are tied to the wisRows Vector
elements at position X.  Both Vectors must have the same number of elements.
@param wisRows a Vector of rows numbers (as Strings) of the wis rows to query
for.  Cannot be null.  Vector elements at position X are tired to the wisNums
Vector elements at position X.  Both Vectors must have the same number of 
elements.
@param order a Vector of order by clauses
@return a Vector of HydroBase_WISData objects.
@throws Exception if an error occurs.
*/
public Vector readWISDataListForWis_numWis_rowList(Vector wisNums, 
Vector wisRows, Vector order) 
throws Exception {
	if (__useSP) {
		int size = wisNums.size();
		int vsize = 0;
		String wisNum = null;
		String wisRow = null;
		Vector results = new Vector();
		Vector v = null;
		for (int i = 0; i < size; i++) {
			wisNum = (String)wisNums.elementAt(i);
			wisRow = (String)wisRows.elementAt(i);
			v = readWISDataList(StringUtil.atoi(wisNum), null,
				StringUtil.atoi(wisRow));
			vsize = v.size();
			for (int j = 0; j < vsize; j++) {
				results.add(v.elementAt(j));
			}
		}
		return results;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WIS_DATA);
	
		StringBuffer whereb = new StringBuffer ();
		whereb.append("(");
		int size = wisNums.size();
		for (int iwis = 0; iwis < size; iwis++) {
			if (iwis > 0) {
				whereb.append(" OR ");
			}
			whereb.append("(wis_data.wis_num=" 
				+ (String)wisNums.elementAt(iwis)
				+ " AND wis_data.wis_row=" 
				+ (String)wisRows.elementAt(iwis) + ")");
		}
		whereb.append(")");
		q.addWhereClause(whereb.toString());

		if (order != null) {
			size = order.size();
				for (int i = 0; i < size; i++) {
				q.addOrderByClause((String)order.elementAt(i));
			}
		}	
		ResultSet rs = dmiSelect(q);
		Vector v = toWISDataList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the wis_data table for all data.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WIS.loadWISData()</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_WISData</li></ul>
@param wis_num the wis_num for which to select.  If mssing, will not be 
included.
@param set_date a date string, pre-formatted with DMIUtil.formatDate().
If null, will not be included.
@param wis_row the number of the row in the wis to return.  If missing, will
not be included.
@return a Vector of HydroBase_WISData objects.
@throws Exception if an error occurs.
*/
public Vector readWISDataList(int wis_num, DateTime set_date, int wis_row) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		
		String[] triplet = null;
		if (!DMIUtil.isMissing(wis_num)) {
			triplet = new String[3];
			triplet[0] = "wis_num";
			triplet[1] = "EQ";
			triplet[2] = "" + wis_num;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (set_date != null) {
			DateTime dt = new DateTime(set_date);
			dt.setPrecision(DateTime.PRECISION_DAY);
			triplet = new String[3];
			triplet[0] = "set_date";
			triplet[1] = "MA";
			triplet[2] = DMIUtil.formatDateTime(this, dt, false);
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (!DMIUtil.isMissing(wis_row)) {
			triplet = new String[3];
			triplet[0] = "wis_row";
			triplet[1] = "EQ";
			triplet[2] = "" + wis_row;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}		

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WISData"), 39, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWISDataList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WIS_DATA_FOR_WIS_NUM_SET_DATE);
		if (!DMIUtil.isMissing(wis_num)) {
			q.addWhereClause("wis_data.wis_num = " + wis_num);
		}
		if (set_date != null) {
			DateTime dt = new DateTime(set_date);
			dt.setPrecision(DateTime.PRECISION_DAY);		
			q.addWhereClause("wis_data.set_date = "
				+ DMIUtil.formatDateTime(this, dt));
		}
		if (!DMIUtil.isMissing(wis_row)) {
			q.addWhereClause("wis_data.wis_row = " + wis_row);
		}
		q.addOrderByClause("wis_data.wis_row");
		ResultSet rs = dmiSelect(q);
		Vector v = toWISDataList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Reads the wis_diagram_data table for all the records with the matching
wis_num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WISDiagram.readDatabaseRecords()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISDiagram_Sel_By_Wis_num</li>
</ul>
@return a Vector of HydroBase_WISDiagramData objects, or null if none were read.
@throws an Exception if an error occurs.
*/
public Vector readWISDiagramDataListForWis_num(int wis_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_WIS_DIAGRAM_DATA);
	q.addWhereClause("wis_diagram_data.wis_num = " + wis_num);
	ResultSet rs = dmiSelect(q);
	Vector v = toWISDiagramDataList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

public HydroBase_WISFormat readWISFormatForWis_numWis_row(int wis_num, 
int wis_row)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		
		String[] triplet = new String[3];
		triplet[0] = "wis_num";
		triplet[1] = "EQ";
		triplet[2] = "" + wis_num;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		triplet = new String[3];
		triplet[0] = "wis_row";
		triplet[1] = "EQ";
		triplet[2] = "" + wis_row;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WISFormat"), 40, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWISFormatSPList(rs);
		closeResultSet(rs, __lastStatement);
		if (v == null || v.size() == 0) {
			return null;
		}
		else {
			return (HydroBase_WISFormat)v.elementAt(0);
		}
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WIS_FORMAT);
		q.addWhereClause("wis_format.wis_num = " + wis_num);
		q.addWhereClause("wis_format.wis_row = " + wis_row);
		ResultSet rs = dmiSelect(q);
		Vector v = toWISFormatList(rs);
		closeResultSet(rs);
		if (v == null || v.size() == 0) {
			return null;
		}
		else {
			return (HydroBase_WISFormat)v.elementAt(0);
		}		
	}
}

/**
Read the wis_format table for all data matching the specified wis_Num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WIS.loadSheet()</li>
<li>HydroBase_GUI_WISBuilder()</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_WISFormat</li></ul>
@param wis_num the wis_num for which to read data.  If missing it will not 
be included.
@param row_type the row_type of the records that should NOT be returned. Records
that do not match this row_type will be returned, if row_type is not null.
@param identifier the identifier of the wis format data to match.  If null it
will not be included.
@return a Vector of HydroBase_WISFormat objects.
@throws Exception if an error occurs.
*/
public Vector readWISFormatList(int wis_num, String row_type, String identifier)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
		
		String[] triplet = null;
		if (!DMIUtil.isMissing(wis_num)) {
			triplet = new String[3];
			triplet[0] = "wis_num";
			triplet[1] = "EQ";
			triplet[2] = "" + wis_num;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (row_type != null) {
			triplet = new String[3];
			triplet[0] = "row_type";
			triplet[1] = "NM";
			triplet[2] = row_type;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		if (identifier != null) {
			triplet = new String[3];
			triplet[0] = "identifier";
			triplet[1] = "MA";
			triplet[2] = identifier;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WISFormat"), 40, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWISFormatSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WIS_FORMAT);
		if (!DMIUtil.isMissing(wis_num)) {
			q.addWhereClause("wis_format.wis_num = " + wis_num);
		}
		if (row_type != null) {
			q.addWhereClause("wis_format.row_type <> '" 
				+ row_type + "'");
		}
		if (identifier != null) {
			q.addWhereClause("wis_format.identifier = '"
				+ identifier + "'");
		}
		q.addOrderByClause("wis_format.wis_row");
		ResultSet rs = dmiSelect(q);
		Vector v = toWISFormatList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the wis_format table for all data.<p>
This method is used by:<ul>
<li>HydroBaseDMI.readWISStructuresList()</li>
</ul>
<p><b>Stored Procedures</b><p>
<b>THIS METHOD USES NO STORED PROCEDURES</b>
@param where a Vector of Strings of wis_nums to search for.
@return a Vector of HydroBase_WISFormat objects.
@throws Exception if an error occurs.
*/
public Vector readWISFormatListForWis_numList(Vector wisNums)
throws Exception {
	if (__useSP) {
		int size = wisNums.size();
		int vsize = -1;
		String s = null;
		Vector results = new Vector();
		Vector v = null;

		for (int i = 0; i < size; i++) {
			s = (String)wisNums.elementAt(i);
			v = readWISFormatList(StringUtil.atoi(s),
				"wdid:", true, "Other");

			vsize = v.size();
			for (int j = 0; j < vsize; j++) {
				results.add(v.elementAt(j));
			}
		}
		return results;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WIS_FORMAT);
		q.selectDistinct(true);

                int size = wisNums.size();
		String s = null;
		int wisNum = -1;
		Vector wheres = new Vector();
                for (int i = 0; i < size; i++) {
                        s = (String)wisNums.elementAt(i);
                        wisNum = StringUtil.atoi(s);
                        if (!DMIUtil.isMissing(wisNum)) {
                                wheres.add("wis_format.wis_num = "
					+ wisNum + " AND ("
					+ " row_type Like 'Diversion' OR"
                                	+ " row_type Like 'Reservoir' OR" 
                                	+ " row_type Like 'MinFlow')");
                        }                        
                }

                String orString = DMIUtil.getOrClause(wheres);
		q.addWhereClause(orString);
		ResultSet rs = dmiSelect(q);
		Vector v = toWISFormatList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the wis_format table for all data.<p>
This method is used by:<ul>
<li>HydroBaseDMI.readWISStructuresList()</li>
</ul>
<p><b>Stored Procedures</b><p>
<b>THIS METHOD USES NO STORED PROCEDURES</b>
@param where a Vector of Strings of wis_nums to search for.
@param order a Vector of Strings of identifiers to search for.
@return a Vector of HydroBase_WISFormat objects.
@throws Exception if an error occurs.
*/
public Vector readWISFormatListForWis_numIdentifierList(Vector wisNums, 
Vector identifiers) 
throws Exception {
	if (__useSP) {
		int size = wisNums.size();
		int vsize = -1;
		String s = null;
		Vector results = new Vector();
		Vector v = null;

		for (int i = 0; i < size; i++) {
			s = (String)wisNums.elementAt(i);
			v = readWISFormatList(StringUtil.atoi(s),
				(String)identifiers.elementAt(i), false, null);

			vsize = v.size();
			for (int j = 0; j < vsize; j++) {
				results.add(v.elementAt(j));
			}
		}
		return results;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WIS_FORMAT);
		q.selectDistinct(true);

                int size = wisNums.size();
		String s = null;
		int wisNum = -1;
		String identifier = null;
		Vector wheres = new Vector();
                for (int i = 0; i < size; i++) {
                        s = (String)wisNums.elementAt(i);
                        wisNum = StringUtil.atoi(s);
			identifier = (String)identifiers.elementAt(i);
                        if (!DMIUtil.isMissing(wisNum)) {
                                wheres.add("wis_format.wis_num = "
					+ wisNum 
					+ " AND wis_format.identifier = '"
					+ identifier + "'");
                        }                        
                }

                String orString = DMIUtil.getOrClause(wheres);
		q.addWhereClause(orString);
		ResultSet rs = dmiSelect(q);
		Vector v = toWISFormatList(rs);
		closeResultSet(rs);
		return v;
	}
}

/**
Read the wis_format table for all data matching the specified wis_nums but
that also have a row type of "Diversion", "Reservoir" or "MinFlow".  This method
is only used for stored procedures.
This method is used by:<ul>
<li>readWISFormatListForWis_numList()</li>
</ul>
<p><b>Stored Procedure</b><p>
@param wis_num the wis_num for which to read data.  
@param identifier the identifier to match for.  If null, will not be used.
@param idStart if true, then the identifier match will be a "Starts With"
match.  If false, it will be a "Match" match.
@return a Vector of HydroBase_WISFormat objects.
@throws Exception if an error occurs.
*/
private Vector readWISFormatList(int wis_num, String identifier, 
boolean idStart, String notRow)
throws Exception {
	String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
		null, null);
	
	String[] triplet = null;
	triplet = new String[3];
	triplet[0] = "wis_num";
	triplet[1] = "EQ";
	triplet[2] = "" + wis_num;
	HydroBase_GUI_Util.addTriplet(parameters, triplet);

	if (identifier != null && identifier.length() > 0) {
		triplet = new String[3];
		triplet[0] = "identifier";
		if (idStart) {
			triplet[1] = "SW";
		}
		else {
			triplet[1] = "MA";
		}
		triplet[2] = identifier;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);	
	}

	if (notRow != null) {
		triplet = new String[3];
		triplet[0] = "row_type";
		triplet[1] = "NM";
		triplet[2] = notRow;
		HydroBase_GUI_Util.addTriplet(parameters, triplet);	
	}

	HydroBase_GUI_Util.fillSPParameters(parameters, 
		getViewNumber("vw_CDSS_WISFormat"), 0, null);
	ResultSet rs = runSPFlex(parameters);
	Vector v = toWISFormatSPList(rs);
	closeResultSet(rs, __lastStatement);
	return v;
}

/**
Read the wis_formula table for all data with the given wis_num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WIS.loadWISFormula()</li>
<li>HydroBase_GUI_WISBuilder.queryWISFormula()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISFormula_Sel_By_Wis_num</li>
</ul>
@return a Vector of HydroBase_WISFormula objects.
@throws Exception if an error occurs.
*/
public Vector readWISFormulaListForWis_num(int wis_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_WIS_FORMULA);
	q.addWhereClause("wis_formula.wis_num = " + wis_num);
	ResultSet rs = dmiSelect(q);
	// checked stored procedure
	Vector v = toWISFormulaList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Read the wis_import table for all data.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WIS.loadWISImports()</li>
<li>HydroBase_GUI_WISBuilder.queryWISImport()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISImportList_Sel_By_Wis_num(bigint @wis_num)</li>
</ul>
@return a Vector of HydroBase_WISImport objects.
@throws Exception if an error occurs.
*/
public Vector readWISImportListForWis_num(int wis_num) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_WIS_IMPORT);
	q.addWhereClause("wis_import.wis_num = " + wis_num);
	ResultSet rs = dmiSelect(q);
	// checked stored procedure
	Vector v = toWISImportList(rs);
	if (__useSP) {
		closeResultSet(rs, q);
	}
	else {
		closeResultSet(rs);
	}
	return v;
}

/**
Reads the sheet_name table for all the records that match the given wis num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WIS.loadSheet()</li>
<li>HydroBase_GUI_WISBuilder.querySheetName()</li>
<li>HydroBase_GUI_LoadWIS.generateDates()</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_WISSheetName</li>
</ul>
@param wd the wd for which to return sheets.  If missing, will not be used.
@param wis_num the wis_num for which to return sheets.  If missing, will not be
used.
@param sheet_name the name of the sheet to return.  If null, will not be used.
@param effective_date the effective_date to match.  If null, will not be used.
@return a Vector of HydroBase_WISSheetName objects.
@throws Exception if an error occurs
*/
public Vector readWISSheetNameList(int wd, int wis_num, String sheet_name,
DateTime effective_date) 
throws Exception {
	return readWISSheetNameList(wd, wis_num, sheet_name, effective_date,
		false);
}

/**
Reads the sheet_name table for all the records that match the given wis num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WIS.loadSheet()</li>
<li>HydroBase_GUI_WISBuilder.querySheetName()</li>
<li>HydroBase_GUI_LoadWIS.generateDates()</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_WISSheetName</li>
</ul>
@param wd the wd for which to return sheets.  If missing, will not be used.
@param wis_num the wis_num for which to return sheets.  If missing, will not be
used.
@param sheet_name the name of the sheet to return.  If null, will not be used.
@param effective_date the effective_date to match.  If null, will not be used.
@param orderDescEffectiveDate if true, the query will be ordered additionally
by effective_date DESC.
@return a Vector of HydroBase_WISSheetName objects.
@throws Exception if an error occurs
*/
public Vector readWISSheetNameList(int wd, int wis_num, String sheet_name,
DateTime effective_date, boolean orderDescEffectiveDate) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = null;

		if (!DMIUtil.isMissing(wd)) {
			triplet = new String[3];
			triplet[0] = "wd";
			triplet[1] = "EQ";
			triplet[2] = "" + wd;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
			
		if (!DMIUtil.isMissing(wis_num)) {
			triplet = new String[3];
			triplet[0] = "wis_num";
			triplet[1] = "EQ";
			triplet[2] = "" + wis_num;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
		
		if (sheet_name != null && sheet_name.length() > 0) {
			triplet = new String[3];
			triplet[0] = "sheet_name";
			triplet[1] = "MA";
			triplet[2] = sheet_name;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
		
		if (effective_date != null) {
			DateTime dt = new DateTime(effective_date);
			dt.setPrecision(DateTime.PRECISION_DAY);
			triplet = new String[3];
			triplet[0] = "effective_date";
			triplet[1] = "MA";
			triplet[2] = DMIUtil.formatDateTime(this, 
				effective_date, false);
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}
			
		int orderNum = 69;
		if (orderDescEffectiveDate) {
			orderNum = 75;
		}
			
		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WISSheetName"), orderNum, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWISSheetNameSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;	
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WIS_SHEET_NAME_FOR_WIS_NUM);
		String table = "wis_sheet_name";
		if (getDatabaseVersion() <= VERSION_20040701) {
			table = "sheet_name";
		}		
		if (!DMIUtil.isMissing(wd)) {
			q.addWhereClause(table + ".wd = " + wd);
		}
		if (!DMIUtil.isMissing(wis_num)) {
			q.addWhereClause(table + ".wis_num = " + wis_num);
		}
		if (sheet_name != null && sheet_name.length() > 0) {
			q.addWhereClause(table + ".sheet_name = '"
				+ sheet_name + "'");
		}
		if (effective_date != null) {
			DateTime dt = new DateTime(effective_date);
			dt.setPrecision(DateTime.PRECISION_DAY);		
			q.addWhereClause(table + ".effective_date = "
				+ DMIUtil.formatDateTime(this, effective_date));
		}
		q.addOrderByClause(table + ".wis_num");

		if (orderDescEffectiveDate) {
			q.addOrderByClause(
				table + ".effective_date DESC");
		}
		
		ResultSet rs = dmiSelect(q);
		Vector v = toSheetNameList(rs, __S_WIS_SHEET_NAME_FOR_WIS_NUM);
		closeResultSet(rs);	
		return v;
	}
}	

/**
Read the sheet_name table for all the distinct records.<p>
The SQL that is executed:<pre>
This method is used by:<ul>
<li>HydroBase_GUI_LoadWIS.getWISSheets()</li>
</ul>
@param wds a Vector of Strings, each of which is the number of a water 
district for which to return distinct sheets.
@return a Vector of HydroBase_WISSheetName objects.
@throws Exception if an error occurs.
*/
public Vector readWISSheetNameDistinctList(Vector wds) 
throws Exception {
	Vector results = new Vector();
	int size = wds.size();
	int size2 = -1;
	Vector v = null;
	String s = null;
	int wd = -1;
	for (int i = 0; i < size; i++) {
		s = (String)wds.elementAt(i);
		wd = StringUtil.atoi(s);
		v = readWISSheetNameDistinctList(wd);
		size2 = v.size();
		for (int j = 0; j < size2; j++) {
			if (v.elementAt(j) != null) {
				results.add(v.elementAt(j));
			}
		}
	}
	return results;
}

/**
Read the sheet_name table for all the distinct records.<p>
This method is used by:<ul>
<li>HydroBase_GUI_Options.generateWIS()</li>
<li>HydroBase_GUI_LoadWIS</li>
</ul>
<p><b>Stored Procedure</b><p>
This method uses the following views:<p><ul>
<li>vw_CDSS_WISSheetName_Distinct</li></ul>
@param wd the water district for which to get distinct records.  If -1, will
not be used.
@return a Vector of HydroBase_WISSheetName objects.
@throws Exception if an error occurs.
*/
public Vector readWISSheetNameDistinctList(int wd) 
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			null, null);
			
		String[] triplet = null;
		if (wd > 0) {
			triplet = new String[3];
			triplet[0] = "wd";
			triplet[1] = "EQ";
			triplet[2] = "" + wd;
			HydroBase_GUI_Util.addTriplet(parameters, triplet);
		}

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WISSheetName_Distinct"), 43, 
			null);

		ResultSet rs = runSPFlex(parameters);
		Vector v = toWISSheetNameDistinctSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;	
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WIS_SHEET_NAME_DISTINCT);
		String table = "wis_sheet_name";
		if (getDatabaseVersion() <= VERSION_20040701) {
			table = "sheet_name";
		}		
		if (wd > 0) {
			q.addWhereClause(table + ".wd = " + wd);
		}
		q.addOrderByClause(table + ".sheet_name");
//	        q.addOrderByClause("effective_date DESC");
		q.selectDistinct(true);
		ResultSet rs = dmiSelect(q);
		Vector v = toSheetNameList(rs, __S_WIS_SHEET_NAME_DISTINCT);
		closeResultSet(rs);	
		return v;
	}
}

/**
Read the sheet_name table for all the distinct records.<p>
The SQL that is executed:<pre>
This method is used by:<ul>
<li>HydroBase_GUI_LoadWIS.getWISSheets()</li>
</ul>
@param wds a Vector of Strings, each of which is the number of a water 
district for which to return distinct sheets.
@return a Vector of HydroBase_WISSheetName objects.
@throws Exception if an error occurs.
*/
public Vector readWISSheetNameList(Vector wds) 
throws Exception {
	return readWISSheetNameList(wds, false);
}

/**
Read the sheet_name table for all the distinct records.<p>
The SQL that is executed:<pre>
This method is used by:<ul>
<li>HydroBase_GUI_LoadWIS.getWISSheets()</li>
</ul>
@param wds a Vector of Strings, each of which is the number of a water 
district for which to return distinct sheets.
@param orderDescEffectiveDate if true, the query will be ordered additionally
by effective_date, descending.
@return a Vector of HydroBase_WISSheetName objects.
@throws Exception if an error occurs.
*/
public Vector readWISSheetNameList(Vector wds, boolean orderDescEffectiveDate) 
throws Exception {
	Vector results = new Vector();
	int size = wds.size();
	int size2 = -1;
	Vector v = null;
	String s = null;
	int wd = -1;
	for (int i = 0; i < size; i++) {
		s = (String)wds.elementAt(i);
		wd = StringUtil.atoi(s);
		v = readWISSheetNameList(wd, -999, null, null,
			orderDescEffectiveDate);
		size2 = v.size();
		for (int j = 0; j < size2; j++) {
			if (v.elementAt(j) != null) {
				results.add(v.elementAt(j));
			}
		}
	}
	return results;
}

/**
Read the sheet_name and wis_format table for all the records matching the
specified input filter and order by clauses.<p>
This method is used by:
<ul>
<li>TSTool</li>
<li>HydroBase_Util</li>
</ul>
<p><b>Stored Procedures</b><p>
This method uses the following view:<p><ul>
<li>vw_CDSS_WISSheetNameWISFormat</li></ul>
@param panel the InputFilter_JPanel to use to constrain the query.  If null,
it will not be used.
@return a Vector of HydroBase_WISSheetName objects.
@throws Exception if an error occurs.
*/
public Vector readWISSheetNameWISFormatListDistinct(
InputFilter_JPanel panel)
throws Exception {
	if (__useSP) {
		String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(
			panel, null);

		HydroBase_GUI_Util.fillSPParameters(parameters, 
			getViewNumber("vw_CDSS_WISSheetNameWISFormat"), 
			41, null);
		ResultSet rs = runSPFlex(parameters);
		Vector v = toWISSheetNameWISFormatSPList(rs);
		closeResultSet(rs, __lastStatement);
		return v;
	}
	else {
		DMISelectStatement q = new DMISelectStatement(this);
		buildSQL(q, __S_WIS_SHEET_NAME_WIS_FORMAT_DISTINCT);
		int size = 0;
		Vector wheres 
			= HydroBase_GUI_Util.getWhereClausesFromInputFilter(
			this, panel);		
		if (wheres != null) {
			size = wheres.size();
			for (int i = 0; i < size; i++) {
				q.addWhereClause((String)wheres.elementAt(i));
			}
		}
		String table = "wis_sheet_name";
		if (getDatabaseVersion() <= VERSION_20040701) {
			table = "sheet_name";
		}		
		q.addOrderByClause(table + ".sheet_name");
		ResultSet rs = dmiSelect(q);
		Vector v = toSheetNameWISFormatList(rs,
			__S_WIS_SHEET_NAME_WIS_FORMAT_DISTINCT);
		closeResultSet(rs);
		return v;
	}
}

/**
Constructs and submits the following queries:
readSheetNameList<br>
readWISFormatList<br>
readStructureList<br>
</ol>
This method is used by:<ul>
<li>HydroBase_GUI_EditCallsBypass.displayWISStructures()</li>
<li>HydroBase_GUI_SetCall.displayResults()</li>
</ul>
@return returns a Vector of HydroBase_Structure Objects
@throws Exception if an error occurs.
*/
public Vector readWISStructuresList()
throws Exception {
	if (__useSP) {

	Vector wds = HydroBase_GUI_Util.generateWaterDistricts(this, false);
	StringBuffer clause = new StringBuffer();
	int size = wds.size();
	for (int i = 0; i < size; i++) {
		clause.append((String)wds.elementAt(i));
		if (i < (size - 1)) {
			clause.append(",");
		}
	}
	String wdClause = clause.toString();
	
	String[] parameters = HydroBase_GUI_Util.getSPFlexParameters(null,null);

	String[] triplet = new String[3];
	triplet[0] = "wd";
	triplet[1] = "IN";
	triplet[2] = wdClause;
	HydroBase_GUI_Util.addTriplet(parameters, triplet);

	HydroBase_GUI_Util.fillSPParameters(parameters, "82", -999, null);
	ResultSet rs = runSPFlex(parameters);
	Vector v = toStructureSPList(rs);
	closeResultSet(rs, __lastStatement);
	__WISStructures_Vector = v;
	return v;

	}
	else {

        boolean isWISResults = false;
        boolean isFormatResults = false;

	HydroBase_WISFormat formatData;
	HydroBase_WISSheetName wisData;

        // initialize variables
        Vector structureNums = null;

	Vector wds = HydroBase_GUI_Util.generateWaterDistricts(this, false);
/*
        //concatenate 'wd = ' for each element in the wd Vector
	Vector wds = new Vector();
	Vector waterDistricts = getWaterDistricts();
        int wdVectorSize = waterDistricts.size();
	HydroBase_WaterDistrict hbwd = null;
        for (int i = 0; i < wdVectorSize; i++) {
		hbwd = (HydroBase_WaterDistrict)
			waterDistricts.elementAt(i);
		wds.add("" + hbwd.getWD());
        }
*/
        // build or clause for the water districts
        Vector wisResults = readWISSheetNameList(wds);

        // get the unique wisNums from the HBWISQuery
        // and build where clause for HBWISFormatRowQuery
	int curInt;
        Vector wisNums = null;
        if (wisResults != null) {
        if (!wisResults.isEmpty()) {
                isWISResults = true;
                int size = wisResults.size();
                wisNums = new Vector(size);
                for (int i = 0; i < size; i++) {
                        wisData=(HydroBase_WISSheetName)wisResults.elementAt(i);
                        curInt = wisData.getWis_num();
                        if (!DMIUtil.isMissing(curInt)) {
                                wisNums.add("" + curInt);
                        }                        
                }		
        }
        }

        // construct and submit HBWISFormatRowQuery using the unique wisNums
        if (isWISResults) {
                isFormatResults = true;
                Vector formatResults = readWISFormatListForWis_numList(
			wisNums);
         
                if (formatResults != null) {
                if (!formatResults.isEmpty()) {
                        int size = formatResults.size();
                        structureNums = new Vector(size, 5);
                        for (int i = 0; i < size; i++) {
                                formatData = (HydroBase_WISFormat)
					formatResults.elementAt(i);
                                curInt = formatData.getStructure_num();
                                if (!DMIUtil.isMissing(curInt)) {
                                        structureNums.add("" + curInt);
                                }
                        }
                }
                }
        }
        // construct and submit HBStructureQuery using the structureNums
	Vector structureResults = null;
	Vector orderBy = new Vector();
        if (isFormatResults) {
                orderBy.add("wd");
                orderBy.add("str_name");
		structureResults = readStructureListForStructure_nums(
			structureNums, orderBy);
        }
        __WISStructures_Vector = structureResults;
        return structureResults;
	}
}

/**
Runs an SPFlex query using the given parameters.<p>
The parameters are as follows:<p>
<b>0</b> - the internal number of the view for which to run SPFLex<br>
<b>1</b> - the first field on which to query, or -999 if no fields are being
	queried.<br>
<b>2</b> - the first comparator (or -999 if no fields are being queried)<br>
<b>3</b> - the first query value (or -999 if no fields are being queried)<br>
<b>4</b> - the second field on which to query, or -999 if no fields are being
	queried.<br>
<b>5</b> - the second comparator (or -999 if one field is being queried)<br>
<b>6</b> - the second query value (or -999 if one field is being queried)<br>
<b>7</b> - the third field on which to query, or -999 if two fields are being
	queried.<br>
<b>8</b> - the third comparator (or -999 if two fields are being queried)<br>
<b>9</b> - the third query value (or -999 if two fields are being queried)<br>
<b>10</b> - the fourth field on which to query, or -999 if three fields are 
	being queried.<br>
<b>11</b> - the fourth comparator (or -999 if three fields are being queried)
	<br>
<b>12</b> - the fourth query value (or -999 if three fields are being queried)
	<br>
<b>13</b> - the fifth field on which to query, or -999 if three fields are 
	being queried.<br>
<b>14</b> - the fifth comparator (or -999 if three fields are being queried)
	<br>
<b>15</b> - the fifth query value (or -999 if three fields are being queried)
	<br>
<b>16</b> - the sixth field on which to query, or -999 if three fields are 
	being queried.<br>
<b>17</b> - the sixth comparator (or -999 if three fields are being queried)
	<br>
<b>18</b> - the sixth query value (or -999 if three fields are being queried)
	<br>	
<b>19</b> - the order by code<br>
<b>20</b> - the application code<br>
@param parameters the parameters for the SPFlex run.
@return the ResultSet generated by the query.
@throws Exception if there is an error running the stored procedure.
*/
private ResultSet runSPFlex(String[] parameters) 
throws Exception {
	if (__uspFlexStoredProcedureData == null) {
		__uspFlexStoredProcedureData = new DMIStoredProcedureData(this, 
			"usp_Flex");
		__uspFlexSelectStatement = new DMISelectStatement(this);
		__uspFlexSelectStatement.setStoredProcedureData(
			__uspFlexStoredProcedureData);
	}

	__lastStatement = __uspFlexSelectStatement;

	String s = "\nexec usp_Flex ";
	for (int i = 0; i < parameters.length; i++) {
		__uspFlexSelectStatement.setValue(parameters[i], i + 2);
		s += "'" + parameters[i] + "'";
		if (i < parameters.length - 1) {
			s += ", ";
		}
	}
	return dmiSelect(__uspFlexSelectStatement);
}

DMIStoredProcedureData __uspFlexStoredProcedureData = null;
DMISelectStatement __uspFlexSelectStatement = null;

// S METHODS

/**
Save any changed user preferences to the database.  After saving, the 
previously-changed user preferences are no longer marked as modified.  
@return true if the preferences were successfully saved to the database.  
False if not.
*/
public boolean saveUserPreferences() {
	String function = "HydroBaseDMI.savePreferences";

	if (__prefsProps == null) {
		Message.printStatus(2, function, "No preferences to save.");
		return false;
	}

        Message.printStatus(2, function,
		"Checking for user preferences that have changed...");
	
        // loop over all the preference fields
	int size = __prefsProps.size();

	// So that it is not confusing to users who did not save options, do
	// an initial pass to see if anything does need to be updated...
	boolean needToSave = false;
	Prop p = null;	
        for(int i = 0; i < size; i++) {
		p = __prefsProps.propAt(i);
		if (p.getHowSet() == Prop.SET_AT_RUNTIME_BY_USER) {
			needToSave = true;
		}
	}

	if (!needToSave) {
		Message.printStatus(2, function,
			"No preferences have changed.  Don't need to save.");
		return true;
	}

	// If we get to here, some do need to be updated...  However, guest
	// users using a remote database cannot save so print a warning...
	if (!canWriteToDatabase()) {
		Message.printWarning(1, function,
		  "You do not have permissions to save preferences to the\n"
		+ "database.  For example, you cannot save preferences to\n"
		+ "the main server if logged in as \"guest\".  Any changes\n"
		+ "you have made will be in effect while you are logged in\n"
		+ "but you will need to reset your preferences the next time\n"
		+ "you log in.  You can also install a database locally or\n"
		+ "contact cdss@state.co.us if you need to save to the\n"
		+ "main database (mainly for State of Colorado staff).");
		return false;
	}

        // get database connection information

	boolean insert = false;
	String prefName;
	String prefValue;

	Vector dbProps = new Vector();
	try {
		dbProps = readUserPreferencesListForUser_num(
			__userNum);
	}
	catch (Exception e) {
		Message.printWarning(2, "writeUserPreferences", e);
	}

	int dbPropsSize = dbProps.size();
	HydroBase_UserPreferences up = null;
	
	boolean capitalize = getCapitalize();
	setCapitalize(false);

        for (int i = 0; i < size; i++) {
		try {
                p = __prefsProps.propAt(i);

		if (p.getHowSet() == Prop.SET_AT_RUNTIME_BY_USER) {
			prefName = p.getKey().trim();
			prefValue = p.getValue().trim();
			__prefsProps.setHowSet(Prop.SET_FROM_PERSISTENT);

			insert = true;
			for (int j = 0; j < dbPropsSize; j++) {
				up = (HydroBase_UserPreferences)
					dbProps.elementAt(j);
				if (up.getPreference().trim().equalsIgnoreCase(
					prefName)) {
					insert = false;
					j = dbPropsSize+1;
					break;
				}
			}
			writeUserPreference(prefName, prefValue, 
				("" + __userNum), "CWRAT", insert);
				// CWRAT is hard-coded as the program name 
				// for HydroBase.  Maybe REVISIT later.
				//IOUtil.getProgramName());
			// If get to here the insert or update was 
			// successful.  Mark the user preference as 
			// not modified so an additional save
			// won't occur later...
			__prefsProps.set(prefName, prefValue);
		}
		}
		catch(Exception e) {
			if (p != null) {
			Message.printWarning(2, function,
				"Error saving preferences for " 
				+ p.toString());
			}
			Message.printWarning(2, function, e);
		}
        }
	setCapitalize(capitalize);
	__prefsProps.setHowSet(Prop.SET_AT_RUNTIME_BY_USER);	
        Message.printStatus(2, function, "User preferences saved.");
        return true;
}

/**
Sets the preference value for the given key.<p>
It is imperative to type the String 
variable exactly as in appears in the User_preference table, otherwise 
the write to the database will when the preferences are saved will add
a new pref.<p>
Preferences remain in effect for the duration of the user's session.  When
they log out of the database, if preference changes are not saved to the 
database they will be lost.
@param keyword lookup keyword
@param value value to put in pref
*/
public void setPreferenceValue(String keyword, String value) {
	String function = "HydroBaseDMI.setPreferenceValue";
	int dl = 20;

	try {
		if (value.equals(getPreferenceValue(keyword))) {
			// prop didn't change
			return;
		}
	
		__prefsProps.set(keyword, value);

		if (Message.isDebugOn) {
			Message.printDebug(dl, function,
				"Set user preference: " + keyword
				+ " value is " + value);
		}
	}
	catch (Exception e) {
		Message.printDebug(dl, function,
			"Unable to locate user preference: " + value);
	}
}

/**
Creates the hashtable that will stored the relationship of view names to the
view numbers used internally by SPFlex, and populates the hashtable as well.
*/
private void setupViewNumbersHashtable() {
	long version = getDatabaseVersion();

	__viewNumbers = new Hashtable();
	__viewNumbers.put("vw_CDSS_AgriculturalCASSCropStats", "1");
	__viewNumbers.put("vw_CDSS_AgriculturalCASSCropStats_Distinct", "2");
	__viewNumbers.put("vw_CDSS_AgriculturalCASSLivestockStats", "106");
	__viewNumbers.put("vw_CDSS_AgriculturalCASSLivestockStats_Distinct","111");
	__viewNumbers.put("vw_CDSS_AgriculturalNASSCropStats", "3");
	__viewNumbers.put("vw_CDSS_AgriculturalNASSCropStats_Distinct", "4");
	__viewNumbers.put("vw_CDSS_Agstats", "5");
	__viewNumbers.put("vw_CDSS_Agstats_Distinct", "6");
	__viewNumbers.put("vw_CDSS_Annual_Amt", "7");
	__viewNumbers.put("vw_CDSS_Annual_Res", "8");
	__viewNumbers.put("vw_CDSS_Annual_WC", "9");
	__viewNumbers.put("vw_CDSS_Calls", "10");
	__viewNumbers.put("vw_CDSS_Calls_Distinct", "11");
	__viewNumbers.put("vw_CDSS_Cropchar", "12");
	__viewNumbers.put("vw_CDSS_CUBlaneyCriddle", "13");
	__viewNumbers.put("vw_CDSS_CUModHargreaves", "14");
	__viewNumbers.put("vw_CDSS_CUPenmanMonteith", "15");
	__viewNumbers.put("vw_CDSS_CUPopulation", "107");
	__viewNumbers.put("vw_CDSS_CUPopulation_Distinct", "112");
	__viewNumbers.put("vw_CDSS_DailyAdminFlow", "113");
	__viewNumbers.put("vw_CDSS_DailyAmt", "16");
	__viewNumbers.put("vw_CDSS_DailyEVAP", "63");
	__viewNumbers.put("vw_CDSS_DailyFlow", "66");
	__viewNumbers.put("vw_CDSS_DailyMAXT", "61");
	__viewNumbers.put("vw_CDSS_DailyMINT", "60");
	__viewNumbers.put("vw_CDSS_DailyPcpn", "59");
	__viewNumbers.put("vw_CDSS_DailySnow", "65");
	__viewNumbers.put("vw_CDSS_DailySolar", "64");
	__viewNumbers.put("vw_CDSS_DailyVP", "62");
	__viewNumbers.put("vw_CDSS_DailyWind", "67");
	__viewNumbers.put("vw_CDSS_DailyWC", "17");
	__viewNumbers.put("vw_CDSS_Frost_Dates", "18");
	__viewNumbers.put("vw_CDSS_Irrig_Summary_TS", "19");
	__viewNumbers.put("vw_CDSS_MonthlyAdminFlow_MaxQ", "114");
	__viewNumbers.put("vw_CDSS_MonthlyAdminFlow_MinQ", "115");
	__viewNumbers.put("vw_CDSS_MonthlyAdminFlow_TotalAF", "116");
	__viewNumbers.put("vw_CDSS_MonthlyEvap", "55");
	__viewNumbers.put("vw_CDSS_MonthlyFlow_MaxQ", "53");
	__viewNumbers.put("vw_CDSS_MonthlyFlow_MinQ", "54");
	__viewNumbers.put("vw_CDSS_MonthlyFlow_TotalAF", "52");
	__viewNumbers.put("vw_CDSS_MonthlyNflow", "56");
	__viewNumbers.put("vw_CDSS_MonthlyPcpn", "57");
	__viewNumbers.put("vw_CDSS_MonthlySnow", "58");
	__viewNumbers.put("vw_CDSS_MonthlyTemp_Max", "50");
	__viewNumbers.put("vw_CDSS_MonthlyTemp_Mean", "49");
	__viewNumbers.put("vw_CDSS_MonthlyTemp_Min", "51");
	__viewNumbers.put("vw_CDSS_NetAmts", "20");
	__viewNumbers.put("vw_CDSS_Parcel_Use_TS", "21");
	
	if (version < VERSION_20050701) {
		__viewNumbers.put("vw_CDSS_Pump_Test", "22");
	}
	else {
		__viewNumbers.put("vw_CDSS_GroundWaterWellsDrillersKSum", "79");
		__viewNumbers.put("vw_CDSS_GroundWaterWellsGeophlogs", "76");
		__viewNumbers.put("vw_CDSS_GroundWaterWellsPumpingTests","77");
		__viewNumbers.put(
			"vw_CDSS_GroundWaterWellsGroundWaterWellsMeasType",
			"78");
		__viewNumbers.put("vw_CDSS_GroundWaterWellsVolcanics", "80");
	}

	__viewNumbers.put("vw_CDSS_RealTime_Telemetry", "45");	
	__viewNumbers.put("vw_CDSS_Res_EOM", "23");
	__viewNumbers.put("vw_CDSS_Res_Meas", "24");
	__viewNumbers.put("vw_CDSS_SnowCrse", "47");
	__viewNumbers.put("vw_CDSS_Station", "28");
	__viewNumbers.put("vw_CDSS_StationCUClimWts", "29");
	__viewNumbers.put("vw_CDSS_StationMeasType", "30");
	__viewNumbers.put("vw_CDSS_StationMeasType_Distinct", "68");
	__viewNumbers.put("vw_CDSS_Structure", "31");
	__viewNumbers.put("vw_CDSS_StructureIrrigSummaryTS", "32");
	__viewNumbers.put("vw_CDSS_StructureStructMeasType", "33");
	__viewNumbers.put("vw_CDSS_StructureIrrigSummaryTS_Distinct_LU",
		"74");
	__viewNumbers.put("vw_CDSS_Transact", "34");
	__viewNumbers.put("vw_CDSS_TSProduct", "35");
	
	if (version < VERSION_20050701) {
		__viewNumbers.put("vw_CDSS_Unpermitted_Wells", "36");
		__viewNumbers.put("vw_CDSS_UnpermittedWellStructMeasType", 
			"75");
	}
	
	__viewNumbers.put("vw_CDSS_WDWater", "37");
	__viewNumbers.put("vw_CDSS_Wells", "70");
	__viewNumbers.put("vw_CDSS_WellApplications", "38");

	__viewNumbers.put("vw_CDSS_WellMeas", "69");

	__viewNumbers.put("vw_CDSS_WellsWellToLayer", "71");
	__viewNumbers.put("vw_CDSS_WellsWellToParcelWellToStructure", "73");
	__viewNumbers.put("vw_CDSS_WellsWellToParcel", "48");
	__viewNumbers.put("vw_CDSS_WellsWellToStructure", "72");
	__viewNumbers.put("vw_CDSS_WISComments", "39");
	__viewNumbers.put("vw_CDSS_WISDailyWC_Diversion", "40");
	__viewNumbers.put("vw_CDSS_WISData", "41");
	__viewNumbers.put("vw_CDSS_WISDailyWC", "46");
	__viewNumbers.put("vw_CDSS_WISDailyWC_Release", "43");
	__viewNumbers.put("vw_CDSS_WISFormat", "44");
	__viewNumbers.put("vw_CDSS_WISSheetName", "25");
	__viewNumbers.put("vw_CDSS_WISSheetName_Distinct", "26");
	__viewNumbers.put("vw_CDSS_WISSheetNameWISFormat", "27");	
}

/**
Sets whether stored procedures should be used or not.
@param useSP if true, stored procedures will be used if they are available.
If false, stored procedures will not be used.
*/
public void setUseStoredProcedures(boolean useSP) {
	__useSP = useSP;
	
	if (__useSP) {
		__storedProcedureHashtable = new Hashtable();
	}
}

// T METHODS
// REVISIT (JTS - 2005-02-23)
// we could trim about 14000 lines of code from this if we moved all the
// toXXXXX() methods into a separate class and made them static.

/**
Translate a ResultSet to HydroBase_AgriculturalCASSCropStats objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_AgriculturalCASSCropStats.
*/
private Vector toAgriculturalCASSCropStatsList(ResultSet rs, boolean distinct)
throws Exception {
	HydroBase_AgriculturalCASSCropStats data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_AgriculturalCASSCropStats();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSt(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCommodity(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPractice(s.trim());
		}
		if (!distinct) {
			// All the other...
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setCal_year(i);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setPlanted(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setPltdHarv(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setHarvested(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setPltdYld(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setYield(d);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setYieldUnit(s.trim());
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setProduction(d);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setProductionUnit(s.trim());
			}			
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_AgriculturalCASSCropStats objects.
@param rs ResultSet to translate.
@param distinct whether it is a distinct query or not
@return a Vector of HydroBase_AgriculturalCASSCropStats.
*/
private Vector toAgriculturalCASSCropStatsSPList(ResultSet rs, boolean distinct)
throws Exception {
	HydroBase_AgriculturalCASSCropStats data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_AgriculturalCASSCropStats();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSt(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCommodity(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPractice(s.trim());
		}

		if (!distinct) {
			// All the other...
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setCal_year(i);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setPlanted(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setPltdHarv(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setHarvested(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setPltdYld(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setYield(d);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setYieldUnit(s.trim());
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setProduction(d);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setProductionUnit(s.trim());
			}			
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_AgriculturalCASSLivestockStats objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_AgriculturalLivestockCropStats.
*/
private Vector toAgriculturalCASSLivestockStatsList(
	ResultSet rs, boolean distinct)
throws Exception {
	HydroBase_AgriculturalCASSLivestockStats data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_AgriculturalCASSLivestockStats();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSt(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCommodity(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setType(s.trim());
		}
		if (!distinct) {
			// All the other...
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setCal_year(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setHead(i);
			}
		}

		v.add(data);
	}
	return v;
}

// REVISIT SAM 2006-10-31
// Why do we need a different version of this method for stored procedures?
// Both operate on a result set.
/**
Translate a ResultSet to HydroBase_AgriculturalCASSLivestockStats objects.
@param rs ResultSet to translate.
@param distinct whether it is a distinct query or not
@return a Vector of HydroBase_AgriculturalCASSLivestockStats.
*/
private Vector toAgriculturalCASSLivestockStatsSPList(
	ResultSet rs, boolean distinct)
throws Exception {
	HydroBase_AgriculturalCASSLivestockStats data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_AgriculturalCASSLivestockStats();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSt(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCommodity(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setType(s.trim());
		}

		if (!distinct) {
			// All the other...
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setCal_year(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setHead(i);
			}
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_AgriculturalNASSCropStats objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_AgriculturalNASSCropStats.
*/
private Vector toAgriculturalNASSCropStatsList(ResultSet rs, boolean distinct)
throws Exception {
	HydroBase_AgriculturalNASSCropStats data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_AgriculturalNASSCropStats();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSt(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCommodity(s.trim());
		}
		if (!distinct) {
			// All the other...
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setCal_year(i);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAg_amt(d);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setFlag(s.trim());
			}
		}
	
		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet from a stored procedure to 
HydroBase_AgriculturalNASSCropStats objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_AgriculturalNASSCropStats.
*/
private Vector toAgriculturalNASSCropStatsSPList(ResultSet rs, boolean distinct)
throws Exception {
	HydroBase_AgriculturalNASSCropStats data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_AgriculturalNASSCropStats();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSt(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCommodity(s.trim());
		}
		if (!distinct) {
			// All the other...
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setCal_year(i);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAg_amt(d);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setFlag(s.trim());
			}
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_AnnualAmt objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_AnnualAmt
@throws Exception if an error occurs.
*/
private Vector toAnnualAmtList (ResultSet rs) 
throws Exception {
	HydroBase_AnnualAmt data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_AnnualAmt();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQuality(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrr_year(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setFdu(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setLdu(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDwc(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setMaxq(d);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setMaxq_date(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setNobs(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setNus(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_nov(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_dec(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_jan(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_feb(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_mar(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_apr(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_may(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_jun(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_jul(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_aug(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_sep(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_oct(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAnn_amt(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFunc(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_AnnualResobjects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_ResMeas
@throws Exception if an error occurs.
*/
private Vector toAnnualResList (ResultSet rs) 
throws Exception {
	HydroBase_AnnualRes data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	double d;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_AnnualRes();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrr_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		dt = rs.getTimestamp(index++);
		if (!rs.wasNull()) {
			data.setFdu(dt);
		}
		dt = rs.getTimestamp(index++);
		if (!rs.wasNull()) {
			data.setLdu(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDwc(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAnn_amt(d);
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet from a view to HydroBase_AnnualResobjects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_ResMeas
@throws Exception if an error occurs.
*/
private Vector toAnnualResSPList (ResultSet rs) 
throws Exception {
	HydroBase_AnnualRes data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	double d;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_AnnualRes();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrr_year(i);
		}
		dt = rs.getTimestamp(index++);
		if (!rs.wasNull()) {
			data.setFdu(dt);
		}
		dt = rs.getTimestamp(index++);
		if (!rs.wasNull()) {
			data.setLdu(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDwc(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAnn_amt(d);
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_AnnualWC objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_AnnualWC
@throws Exception if an error occurs.
*/
private Vector toAnnualWCList (ResultSet rs) 
throws Exception {
	HydroBase_AnnualWC data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_AnnualWC();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQuality(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrr_year(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setFdu(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setLdu(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDwc(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setMaxq(d);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setMaxq_date(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setNobs(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setNus(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_nov(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_dec(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_jan(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_feb(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_mar(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_apr(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_may(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_jun(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_jul(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_aug(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_sep(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt_oct(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAnn_amt(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFunc(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setS(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setF(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setU(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setT(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translates a ResultSet to HydroBase_Aquifer objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Aquifer.
@throws Exception if an error occurs.
*/
private Vector toAquiferList(ResultSet rs)
throws Exception {
	HydroBase_Aquifer data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Aquifer();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAquifer_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer_code(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) { 
			data.setAquifer_name(s.trim());
		}
		
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_AreaCap objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_AreaCap
*/
private Vector toAreaCapList(ResultSet rs) 
throws Exception {
	HydroBase_AreaCap data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_AreaCap();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAc_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);		
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setElevation(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setGage_height(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setSurface_area(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setVolume(d);
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_Calls objects.
@param rs ResultSet to translate.
@param distinct whether the query was distrinct (true) or not (false)
@return a Vector of HydroBase_Calls
@throws Exception if an error occurs.
*/
private Vector toCallsList (ResultSet rs, boolean distinct) 
throws Exception {
	HydroBase_Calls data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Calls();
		if (!distinct) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setCall_num(i);
			}
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		if (!distinct) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setNet_num(i);
			}
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		if (!distinct) {
			dt = rs.getTimestamp(index++);
			if (!rs.wasNull()) {
				data.setDate_time_set(dt);
			}
			dt = rs.getTimestamp(index++);
			if (!rs.wasNull()) {
				data.setDate_time_released(dt);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAdminno(d);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDistricts_affected(s.trim());
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		if (!distinct) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setStrname(s.trim());
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setStrtribto(i);
			}
			dt = rs.getDate(index++);
			if (!rs.wasNull()) {
				data.setApro_date(dt);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDcr_amt(s.trim());
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setSet_comments(s.trim());
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setRelease_comments(s.trim());
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setRelease_call_num(i);
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDeleted(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		if (!distinct) {
			dt = rs.getTimestamp(index++);
			if (!rs.wasNull()) {
				data.setArchive_date(dt);
			}
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_Calls objects.
@param rs ResultSet to translate.
@param distinct whether the query was distrinct (true) or not (false)
@return a Vector of HydroBase_Calls
@throws Exception if an error occurs.
*/
private Vector toCallsSPList (ResultSet rs) 
throws Exception {
	HydroBase_Calls data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Calls();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCall_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setNet_num(i);
		}
		dt = rs.getTimestamp(index++);
		if (!rs.wasNull()) {
			data.setDate_time_set(dt);
		}
		dt = rs.getTimestamp(index++);
		if (!rs.wasNull()) {
			data.setDate_time_released(dt);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAdminno(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSet_comments(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRelease_comments(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDistricts_affected(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRelease_call_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDeleted(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		dt = rs.getTimestamp(index++);
		if (!rs.wasNull()) {
			data.setArchive_date(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStrname(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStrtribto(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setApro_date(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDcr_amt(s.trim());
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_Calls objects.
@param rs ResultSet to translate.
@param distinct whether the query was distrinct (true) or not (false)
@return a Vector of HydroBase_Calls
@throws Exception if an error occurs.
*/
private Vector toCallsSPDistinctList (ResultSet rs) 
throws Exception {
	HydroBase_Calls data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Calls();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDeleted(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_Contact objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Contact.
*/
private Vector toContactList(ResultSet rs) 
throws Exception {
	HydroBase_Contact data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	long version = getDatabaseVersion();
	String areaCode = null;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Contact();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setContact_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRolodex_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setContact_type(s.trim());
		}
		if (version < VERSION_19990305) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				areaCode = s.trim();
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setPhone_number(areaCode + s.trim());
			}
		}
		else {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setPhone_number(s.trim());
			}
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setContact_text(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFirst_contact(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRolodex_num(i);
		}
		if (version >= VERSION_19990305) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setPhone_ext(s.trim());
			}
		}

		v.add(data);
	}
	return v;
}
	
/**
Translate a ResultSet to HydroBase_Contact objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Contact.
*/
private Vector toContactSPList(ResultSet rs) 
throws Exception {
	HydroBase_Contact data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Contact();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setContact_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRolodex_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setContact_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPhone_number(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPhone_ext(s.trim());
		}	
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setContact_text(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFirst_contact(s.trim());
		}

		v.add(data);
	}
	return v;
}
	
/**
Translate a ResultSet to HydroBase_CountyRef objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_CountyRef.
@throws Exception if an error occurs.
*/
private Vector toCountyRefList (ResultSet rs) 
throws Exception {
	HydroBase_CountyRef data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_CountyRef();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFips_cty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFips_st(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}
		if (version < VERSION_19990305) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setAbbrev(s.trim());
			}
		}
		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_CourtCase objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_CourtCase
@throws Exception if an error occurs.
*/
private Vector toCourtCaseList (ResultSet rs) 
throws Exception {
	HydroBase_CourtCase data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_CourtCase();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCase_no_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCase_no(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCase_no_book(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCase_no_page(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCase_no_comment(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDecree_summary(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_CropRef objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_CropRef
@throws Exception if an error occurs.
*/
private Vector toCropRefList (ResultSet rs) 
throws Exception {
	HydroBase_CropRef data = null;
	Vector v = new Vector();
	int index = 1;
	
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_CropRef();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCrop_code(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCrop_desc(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_Cropchar objects.
@param rs ResultSet to translate.
@param distinct If true, indicates that a distinct query of Cropchar.method_desc
is occurring.
@return a Vector of HydroBase_Cropchar.
@throws Exception if an error occurs.
*/
private Vector toCropcharList(ResultSet rs, boolean distinct ) 
throws Exception {
	HydroBase_Cropchar data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Cropchar();
		if (!distinct) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setCropnum(i);
			}
		}
		if (version >= VERSION_20000427) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setMethod_desc(s.trim());
			}
		}
		if (!distinct) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setCropname(s.trim());
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setTempearlymoisture(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setTemplatemoisture(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setInitialroot(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setMaxroot(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setMadlevel(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setMaxappdepth(d);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setDaystofullcover(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setPlantingmon(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setPlantingday(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setHarvestmon(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setHarvestday(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setDaystofirstcut(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setDaysbetweencuts(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setLengthofseason(i);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setSpringfrostmethod(s.trim());
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setFallfrostmethod(s.trim());
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setIrrig_cropnum(i);
			}
		}
		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet from a view to HydroBase_Cropchar objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Cropchar.
@throws Exception if an error occurs.
*/
private Vector toCropcharSPList(ResultSet rs)
throws Exception {
	HydroBase_Cropchar data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Cropchar();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCropnum(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMethod_desc(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCropname(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTempearlymoisture(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTemplatemoisture(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setInitialroot(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setMaxroot(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setMadlevel(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setMaxappdepth(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDaystofullcover(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPlantingmon(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPlantingday(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setHarvestmon(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setHarvestday(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDaystofirstcut(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDaysbetweencuts(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setLengthofseason(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSpringfrostmethod(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFallfrostmethod(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrrig_cropnum(i);
		}
		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet from a distinct stored procedure to HydroBase_Cropchar 
objects.
@param rs ResultSet to translate.
@param distinct If true, indicates that a distinct query of Cropchar.method_desc
is occurring.
@return a Vector of HydroBase_Cropchar.
@throws Exception if an error occurs.
*/
private Vector toCropcharDistinctSPList(ResultSet rs)
throws Exception {
	HydroBase_Cropchar data = null;
	Vector v = new Vector();
	int index = 1;
	
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Cropchar();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMethod_desc(s.trim());
		}
		v.add(data);
	}
	return v;
}

/**
Convert a ResultSet to a Vector of HydroBase_CUBlaneyCriddle
@param rs ResultSet from a query
@param distinct if true, only the method_desc field is set in the returned
objects.
@return a Vector of HydroBase_CUBlaneyCriddle
*/
private Vector toCUBlaneyCriddleList(ResultSet rs, boolean distinct ) 
throws Exception {
	HydroBase_CUBlaneyCriddle data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	float f;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_CUBlaneyCriddle();
		if (!distinct) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setCropnum(i);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setCropname(s.trim());
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMethod_desc(s.trim());
		}
		if (!distinct) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setCurve_type(s.trim());
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setCurve_value(i);
			}
			f = rs.getFloat(index++);		
			if (!rs.wasNull()) {
				data.setCropgrowcoeff((double)f);
			}
		}

		v.add(data);
	}
	return v;
}

/**
Convert a ResultSet to a Vector of HydroBase_CUBlaneyCriddle
@param rs ResultSet from a query
@param distinct if true, only the method_desc field is set in the returned
objects.
@return a Vector of HydroBase_CUBlaneyCriddle
*/
private Vector toCUBlaneyCriddleDistinctSPList(ResultSet rs)
throws Exception {
	HydroBase_CUBlaneyCriddle data = null;
	Vector v = new Vector();
	int index = 1;

	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_CUBlaneyCriddle();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMethod_desc(s.trim());
		}
		v.add(data);
	}
	return v;
}

/**
Convert a ResultSet to a Vector of HydroBase_CUBlaneyCriddle
@param rs ResultSet from a query
@return a Vector of HydroBase_CUBlaneyCriddle
*/
private Vector toCUBlaneyCriddleSPList(ResultSet rs)
throws Exception {
	HydroBase_CUBlaneyCriddle data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	float f;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_CUBlaneyCriddle();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCropnum(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCropname(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMethod_desc(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCurve_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCurve_value(i);
		}
		f = rs.getFloat(index++);		
		if (!rs.wasNull()) {
			data.setCropgrowcoeff((double)f);
		}

		v.add(data);
	}
	return v;
}

/**
Translates a ResultSet into a Vector of HydroBase_CUCoeff objects.
@param rs the resultset to translate
@return a Vector of HydroBase_CUCoeff objects
*/
private Vector toCUCoeffList (ResultSet rs) 
throws Exception {
	HydroBase_CUCoeff data = null;
 	Vector v = new Vector();
	int index = 1;
	int i;
	String s;
	double d;
	while (rs.next()) {
		data = new HydroBase_CUCoeff();
		index = 1;
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setConsnum(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setConsname(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setConsuse(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setCU_coeff(d);
		}
	
		v.add(data);
	}
	return v;
}


/**
Translate a ResultSet to HydroBase_CUMethod objects.
@param rs ResultSet to translate.
@param distinct If true, only the description is transferred.
@return a Vector of HydroBase_CUMethod.
@throws Exception if an error occurs.
*/
private Vector toCUMethodList (ResultSet rs, boolean distinct) 
throws Exception {
	HydroBase_CUMethod data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_CUMethod();
		if (!distinct) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setMethod_num(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setCropnum(i);
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMethod_desc(s.trim());
		}
		v.add(data);
	}
	return v;
}

/**
Convert a ResultSet to a Vector of HydroBase_CUModHargreaves.
@param rs ResultSet from a query
@return a Vector of HydroBase_CUModHargreaves
*/
private Vector toCUModHargreavesList(ResultSet rs) 
throws Exception {
	HydroBase_CUModHargreaves data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	float f;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_CUModHargreaves();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCropnum(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCropname(s.trim());
		}
		i = rs.getInt(index++);		
		if (!rs.wasNull()) {
			data.setCover_10(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCover_80(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setFirstcut(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMaturity(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSecondcut(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setHarvest(i);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setK1(f);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setK2(f);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setK3(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMethod_desc(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Convert a ResultSet from a stored procedure to a Vector 
of HydroBase_CUModHargreaves.
@param rs ResultSet from a query
@return a Vector of HydroBase_CUModHargreaves
*/
private Vector toCUModHargreavesSPList(ResultSet rs) 
throws Exception {
	HydroBase_CUModHargreaves data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	float f;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_CUModHargreaves();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCropnum(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCropname(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMethod_desc(s.trim());
		}
		i = rs.getInt(index++);		
		if (!rs.wasNull()) {
			data.setCover_10(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCover_80(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setFirstcut(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMaturity(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSecondcut(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setHarvest(i);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setK1(f);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setK2(f);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setK3(f);
		}

		v.add(data);
	}

	return v;
}

/**
Convert a ResultSet to a Vector of HydroBase_CUPenmanMonteith
@param rs ResultSet from a query
@return a Vector of HydroBase_CUPenmanMonteith
*/
private Vector toCUPenmanMonteithList(ResultSet rs) 
throws Exception {
	HydroBase_CUPenmanMonteith data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	float f;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_CUPenmanMonteith();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCropnum(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCropname(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGrowthstage_no(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCurve_value(i);
		}
		f = rs.getFloat(index++);		
		if (!rs.wasNull()) {
			data.setCropgrowcoeff(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMethod_desc(s.trim());
		}

		v.add(data);
	}
	return v;
}

/**
Convert a ResultSet from a stored procedure to a Vector 
of HydroBase_CUPenmanMonteith
@param rs ResultSet from a query
@return a Vector of HydroBase_CUPenmanMonteith
*/
private Vector toCUPenmanMonteithSPList(ResultSet rs) 
throws Exception {
	HydroBase_CUPenmanMonteith data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	float f;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_CUPenmanMonteith();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCropnum(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCropname(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMethod_desc(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGrowthstage_no(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCurve_value(i);
		}
		f = rs.getFloat(index++);		
		if (!rs.wasNull()) {
			data.setCropgrowcoeff(f);
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_CUPopulation objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_CUPopulation.
*/
private Vector toCUPopulationList( ResultSet rs, boolean distinct)
throws Exception {
	HydroBase_CUPopulation data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_CUPopulation();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setArea_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setArea_name(s.trim());
		}
		if (!distinct) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setCal_year(i);
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPop_type(s.trim());
		}
		if (!distinct) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setPopulation(i);
			}
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_DailyAmt objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_DailyAmt
@throws Exception if an error occurs.
*/
private Vector toDailyAmtList (ResultSet rs) 
throws Exception {
	HydroBase_DailyAmt data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	int iday;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_DailyAmt();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQuality(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrr_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrr_mon(i);
		}
		for ( iday = 1; iday <=31; iday++) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAmountForDay(iday, d);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setObservationForDay(iday, s.trim());
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFunc(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_DailyWC objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_DailyWC
@throws Exception if an error occurs.
*/
private Vector toDailyWCList(ResultSet rs) 
throws Exception {
	HydroBase_DailyWC data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_DailyWC();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQuality(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrr_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrr_mon(i);
		}
		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt1(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs1(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt2(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs2(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt3(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs3(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt4(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs4(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt5(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs5(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt6(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs6(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt7(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs7(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt8(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs8(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt9(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs9(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt10(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs10(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt11(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs11(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt12(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs12(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt13(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs13(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt14(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs14(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt15(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs15(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt16(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs16(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt17(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs17(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt18(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs18(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt19(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs19(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt20(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs20(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt21(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs21(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt22(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs22(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt23(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs23(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt24(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs24(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt25(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs25(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt26(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs26(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt27(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs27(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt28(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs28(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt29(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs29(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt30(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs30(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt31(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs31(s.trim());
		}

		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFunc(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setS(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setF(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setU(s.trim());
		} 
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setT(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_DailyWC objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_DailyWC
@throws Exception if an error occurs.
*/
private Vector toDailyWCSPList(ResultSet rs) 
throws Exception {
	HydroBase_DailyWC data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_DailyWC();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQuality(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrr_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrr_mon(i);
		}
		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt1(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs1(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt2(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs2(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt3(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs3(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt4(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs4(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt5(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs5(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt6(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs6(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt7(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs7(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt8(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs8(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt9(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs9(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt10(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs10(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt11(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs11(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt12(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs12(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt13(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs13(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt14(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs14(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt15(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs15(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt16(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs16(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt17(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs17(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt18(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs18(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt19(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs19(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt20(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs20(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt21(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs21(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt22(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs22(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt23(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs23(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt24(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs24(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt25(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs25(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt26(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs26(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt27(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs27(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt28(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs28(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt29(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs29(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt30(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs30(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt31(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs31(s.trim());
		}

		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFunc(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setS(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setF(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setU(s.trim());
		} 
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setT(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_DailyPcpn objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_DailyPcpn
@throws Exception if an error occurs.
*/
private Vector toDailyPcpnList (ResultSet rs)
throws Exception {
	HydroBase_DailyPcpn data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i, iday;
	String s;
	double d;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_DailyPcpn();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		if (version >= VERSION_20010326) {
			// Add "b" flags...
			for ( iday = 1; iday <= 31; iday++) {
				d = rs.getDouble(index++);
				if (!rs.wasNull()) {
					data.setDay(iday, d);
				}
				s = rs.getString(index++);
				if (!rs.wasNull()) {
					data.setFlaga(iday, s.trim());
				}
				s = rs.getString(index++);
				if (!rs.wasNull()) {
					data.setFlagb(iday, s.trim());
				}
			}
		}
		else {
			// Only have one flag.  In the DB it is not called "a"
			// but use the "a" data members...
			for ( iday = 1; iday <= 31; iday++) {
				d = rs.getDouble(index++);
				if (!rs.wasNull()) {
					data.setDay(iday, d);
				}
				s = rs.getString(index++);
				if (!rs.wasNull()) {
					data.setFlaga(iday, s.trim());
				}
			}
		}
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_DailyTS objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_DailyTS
@throws Exception if an error occurs.
*/
private Vector toDailyTSList(ResultSet rs, int sqlNumber) 
throws Exception {
	HydroBase_DailyTS data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	boolean access = false;
	if (getDatabaseEngine().equalsIgnoreCase("Access")) {
		access = true;
	}

	int iday = 0;
	while (rs.next()) {
		index = 1;
		data = new HydroBase_DailyTS();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}

		if ((sqlNumber == __S_DAILY_FLOW
		    && access && getDatabaseVersion() < VERSION_20050501)
		    || 
		    (sqlNumber == __S_DAILY_FLOW 
		    && getDatabaseVersion() < VERSION_20010326)) {
			for ( iday = 1; iday <= 31; iday++) {
				d = rs.getDouble(index++);
				if (!rs.wasNull()) {
					data.setDay(iday, d);
				}
				s = rs.getString(index++);
				if (!rs.wasNull()) {
					data.setFlaga(iday, s.trim());
				}
			}
		}
		else {
			for ( iday = 1; iday <= 31; iday++) {
				d = rs.getDouble(index++);
				if (!rs.wasNull()) {
					data.setDay(iday, d);
				}
				s = rs.getString(index++);
				if (!rs.wasNull()) {
					data.setFlaga(iday, s.trim());
				}
				s = rs.getString(index++);
				if (!rs.wasNull()) {
					data.setFlagb(iday, s.trim());
				}
			}
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_DailyTS objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_DailyTS
@throws Exception if an error occurs.
*/
private Vector toDailyPcpnSPList(ResultSet rs)
throws Exception {
	HydroBase_DailyPcpn data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	int iday = 0;
	while (rs.next()) {
		index = 1;
		data = new HydroBase_DailyPcpn();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		for ( iday = 1; iday <= 31; iday++) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDay(iday, d);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setFlaga(iday, s.trim());
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setFlagb(iday, s.trim());
			}
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_DailyTS objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_DailyTS
@throws Exception if an error occurs.
*/
private Vector toDailyTSSPList(ResultSet rs)
throws Exception {
	HydroBase_DailyTS data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	int iday = 0;
	while (rs.next()) {
		index = 1;
		data = new HydroBase_DailyTS();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon_num(i);
		}				
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(s.trim());
		}				
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		for ( iday = 1; iday <= 31; iday++) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDay(iday, d);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setFlaga(iday, s.trim());
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setFlagb(iday, s.trim());
			}
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StructureDam objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureDam
@throws Exception if an error occurs.
*/
private Vector toDamList (ResultSet rs) 
throws Exception {
	HydroBase_StructureDam data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	float f;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureDam();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRes_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStaff_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAgency_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setOwner_status(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDamid(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setNatid(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHazard_class(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAband_code(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRemarks(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDown_town(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setDown_town_dist(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCompl_year(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPurposes(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFed_land(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFed_regs(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStrm_code(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDam_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setLength(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setHeight(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_height(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setHyd_height(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setCrest_width(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setCrest_elev(d);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setSpillway_capacity(f);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setOutlet_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setForestid(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPhase1(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		if (version < VERSION_19990305) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setAquifer_num(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setStream_num(i);
			}
		}	
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		if (version < VERSION_19990305) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setStr_mile(d);
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCiu(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setEst_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setEst_unit(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDcr_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDcr_unit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSTRTYPE(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTransbsn(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a dam stored procedure to 
HydroBase_StructureDam objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureDam
@throws Exception if an error occurs.
*/
private Vector toDamSPList (ResultSet rs) 
throws Exception {
	HydroBase_StructureDam data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	float f;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureDam();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRes_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStaff_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAgency_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setOwner_status(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDamid(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setNatid(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHazard_class(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAband_code(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRemarks(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDown_town(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setDown_town_dist(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCompl_year(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPurposes(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFed_land(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFed_regs(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStrm_code(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDam_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setLength(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setHeight(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_height(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setHyd_height(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setCrest_width(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setCrest_elev(d);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setSpillway_capacity(f);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setOutlet_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setForestid(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPhase1(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCiu(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSTRTYPE(s.trim());
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setEst_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setEst_unit(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDcr_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDcr_unit(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTransbsn(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_DamInspection objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_DamInspection
@throws Exception if an error occurs.
*/
private Vector toDamInspectionList (ResultSet rs) 
throws Exception {
	HydroBase_DamInspection data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_DamInspection();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDam_inspect_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setOutlet_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDamid(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setInspection_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setInspect_login(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setInspect_date(dt);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure to 
HydroBase_DamInspection objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_DamInspection
@throws Exception if an error occurs.
*/
private Vector toDamInspectionSPList (ResultSet rs) 
throws Exception {
	HydroBase_DamInspection data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_DamInspection();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDam_inspect_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setOutlet_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDamid(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setInspect_login(s.trim());
		}		
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setInspect_date(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setInspection_type(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_DamOutlet objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_DamOutlet
@throws Exception if an error occurs.
*/
private Vector toDamOutletList (ResultSet rs) 
throws Exception {
	HydroBase_DamOutlet data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_DamOutlet();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setOutlet_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDamid(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setOutlet_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setType(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setDiameter(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLength(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDescription(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setCapacity(d);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_DamSpillway objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_DamSpillway
@throws Exception if an error occurs.
*/
private Vector toDamSpillwayList (ResultSet rs) 
throws Exception {
	HydroBase_DamSpillway data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_DamSpillway();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDam_spillway_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDamid(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSpillway_name(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setWidth(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setFreeboard(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setWall_side_slope(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCapacity(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSply_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSply_code(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Convert a ResultSet to a Vector of HydroBase_DBVersion.
@param rs ResultSet from a db_version table query.
*/
private Vector toDBVersionList (ResultSet rs) 
throws Exception {
	HydroBase_DBVersion data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	Date d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_DBVersion();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setVersion_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setVersion_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setVersion_id(i);
		}
		d = rs.getTimestamp(index++);
		if (!rs.wasNull()) {
			data.setVersion_date(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setVersion_comment(s.trim());
		}
		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_DiversionComment objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_DiversionComment
@throws Exception if an error occurs.
*/
private Vector toDiversionCommentList (ResultSet rs) 
throws Exception {
	HydroBase_DiversionComment data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	float f;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_DiversionComment();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setNot_used(s.trim());
		}
		dt = rs.getTimestamp(index++);
		if (!rs.wasNull()) {
			data.setComm_date(dt);
			data.setIrr_year(
				StringUtil.atoi(TimeUtil.formatTimeString(
				dt, "%Y")));
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDiver_comment(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setAcres_irrig(f);
		}
		
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_EmergencyPlan objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_EmergencyPlan
@throws Exception if an error occurs.
*/
private Vector toEmergencyPlanList (ResultSet rs) 
throws Exception {
	HydroBase_EmergencyPlan data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_EmergencyPlan();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setEmer_plan_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setEplan(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setEp_date(dt);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_Equipment objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Equipment
@throws Exception if an error occurs.
*/
private Vector toEquipmentList (ResultSet rs) 
throws Exception {
	HydroBase_Equipment data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Equipment();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setEquip_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setDate_installed(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMeas_device(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRecorder(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}		

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_Equipment objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Equipment
@throws Exception if an error occurs.
*/
private Vector toEquipmentSPList (ResultSet rs) 
throws Exception {
	HydroBase_Equipment data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Equipment();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setEquip_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setDate_installed(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMeas_device(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRecorder(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_FrostDates objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_FrostDates
@throws Exception if an error occurs.
*/
private Vector toFrostDatesList (ResultSet rs) 
throws Exception {
	HydroBase_FrostDates data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_FrostDates();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setL28s(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setL32s(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setF32f(dt);
		}		
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setF28f(dt);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_FrostDates objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_FrostDates
@throws Exception if an error occurs.
*/
private Vector toFrostDatesSPList (ResultSet rs) 
throws Exception {
	HydroBase_FrostDates data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_FrostDates();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setL28s(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setF28f(dt);
		}		
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setL32s(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setF32f(dt);
		}		

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_GeneralComment objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_GeneralComment
@throws Exception if an error occurs.
*/
private Vector toGeneralCommentList (ResultSet rs) 
throws Exception {
	HydroBase_GeneralComment data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	Date dt;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_GeneralComment();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}

		if (version >= VERSION_19990305) {
			dt = rs.getDate(index++);
			if (!rs.wasNull()) {
				data.setDate_entered(dt);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setComment(s.trim());
			}
		} 
		else {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setGenl_comm_num(i);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setGenl_comment(s.trim());
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setNotes(s.trim());
			}
		}
		
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_Geoloc objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Geoloc
@throws Exception if an error occurs.
*/
private Vector toGeolocList (ResultSet rs) 
throws Exception {
	HydroBase_Geoloc data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Geoloc();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsns(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsns_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsew(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsew_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		if (version >= VERSION_20010326) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setElev(d);
			}
		}
		else if (version >= VERSION_20000427) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setElevation(d);
			}
		}
		else {
			// older databases had elevation in station
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFeature_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAccuracy(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAquifer_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStream_num(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_description(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSpotter_version(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setUser_num(i);
		}
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_Geoloc objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Geoloc
@throws Exception if an error occurs.
*/
private Vector toGeolocSPList (ResultSet rs) 
throws Exception {
	HydroBase_Geoloc data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Geoloc();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsns(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsns_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsew(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsew_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setElev(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFeature_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAccuracy(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAquifer_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStream_num(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_description(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSpotter_version(s.trim());
		}
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_GroundWaterWellsGeophlogs objects 
(but includes no groundwater data).
@param rs ResultSet to translate.
@return a Vector of HydroBase_GroundWaterWellsGeophlogs
@throws Exception if an error occurs.
*/
private Vector toGeophlogsList(ResultSet rs)
throws Exception {
	HydroBase_GroundWaterWellsGeophlogs data = null;
	Vector v = new Vector();
	int index = 1;
	
	boolean b;
	Date dt;
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_GroundWaterWellsGeophlogs();

		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGlogtop(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGlogbase(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGlogthickness(i);
		}
		b = rs.getBoolean(index++);
		if (!rs.wasNull()) {
			data.setOrig_1986(b);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setComment(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setModified(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUser(s.trim());
		}
		
		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_GroundWaterWellsDrillersKSum objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_GroundWaterWellsDrillersKSum
@throws Exception if an error occurs.
*/
private Vector toGroundWaterWellsDrillersKSumList(ResultSet rs) 
throws Exception {
	HydroBase_GroundWaterWellsDrillersKSum data = null;
	Vector v = new Vector();
	int index = 1;
	
	double d;
	int i;
	String s;
	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_GroundWaterWellsDrillersKSum();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDunctop(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDuncbase(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDunctopbasek(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDcontop(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setD500(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDcon500k(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.set_2d500(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setD1000(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setD500to1000k(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.set_2d1000(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.set_1500(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setD1000_1500k(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.set_2d1500(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setD2000(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setD1500_2000k(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.set_2d2000(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setD2500(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setD2000_2500(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.set_2d2500(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setD3000(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.set_2d3000(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setD2500_3000(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setD3500(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setD3000_3500k(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.set_2d3500(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setD4000(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setD3500_4000k(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWell_name(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setReceipt(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPermitno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitsuf(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitrpl(s.trim());
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLocnum(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSite_id(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setBasin(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMD(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_depth(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer_comment(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBperf(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setYield(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setBedrock_elev(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setSat_1965(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRemarks1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRemarks2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_source_id(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_source(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsns(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsns_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsew(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsew_dir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setElev(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setElev_accuracy(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setLoc_accuracy(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStream_num(i);
		}		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSpotter_version(s.trim());
		}				

		if (version >= VERSION_20051115) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer1(s.trim());
			}				
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer2(s.trim());
			}				
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer_comment(s.trim());
			}				
		}
		
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_GroundWaterWellsPumpingTest objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_GroundWaterWellsPumpTest
@throws Exception if an error occurs.
*/
private Vector toGroundWaterWellsPumpingTestList (ResultSet rs) 
throws Exception {
	HydroBase_GroundWaterWellsPumpingTest data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;
	long version = getDatabaseVersion();

	if (getDatabaseVersion() < VERSION_20050701) {

	while (rs.next()) {
		index = 1;
		data = new HydroBase_GroundWaterWellsPumpingTest();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTswl(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTfwl(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTestq(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTesttime(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTrans(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setK(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStorativity(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLeakance(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setToptestint(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBasetestint(i);
		}		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setDrawdown(d);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setTestdate(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPtsource(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPttype(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPtmon(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPtobs(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPtmultiple(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setSp_cap(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}

		v.add(data);
	}

	}
	else {
	while (rs.next()) {
		index = 1;
		data = new HydroBase_GroundWaterWellsPumpingTest();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_num(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTswl(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTfwl(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTestq(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTesttime(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTrans(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setK(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStorativity(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLeakance(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setToptestint(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBasetestint(i);
		}		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setDrawdown(d);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setTestdate(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPtsource(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPttype(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPtmon(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPtobs(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPtmultiple(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setSp_cap(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWell_name(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setReceipt(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPermitno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitsuf(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitrpl(s.trim());
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLocnum(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSite_id(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setBasin(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMD(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_depth(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer_comment(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBperf(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setYield(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setBedrock_elev(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setSat_1965(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRemarks1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRemarks2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_source_id(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_source(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsns(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsns_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsew(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsew_dir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setElev(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setElev_accuracy(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setLoc_accuracy(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStream_num(i);
		}		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSpotter_version(s.trim());
		}		

		if (version >= VERSION_20051115) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer1(s.trim());
			}				
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer2(s.trim());
			}				
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer_comment(s.trim());
			}				
		}		
		
		v.add(data);
	}

	}

	return v;
}

/**
Translates a ResultSet from reading from the GroundWaterWells and Geophlogs
tables into a Vector of HydroBase_GroundWaterWellsView objects.
@param rs the ResultSet from the query.
@return a Vector of HydroBase_GroundWaterWellsView Objects.
@throws Exception if an error occurs.
*/
private Vector toGroundWaterWellsGeophlogsList(ResultSet rs) 
throws Exception {
	HydroBase_GroundWaterWellsGeophlogs data = null;
	Vector v = new Vector();
	int index = 1;
	
	Date dt;
	double d;
	int i;
	String s;
	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_GroundWaterWellsGeophlogs();

		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWell_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setReceipt(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPermitno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitsuf(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitrpl(s.trim());
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLocnum(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSite_id(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setBasin(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMD(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_depth(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setLog_depth(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLog_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setLog_swl(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setLog_date(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer_comment(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBperf(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setYield(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setBedrock_elev(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setSat_1965(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRemarks1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRemarks2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_source_id(s.trim());
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_source(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsns(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsns_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsew(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsew_dir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setElev(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setElev_accuracy(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setLoc_accuracy(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStream_num(i);
		}		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSpotter_version(s.trim());
		}		
		
		if (version >= VERSION_20051115) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer1(s.trim());
			}				
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer2(s.trim());
			}				
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer_comment(s.trim());
			}				
		}

		v.add(data);
	}
	
	return v;
}

/**
Translate a ResultSet to HydroBase_GroundWaterWellsVolcanics objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_GroundWaterWellsVolcanics
@throws Exception if an error occurs.
*/
private Vector toGroundWaterWellsVolcanicsList(ResultSet rs) 
throws Exception {
	HydroBase_GroundWaterWellsVolcanics data = null;
	Vector v = new Vector();
	int index = 1;
	
	double d;
	int i;
	String s;
	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_GroundWaterWellsVolcanics();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setVoltop(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setVolbase(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWell_name(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setReceipt(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPermitno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitsuf(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitrpl(s.trim());
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLocnum(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSite_id(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setBasin(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMD(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_depth(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer_comment(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBperf(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setYield(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setBedrock_elev(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setSat_1965(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRemarks1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRemarks2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_source_id(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_source(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsns(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsns_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsew(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsew_dir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setElev(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setElev_accuracy(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setLoc_accuracy(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStream_num(i);
		}		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSpotter_version(s.trim());
		}				

		if (version >= VERSION_20051115) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer1(s.trim());
			}				
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer2(s.trim());
			}				
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer_comment(s.trim());
			}				
		}
		
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_LocType objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_LocType
@throws Exception if an error occurs.
*/
private Vector toLocTypeList (ResultSet rs) 
throws Exception {
	HydroBase_LocType data = null;
	Vector v = new Vector();
	int index = 1;
	
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_LocType();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type_desc(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_Mapfile objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Mapfile
@throws Exception if an error occurs.
*/
private Vector toMapfileList (ResultSet rs) 
throws Exception {
	HydroBase_Mapfile data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Mapfile();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMapfile_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMap_file_no(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMap_suffix(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMap_supp_stmt(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMap_file(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setMap_file_date(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_Mapfile objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Mapfile
@throws Exception if an error occurs.
*/
private Vector toMapfileSPList (ResultSet rs) 
throws Exception {
	HydroBase_Mapfile data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Mapfile();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMapfile_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMap_file_no(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMap_suffix(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMap_supp_stmt(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMap_file(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setMap_file_date(dt);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_MeasType objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_MeasType
@throws Exception if an error occurs.
*/
private Vector toMeasTypeDistinctList(ResultSet rs) 
throws Exception {
	HydroBase_MeasType data = null;
	Vector v = new Vector();
	int index = 1;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_MeasType();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMeas_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTime_step(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_source(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setVax_field(s.trim());
		}
		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_MonthlyPcpn objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_MonthlyPcpn
@throws Exception if an error occurs.
*/
private Vector toMonthlyPcpnList (ResultSet rs) 
throws Exception {
	HydroBase_MonthlyPcpn data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_MonthlyPcpn();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTotal_pcpn(d);
		}
		
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_MonthlyTemp objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_MonthlyTemp
@throws Exception if an error occurs.
*/
private Vector toMonthlyTempList (ResultSet rs, int sqlNumber) 
throws Exception {
	HydroBase_MonthlyTemp data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_MonthlyTemp();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			switch(sqlNumber) {
				case __S_MONTHLY_AVG_MAX_T:
					data.setAvg_max_t(d);	break;
				case __S_MONTHLY_AVG_MIN_T:
					data.setAvg_min_t(d);	break;
				case __S_MONTHLY_MEAN_T:
					data.setMean_t(d);	break;
				default:
					throw new Exception ("bad sqlNumber " +
					"value (" + sqlNumber + ") passed to " +
					"toMonthlyTempList()");
			}
		}
		
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_MonthlyEvap objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_MonthlyEvap
@throws Exception if an error occurs.
*/
private Vector toMonthlyEvapList (ResultSet rs) 
throws Exception {
	HydroBase_MonthlyEvap data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_MonthlyEvap();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTotal_evap(d);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_MonthlySnow objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_MonthlySnow
@throws Exception if an error occurs.
*/
private Vector toMonthlySnowList (ResultSet rs) 
throws Exception {
	HydroBase_MonthlySnow data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_MonthlySnow();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTotal_snow(d);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_MonthlyFlow objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_MonthlyFlow
@throws Exception if an error occurs.
*/
private Vector toMonthlyFlowList (ResultSet rs, int sqlNumber) 
throws Exception {
	HydroBase_MonthlyFlow data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_MonthlyFlow();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			switch(sqlNumber) {
				case __S_MONTHLY_MAX_ADMIN_FLOW:
				case __S_MONTHLY_MAX_FLOW:
					data.setMax_q_cfs(d);	break;
				case __S_MONTHLY_MIN_ADMIN_FLOW:
				case __S_MONTHLY_MIN_FLOW:
					data.setMin_q_cfs(d);	break;
				case __S_MONTHLY_TOTAL_ADMIN_FLOW:
				case __S_MONTHLY_TOTAL_FLOW:
					data.setTotal_q_af(d);	break;
				default:
					throw new Exception ("bad sqlNumber " +
					"value (" + sqlNumber + ") passed to " +
					"toMonthlyFlowList()");
			}
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_MonthlyNflow objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_MonthlyNflow
@throws Exception if an error occurs.
*/
private Vector toMonthlyNflowList (ResultSet rs) 
throws Exception {
	HydroBase_MonthlyNflow data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_MonthlyNflow();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTotal_q_af(d);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_NetAmts objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_NetAmts
@throws Exception if an error occurs.
*/
private Vector toNetAmtsList (ResultSet rs) 
throws Exception {
	HydroBase_NetAmts data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_NetAmts();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setNet_num(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAdj_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setPadj_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setApro_date(dt);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAdmin_no(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_rate_abs(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_rate_apex(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_vol_abs(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_vol_apex(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_rate_cond(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_vol_cond(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setOrder_no(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRight_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWr_stream_no(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAdj_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPri_case_no(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRng(s.trim());
		}
		if (!getDatabaseEngine().equalsIgnoreCase("Access")
		    && version >= VERSION_20040701) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setRdir(s.trim());
			}
		}
		else if (getDatabaseEngine().equalsIgnoreCase("Access")
		    && version > VERSION_20040701) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setRdir(s.trim());
			}
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTab_trib(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTS(s.trim());
		}
		if (!getDatabaseEngine().equalsIgnoreCase("Access")
		    && version >= VERSION_20040701) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setTdir(s.trim());
			}		
		}
		else if (getDatabaseEngine().equalsIgnoreCase("Access")
		    && version > VERSION_20040701) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setTdir(s.trim());
			}		
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWd_stream_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWr_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStrtype(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAction_comment(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAbs(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setApex(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_apex(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCond(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_cond(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_abs(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}		

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a NetAmts SPFlex query to HydroBase_NetAmts objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_NetAmts
@throws Exception if an error occurs.
*/
private Vector toNetAmtsSPList (ResultSet rs) 
throws Exception {
	HydroBase_NetAmts data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_NetAmts();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setNet_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTab_trib(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWr_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWr_stream_no(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWd_stream_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStrtype(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRng(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTS(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAdj_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setPadj_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setApro_date(dt);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAdmin_no(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setOrder_no(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPri_case_no(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAdj_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_rate_abs(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_vol_abs(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_rate_cond(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_vol_cond(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_rate_apex(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_vol_apex(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAbs(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCond(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setApex(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_abs(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_cond(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNet_apex(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAction_comment(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRight_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}		

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_ParcelUseTS objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_ParcelUseTS
@throws Exception if an error occurs.
*/
private Vector toParcelUseTSList (ResultSet rs, boolean distinct) 
throws Exception {
	HydroBase_ParcelUseTS data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_ParcelUseTS();
		if (!distinct) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setParcel_num(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setDiv(i);
			}
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		if (!distinct) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setParcel_id(i);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setPerimeter(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setArea(d);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setLand_use(s.trim());
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setIrrig_type(s.trim());
			}
		}
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_ParcelUseTSStructureToParcel objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_ParcelUseTS
@throws Exception if an error occurs.
*/
private Vector toParcelUseTSStructureToParcelList (ResultSet rs) 
throws Exception {
	HydroBase_ParcelUseTSStructureToParcel data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_ParcelUseTSStructureToParcel();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setParcel_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setParcel_id(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setPerimeter(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setArea(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLand_use(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setIrrig_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPrimary_flag(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setPercent_irrig(d);
		}
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_PersonDetails objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_PersonDetails
@throws Exception if an error occurs.
*/
private Vector toPersonDetailsList (ResultSet rs) 
throws Exception {
	HydroBase_PersonDetails data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_PersonDetails();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRolodex_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setType(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setNote(s.trim());
		}

		if (version < VERSION_19990305) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAmount(d);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setPriority(s.trim());
			}
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_RefCIU objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_ResEOM
@throws Exception if an error occurs.
*/
private Vector toRefCIUList(ResultSet rs)
throws Exception {
	HydroBase_RefCIU data = null;
	Vector v = new Vector();
	int index = 1;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_RefCIU();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCode(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDescription(s.trim());
		}
		if (__useSP) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setShort_desc(s.trim());
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRpt_code(s.trim());
		}
		if (!__useSP && getDatabaseVersion() > VERSION_20040701) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setShort_desc(s.trim());
			}
		}		
		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_ResEOM objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_ResEOM
@throws Exception if an error occurs.
*/
private Vector toResEOMList (ResultSet rs) 
throws Exception {
	HydroBase_ResEOM data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_ResEOM();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTotal_af(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_src(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_ResEOM objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_ResEOM
@throws Exception if an error occurs.
*/
private Vector toResEOMSPList (ResultSet rs) 
throws Exception {
	HydroBase_ResEOM data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_ResEOM();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon_num(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTotal_af(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_src(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_ResMeas objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_ResMeas
@throws Exception if an error occurs.
*/
private Vector toResMeasList (ResultSet rs) 
throws Exception {
	HydroBase_ResMeas data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	double d;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_ResMeas();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setDate_time(dt);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setGage_height(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStorage_amt(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setFill_amt(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setRelease_amt(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setEvap_loss_amt(d);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_Rolodex objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Rolodex
@throws Exception if an error occurs.
*/
private Vector toRolodexList (ResultSet rs) 
throws Exception {
	HydroBase_Rolodex data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	int i2;
	String s;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Rolodex();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRolodex_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLast_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFirst_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMiddle_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTitle(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPrefix(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSuffix(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFull_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAddress1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAddress2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCity(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}
		if (version >= VERSION_19990305) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setZip(s.trim());
			}
		}
		else {
			i = rs.getInt(index++);
			i2 = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setZip("" + i + "-" + i2);
			}
			else {
				data.setZip("" + i);
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setOrg_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setBond_co_name(s.trim());
		}
		if (version >= VERSION_19990305) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setLic_no(s.trim());
			}
		}
//		s = rs.getString(index++);
//		if (!rs.wasNull()) {
//			data.setXaoo(s.trim());
//		}
//		s = rs.getString(index++);
//		if (!rs.wasNull()) {
//			data.setXaoo2(s.trim());
//		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_Rolodex objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Rolodex
@throws Exception if an error occurs.
*/
private Vector toRolodexSPList (ResultSet rs) 
throws Exception {
	HydroBase_Rolodex data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Rolodex();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRolodex_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLast_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFirst_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMiddle_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTitle(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPrefix(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSuffix(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFull_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAddress1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAddress2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCity(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setZip(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setOrg_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setBond_co_name(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_RTMeas objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_RTMeas
@throws Exception if an error occurs.
*/
private Vector toRTMeasList (ResultSet rs) 
throws Exception {
	HydroBase_RTMeas data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_RTMeas();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		dt = rs.getTimestamp(index++);
		if (!rs.wasNull()) {
			data.setDate_time(dt);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFlag(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WISSheetName objects.
@param rs ResultSet to translate.
@param type the kind of query that was executed
@return a Vector of HydroBase_WISSheetName
@throws Exception if an error occurs.
*/
private Vector toSheetNameList (ResultSet rs, int type) 
throws Exception {
	HydroBase_WISSheetName data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WISSheetName();
		if (type != __S_WIS_SHEET_NAME_DISTINCT) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setWis_num(i);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setSheet_name(s.trim());
			}
			dt = rs.getTimestamp(index++);
			if (!rs.wasNull()) {
				data.setEffective_date(dt);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setWD(i);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setGain_method(s.trim());
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setSheet_type(s.trim());
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setComments(s.trim());
			}
		}
		else if (type == __S_WIS_SHEET_NAME_DISTINCT) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setSheet_name(s.trim());
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setWD(i);
			}
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WISSheetNameWISFormat objects.
@param rs ResultSet to translate.
@param type the kind of query that was executed
@return a Vector of HydroBase_WISSheetName
@throws Exception if an error occurs.
*/
private Vector toSheetNameWISFormatList (ResultSet rs, int type) 
throws Exception {
	HydroBase_WISSheetNameWISFormat data = null;
	Vector v = new Vector();
	int index = 1;
	
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WISSheetNameWISFormat();
		// The following are 
		//	for __S_WIS_SHEET_NAME_WIS_FORMAT_DISTINCT...
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSheet_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setIdentifier(s.trim());
		}
		// For distinct, all other fields are missing.

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_SnowCrse objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_SnowCrse
@throws Exception if an error occurs.
*/
private Vector toSnowCrseList (ResultSet rs) 
throws Exception {
	HydroBase_SnowCrse data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_SnowCrse();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDay(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setM_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setM_type(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDepth(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setSwe(d);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_SnowCrse objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_SnowCrse
@throws Exception if an error occurs.
*/
private Vector toSnowCrseSPList (ResultSet rs) 
throws Exception {
	HydroBase_SnowCrse data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_SnowCrse();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon_num(i);
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDay(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setM_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setM_type(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDepth(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setSwe(d);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_Station objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Station
@throws Exception if an error occurs.
*/
private Vector toStationList (ResultSet rs) 
throws Exception {
	HydroBase_Station data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Station();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStation_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStation_id(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setDrain_area(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setContr_area(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSource(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAbbrev(s.trim());
		}
		if (version >= VERSION_19990305) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setTransbsn(i);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setNesdis_id(s.trim());
			}
		}
		else {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setTransmit(s.trim());
			}
		}
		

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StationGeoloc objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StationGeoloc
@throws Exception if an error occurs.
*/
private Vector toStationGeolocList (ResultSet rs)
throws Exception {
	HydroBase_StationGeoloc data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StationGeoloc();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsns(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsew(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStation_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStation_id(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setDrain_area(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setContr_area(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			if (version >= VERSION_20010326) {
				data.setElev(d);
			}
			else if (version >= VERSION_20000427) {
				data.setElevation(d);
			}
			else {
				data.setElevation(d);
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSource(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAbbrev(s.trim());
		}
		if (version < VERSION_19990305) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setTransmnt(s.trim());
			}
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStream_num(i);
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		if (version >= VERSION_19990305) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setTransbsn(i);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setNesdis_id(s.trim());
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setUtm_x(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setUtm_y(d);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setCoordsns_dir(s.trim());
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setCoordsew_dir(s.trim());
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setFeature_type(s.trim());
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setAccuracy(i);
			}
		}
		v.add(data);
	}

	return v;
}

/**
Translates a ResultSet into a Vector of HydroBase_StationGeolocCUClimWts
objects.
@param rs the resultset to translate
@return a Vector of HydroBase_StationGeolocCUClimWts objects
*/
private Vector toStationGeolocCUClimWtsList (ResultSet rs) 
throws Exception {
	HydroBase_StationGeolocCUClimWts data = null;
 	Vector v = new Vector();
	int index = 1;
	int i;
	String s;
	double d;
	while (rs.next()) {
		data = new HydroBase_StationGeolocCUClimWts();
		index = 1;
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHydrounit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTemp_wt(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setPcpn_wt(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStation_id(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}

		v.add(data);
	}
	return v;
}

/**
Translates a ResultSet from a stored procedure into a Vector of 
HydroBase_StationGeolocCUClimWts objects.
@param rs the resultset to translate
@return a Vector of HydroBase_StationGeolocCUClimWts objects
*/
private Vector toStationGeolocCUClimWtsSPList (ResultSet rs) 
throws Exception {
	HydroBase_StationGeolocCUClimWts data = null;
 	Vector v = new Vector();
	int index = 1;
	int i;
	String s;
	double d;
	long version = getDatabaseVersion();
	while (rs.next()) {
		data = new HydroBase_StationGeolocCUClimWts();
		index = 1;
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStation_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStation_id(s.trim());
		}
		if (version >= VERSION_20040701) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setCooperator_id(s.trim());
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setNesdis_id(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setDrain_area(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setContr_area(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSource(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAbbrev(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTransbsn(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHydrounit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTemp_wt(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setPcpn_wt(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setElev(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAccuracy(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_StationView objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StationView
@throws Exception if an error occurs.
@param distinct whether this is a distinct query or not
*/
private Vector toStationSPList(ResultSet rs)
throws Exception {
	HydroBase_StationView data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StationView();
		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStation_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStation_id(s.trim());
		}
		if (version >= VERSION_20040701) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setCooperator_id(s.trim());
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setNesdis_id(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setDrain_area(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setContr_area(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSource(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAbbrev(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTransbsn(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setElev(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAccuracy(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}	

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StationView objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StationView
@throws Exception if an error occurs.
@param distinct whether this is a distinct query or not
*/
private Vector toStationMeasTypeSPList(ResultSet rs, boolean distinct)
throws Exception {
	HydroBase_StationView data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StationView();
		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStation_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStation_id(s.trim());
		}
		if (version >= VERSION_20040701) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setCooperator_id(s.trim());
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setNesdis_id(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setDrain_area(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setContr_area(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSource(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAbbrev(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTransbsn(i);
		}
		if (!distinct) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setMeas_num(i);
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMeas_type(s.trim());
		}
		if (!distinct) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setTime_step(s.trim());
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setStart_year(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setEnd_year(i);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setVax_field(s.trim());
			}		
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setTransmit(s.trim());
			}		
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setMeas_count(i);
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_source(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setElev(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAccuracy(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}		
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StrType objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StrType
@throws Exception if an error occurs.
*/
private Vector toStrTypeList (ResultSet rs) 
throws Exception {
	HydroBase_StrType data = null;
	Vector v = new Vector();
	int index = 1;
	
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StrType();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_type_desc(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRpt_code(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_Stream objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Stream
@throws Exception if an error occurs.
*/
private Vector toStreamList (ResultSet rs) 
throws Exception {
	HydroBase_Stream data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Stream();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStream_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStream_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStr_trib_to(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_Stream objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Stream
@throws Exception if an error occurs.
*/
private Vector toStreamSPList (ResultSet rs) 
throws Exception {
	HydroBase_Stream data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Stream();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStream_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStr_trib_to(i);
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStream_name(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StructMeasType objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructMeasType
@throws Exception if an error occurs.
*/
private Vector toStructMeasTypeDistinctList(ResultSet rs) 
throws Exception {
	HydroBase_StructMeasType data = null;
	Vector v = new Vector();
	int index = 1;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructMeasType();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMeas_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTime_step(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_source(s.trim());
		}
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StructMeasTypeView objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructMeasType
@throws Exception if an error occurs.
*/
private Vector toStructMeasTypeSPList (ResultSet rs)
throws Exception {
	HydroBase_StructMeasTypeView data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	boolean access = false;
	if (getDatabaseEngine().equalsIgnoreCase("Access")) {
		access = true;
	}

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructMeasTypeView();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsns(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsns_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsew(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsew_dir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setElev(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		if (!access && getDatabaseVersion() == VERSION_20050501) {

		}
		else {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setST(s.trim());
			}
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMeas_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTime_step(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStart_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setEnd_year(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setIdentifier(s.trim());
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTransmit(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_count(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_source(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StructureAKA objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureAKA
@throws Exception if an error occurs.
*/
private Vector toStructureAKAList (ResultSet rs) 
throws Exception {
	HydroBase_StructureAKA data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureAKA();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_aka_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStructure_aka_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_StructureAKA objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureAKA
@throws Exception if an error occurs.
*/
private Vector toStructureAKASPList (ResultSet rs) 
throws Exception {
	HydroBase_StructureAKA data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureAKA();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_aka_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStructure_aka_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StructureIrrigSummary objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureIrrigSummary
@throws Exception if an error occurs.
*/
private Vector toStructureIrrigSummaryList (ResultSet rs) 
throws Exception {
	HydroBase_StructureIrrigSummary data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	float f;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureIrrigSummary();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCiu(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setEst_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setEst_unit(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDcr_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDcr_unit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSTRTYPE(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTia_gis(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTia_gis_calyear(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTia_div(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTia_div_calyear(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTia_struct(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTia_struct_calyear(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StructureIrrigSummaryTS objects.
@param rs ResultSet to translate.
@param sqlcode Indicates the SQL statement that was executed.
@return a Vector of HydroBase_StructureIrrigSummaryTS.
@throws Exception if an error occurs.
*/
private Vector toStructureIrrigSummaryTSList (ResultSet rs, int sqlcode ) 
throws Exception {
	HydroBase_StructureIrrigSummaryTS data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date date;
	float f;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureIrrigSummaryTS();
		// irrig_summary_ts fields...
		if (sqlcode != __S_STRUCTURE_IRRIG_SUMMARY_TS_JOIN_DISTINCT 
		 && sqlcode !=__S_STRUCTURE_IRRIG_SUMMARY_TS_JOIN_DISTINCT_SP) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setCal_year(i);
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLand_use(s.trim());
		}
		if (sqlcode != __S_STRUCTURE_IRRIG_SUMMARY_TS_JOIN_DISTINCT
		 && sqlcode != __S_STRUCTURE_IRRIG_SUMMARY_TS_JOIN_DISTINCT_SP) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAcres_total(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAcres_by_drip(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAcres_by_flood(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAcres_by_furrow(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAcres_by_sprinkler(d);
			}
		}
		// Structure table fields...
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCiu(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDcr_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDcr_unit(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setEst_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setEst_unit(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		date = rs.getTimestamp(index++);
		if (!rs.wasNull()) {
			data.setModified(date);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSTRTYPE(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTransbsn(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setUser_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a view to HydroBase_StructureIrrigSummaryTS objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureView.
@throws Exception if an error occurs.
*/
private Vector toStructureIrrigSummaryTSSPList(ResultSet rs, boolean distinct)
throws Exception {
	HydroBase_StructureView data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	float f;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureView();

		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCiu(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStrtype(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setEst_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setEst_unit(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDcr_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDcr_unit(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTransbsn(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setXtia(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsns(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsns_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsew(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsew_dir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setElev(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAccuracy(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStream_num(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}
		if (version >= VERSION_20040701) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_rate_abs(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_rate_cond(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_rate_APEX_abs(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_rate_APEX_cond(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_vol_abs(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_vol_cond(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_vol_APEX_abs(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_vol_APEX_cond(d);
			}
		}
		if (!distinct) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setCal_year(i);
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLand_use(s.trim());
		}
		if (!distinct) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAcres_total(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAcres_by_drip(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAcres_by_flood(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAcres_by_furrow(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setAcres_by_sprinkler(d);
			}
			if (version >= VERSION_20040701) {
				d = rs.getDouble(index++);
				if (!rs.wasNull()) {
					data.setAcres_by_groundwater(d);
				}	
			}
		}

		v.add(data);
	}

	return v;
}

/**
Convert a ResultSet to a Vector of HydroBase_Structure
@param rs ResultSet from a Structure table query.
*/
private Vector toStructureList (ResultSet rs) throws Exception {
	HydroBase_Structure data = null;
 	Vector v = new Vector();
	int index = 1;
	int i;
	String s;
	float f;
	double dd;

	while (rs.next()) {
		data = new HydroBase_Structure();
		index = 1;
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCiu(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDcr_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDcr_unit(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setEst_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setEst_unit(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSTRTYPE(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTransbsn(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		dd = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setXtia(dd);
		}
		
		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_StructureMFReach objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureMFReach
@throws Exception if an error occurs.
*/
private Vector toStructureMFReachList (ResultSet rs) 
throws Exception {
	HydroBase_StructureMFReach data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	float f;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureMFReach();
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setMfr_rate(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setMfr_vol(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		if (version < VERSION_19990305) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setAquifer_num(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setStream_num(i);
			}
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		if (version < VERSION_19990305) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setStr_mile(d);
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCiu(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setEst_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setEst_unit(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDcr_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDcr_unit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSTRTYPE(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTransbsn(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure 
to HydroBase_StructureMFReach objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureMFReach
@throws Exception if an error occurs.
*/
private Vector toStructureMFReachSPList (ResultSet rs) 
throws Exception {
	HydroBase_StructureMFReach data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureMFReach();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setMfr_rate(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setMfr_vol(d);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StructureReservoir objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureReservoir
@throws Exception if an error occurs.
*/
private Vector toStructureReservoirList(ResultSet rs) 
throws Exception {
	HydroBase_StructureReservoir data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureReservoir();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		if (version < VERSION_19990305) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setAquifer_num(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setStream_num(i);
			}
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		if (version < VERSION_19990305) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setStr_mile(d);
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMax_storage(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setNormal_storage(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSurface_area(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDrain_area(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure 
to HydroBase_StructureReservoir objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureReservoir
@throws Exception if an error occurs.
*/
private Vector toStructureReservoirSPList (ResultSet rs) 
throws Exception {
	HydroBase_StructureReservoir data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureReservoir();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMax_storage(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setNormal_storage(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSurface_area(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDrain_area(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StructureSmallDam objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureSmallDam
@throws Exception if an error occurs.
*/
private Vector toStructureSmallDamList (ResultSet rs) 
throws Exception {
	HydroBase_StructureSmallDam data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;
	float f;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureSmallDam();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setReceipt(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSmall_dam_type(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAppl_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setCompl_date(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTitle_no(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setOutlet_size(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setOutlet_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setHeight(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSpillway_height(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSpillway_width(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDrain_area(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTank_capy(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		if (version < VERSION_19990305) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setAquifer_num(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setStream_num(i);
			}
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		if (version < VERSION_19990305) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setStr_mile(d);
			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCiu(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setEst_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setEst_unit(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDcr_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDcr_unit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSTRTYPE(s.trim());
		}
		if (version >= VERSION_19990305) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setTransbsn(i);
			}
		}
		else {
//			d = rs.getDouble(index++);
//			if (!rs.wasNull()) {
//				data.setXtia(d);
//			}
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure 
to HydroBase_StructureSmallDam objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureSmallDam
@throws Exception if an error occurs.
*/
private Vector toStructureSmallDamSPList (ResultSet rs) 
throws Exception {
	HydroBase_StructureSmallDam data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureSmallDam();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setReceipt(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSmall_dam_type(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAppl_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setCompl_date(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTitle_no(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setOutlet_size(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setOutlet_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setHeight(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSpillway_height(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSpillway_width(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDrain_area(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTank_capy(d);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StructureUnpermittedWells objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureUnpermittedWells
@throws Exception if an error occurs.
*/
private Vector toStructureUnpermittedWellsList (ResultSet rs) 
throws Exception {
	HydroBase_StructureUnpermittedWells data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureUnpermittedWells();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setApinumber(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setOiloper(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer2(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDepth(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setElev(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setComment(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUsgs_id(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLocal_well_num(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUsbr_id(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSp_coord_n(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSp_coord_e(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUsgs_net(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StructureView objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WISData
@throws Exception if an error occurs.
*/
public Vector toStructureSPList(ResultSet rs)
throws Exception {
	HydroBase_StructureView data = null;
	Vector v = new Vector();
	int index = 1;
	
	double d;
	float f;
	int i;
	String s;

	long version = getDatabaseVersion();
	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureView();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCiu(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStrtype(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setEst_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setEst_unit(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDcr_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDcr_unit(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTransbsn(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setXtia(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_type_desc(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsns(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsns_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsew(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsew_dir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setElev(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAccuracy(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStream_num(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSpotter_version(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStrno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStrname(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStrtribto(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRolodex_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFull_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAddress1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAddress2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCity(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setZip(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTia_gis(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTia_gis_calyear(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTia_div(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTia_div_calyear(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTia_struct(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTia_struct_calyear(i);
		}
		if (version >= VERSION_20040701) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_rate_abs(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_rate_cond(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_rate_APEX_abs(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_rate_APEX_cond(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_vol_abs(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_vol_cond(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_vol_APEX_abs(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_vol_APEX_cond(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_rate_total(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setDcr_vol_total(d);
			}
		}
	
		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_Structure objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Structure
@throws Exception if an error occurs.
*/
private Vector toStructureDistinctWDList (ResultSet rs) 
throws Exception {
	HydroBase_Structure data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Structure();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StructureGeoloc objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureGeoloc
@throws Exception if an error occurs.
*/
private Vector toStructureGeolocForWDIDList (ResultSet rs) 
throws Exception {
	HydroBase_StructureGeoloc data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	float f;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureGeoloc();

		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCiu(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSTRTYPE(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setEst_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setEst_unit(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDcr_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDcr_unit(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTransbsn(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsns(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsns_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsew(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsew_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		if (version >= VERSION_20010326) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setElev(d);
			}
		}
		else if (version >= VERSION_20000427) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setElevation(d);
			}
		}
		else {
			// older databases had elevation in station
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFeature_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAccuracy(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAquifer_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStream_num(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_description(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSpotter_version(s.trim());
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_StructureGeoloc objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureGeoloc
@throws Exception if an error occurs.
*/
private Vector toStructureGeolocList (ResultSet rs) 
throws Exception {
	HydroBase_StructureGeoloc data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	float f;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureGeoloc();

		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsns(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsew(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		if (version >= VERSION_20010326) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setElev(d);
			}
		}
		else if (version >= VERSION_20000301) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setElev(d);
			}			
		}
		else {
			//
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGeoloc_num(i);
		}
		if (version < VERSION_19990305) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setAquifer_num(i);
			}
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStream_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCiu(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setEst_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setEst_unit(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDcr_capacity(f);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDcr_unit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSTRTYPE(s.trim());
		}
		if (version < VERSION_19990305) {
//			d = rs.getDouble(index++);
//			if (!rs.wasNull()) {
//				data.setXtia(d);
//			}
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStrname(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFull_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRolodex_num(i);
		}
		if (version >= VERSION_19990305) {
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setUtm_x(d);
			}
			d = rs.getDouble(index++);
			if (!rs.wasNull()) {
				data.setUtm_y(d);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setCoordsns_dir(s.trim());
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setCoordsew_dir(s.trim());
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setFeature_type(s.trim());
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setAccuracy(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setTransbsn(i);
			}
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setSpotter_version(s.trim());
			}
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_Transact objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Transact
@throws Exception if an error occurs.
*/
private Vector toTransactList(ResultSet rs)
throws Exception {
	HydroBase_Transact data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Transact();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTrans_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTab_trib(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWr_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWr_stream_no(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWd_stream_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStrtype(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTS(s.trim());
		}
		if (!getDatabaseEngine().equalsIgnoreCase("Access")
		    && version >= VERSION_20040701) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setTdir(s.trim());
			}		
		}
		else if (getDatabaseEngine().equalsIgnoreCase("Access")
		    && version > VERSION_20040701) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setTdir(s.trim());
			}		
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRng(s.trim());
		}
		if (!getDatabaseEngine().equalsIgnoreCase("Access")
		    && version >= VERSION_20040701) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setRdir(s.trim());
			}		
		}
		else if (getDatabaseEngine().equalsIgnoreCase("Access")
		    && version > VERSION_20040701) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setRdir(s.trim());
			}		
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAdj_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setPadj_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setApro_date(dt);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAdmin_no(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setOrder_no(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAdj_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setRate_amt(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setVol_amt(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStatus_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTransfer_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAssoc_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAband(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAug_role(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPrior_no(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCase_no(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLast_due_dil(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAction_comment(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAction_update(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAssoc_wd(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAssoc_id(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPlan_wd(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPlan_id(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTran_wd(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTran_id(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRight_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWr_action_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_Transact objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Transact
@throws Exception if an error occurs.
*/
private Vector toTransactSPList(ResultSet rs) 
throws Exception {
	HydroBase_Transact data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Transact();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTrans_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTab_trib(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWr_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWr_stream_no(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWd_stream_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStrtype(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRng(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}				
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTS(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAdj_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setPadj_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setApro_date(dt);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAdmin_no(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setOrder_no(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAdj_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setRate_amt(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setVol_amt(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStatus_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTransfer_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAssoc_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAband(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAug_role(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPrior_no(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCase_no(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLast_due_dil(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAction_comment(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAction_update(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAssoc_wd(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAssoc_id(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPlan_wd(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPlan_id(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTran_wd(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTran_id(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRight_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWr_action_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_TSProduct objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_TSProduct
@throws Exception if an error occurs.
*/
private Vector toTSProductList(ResultSet rs) 
throws Exception {
	HydroBase_TSProduct data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_TSProduct();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTSProduct_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setProductGroup_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setIdentifier(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setName(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setComment(s.trim());
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_TSProduct objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_TSProduct
@throws Exception if an error occurs.
*/
private Vector toTSProductSPList(ResultSet rs) 
throws Exception {
	HydroBase_TSProduct data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_TSProduct();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTSProduct_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setProductGroup_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setIdentifier(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setName(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setComment(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setUser_num(i);
		}		

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_TSProductProps objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_TSProductProps
@throws Exception if an error occurs.
*/
private Vector toTSProductPropsList(ResultSet rs) 
throws Exception {
	HydroBase_TSProductProps data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_TSProductProps();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTSProduct_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setProperty(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSequence(i);
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setValue(s.trim());
		}

		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_StructureWDWater objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureWDWater
@throws Exception if an error occurs.
*/
private Vector toStructureWDWaterList (ResultSet rs) 
throws Exception {
	HydroBase_StructureWDWater data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureWDWater();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStrno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStrname(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAdmingrp(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStrtribto(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStrmile(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_StructureGeolocStructMeasTypeView objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_StructureGeolocStructMeasTypeView
@throws Exception if an error occurs.
*/
private Vector toGroundWaterWellMeasTypeList(ResultSet rs) 
throws Exception {
	HydroBase_GroundWaterWellsView data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	long version = getDatabaseVersion();

	if (version < VERSION_20050701) {
	while (rs.next()) {
		index = 1;
		data = new HydroBase_GroundWaterWellsView();

		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStart_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setEnd_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUsgs_id(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUsbr_id(s.trim());
		}
		v.add(data);
	}

	return v;
	}
	else {
	while (rs.next()) {
		index = 1;
		data = new HydroBase_GroundWaterWellsView();

		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWell_name(s.trim());
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setReceipt(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPermitno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitsuf(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitrpl(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLocnum(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSite_id(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setBasin(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMD(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_depth(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer_comment(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBperf(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setYield(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setBedrock_elev(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setSat_1965(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRemarks1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRemarks2(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_meas_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMeas_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTime_step(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStart_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setEnd_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_count(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setIdentifier(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setData_source(s.trim());
		}		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}				
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsns(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsns_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsew(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsew_dir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTopomap(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setElev(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setElev_accuracy(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setLoc_accuracy(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStream_num(i);
		}		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSpotter_version(s.trim());
		}		

		if (version >= VERSION_20051115) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer1(s.trim());
			}				
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer2(s.trim());
			}				
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDSS_aquifer_comment(s.trim());
			}				
		}		
		
		v.add(data);
	}

	return v;
	}
}

/**
Translate a ResultSet to HydroBase_Use objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Use
@throws Exception if an error occurs.
*/
private Vector toUseList (ResultSet rs) 
throws Exception {
	HydroBase_Use data = null;
	Vector v = new Vector();
	int index = 1;
	
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Use();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setXuse(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse_def(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setOk_for_wr(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRpt_code(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_UserPreferences objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_UserPreferences
@throws Exception if an error occurs.
*/
private Vector toUserPreferencesList (ResultSet rs) 
throws Exception {
	HydroBase_UserPreferences data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_UserPreferences();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setUser_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPreference(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPref_value(s.trim());
		}
		if (version < VERSION_19990305) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setApplication(s.trim());
			}
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_UserSecurity objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_UserSecurity
@throws Exception if an error occurs.
*/
private Vector toUserSecurityList (ResultSet rs) 
throws Exception {
	HydroBase_UserSecurity data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;		
		data = new HydroBase_UserSecurity();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setUser_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLogin(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPassword(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermissions(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUser_name(s.trim());
		}
		if (version >= VERSION_19990305) {
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setApplication(s.trim());
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setTeam_num(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setSupervisor(i);
			}
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WaterDistrict objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WaterDistrict
@throws Exception if an error occurs.
*/
private Vector toWaterDistrictList (ResultSet rs) 
throws Exception {
	HydroBase_WaterDistrict data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WaterDistrict();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWd_name(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WaterDivision objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WaterDivision
@throws Exception if an error occurs.
*/
private Vector toWaterDivisionList (ResultSet rs) 
throws Exception {
	HydroBase_WaterDivision data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WaterDivision();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDiv_name(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WDWater objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WDWater
@throws Exception if an error occurs.
*/
private Vector toWDWaterList (ResultSet rs) 
throws Exception {
	HydroBase_WDWater data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WDWater();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStrno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStrname(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAdmingrp(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStrtribto(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStrmile(d);
		}
	
		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_WDWater objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WDWater
@throws Exception if an error occurs.
*/
private Vector toWDWaterSPList(ResultSet rs) 
throws Exception {
	HydroBase_WDWater data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WDWater();

		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStrno(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStrname(s.trim());
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAdmingrp(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStrtribto(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStrmile(d);
		}
	
		v.add(data);
	}
	return v;
}

/**
Translate a ResultSet to HydroBase_WellApplicationView objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WellApplicationView
@throws Exception if an error occurs.
*/
private Vector toWellApplicationSPList (ResultSet rs) 
throws Exception {
	HydroBase_WellApplicationView data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WellApplicationView();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setReceipt(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCty(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPermitno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitsuf(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitrpl(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setActdate(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setActcode(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setBasin(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMD(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFull_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAddress1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAddress2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCity(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setZip(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPhone_number(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsns(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsns_dir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCoordsew(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCoordsew_dir(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_x(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setUtm_y(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLoc_source(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSubdiv_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setLot(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setBlock(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFiling(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setEngineer(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWell_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse3(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDriller_lic(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPump_lic(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setPidate(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStatute(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStatcode(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setStatdate(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setNpdate(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setWadate(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTrancode(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setTrandate(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setSadate(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setSbudate(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setExdate(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAbrdate(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAbcodate(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setAbreq(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAcreft(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBperf(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCase_no(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setYield(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDepth(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setLevel(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setElev(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setArea_irr(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setComment(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeter(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWellxno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWellxsuf(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWellxrpl(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setNwcdate(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setNbudate(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setWcdate(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setPcdate(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setLog(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setQual(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUser(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setPyield(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPdepth(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setPacreft(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWell_type(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setValid_permit(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setParcel_size(d);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setNoticedate(dt);
		}
		/*
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setGw_controller_num(i);
		}
		*/

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WellMeas objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WellMeas
@throws Exception if an error occurs.
*/
private Vector toWellMeasList (ResultSet rs) 
throws Exception {
	HydroBase_WellMeas data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WellMeas();
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setMeas_date(dt);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setWat_level(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WellMeas objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WellMeas
@throws Exception if an error occurs.
*/
private Vector toWellMeasSPList (ResultSet rs) 
throws Exception {
	HydroBase_WellMeas data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;

	if (getDatabaseVersion() < VERSION_20050701) {

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WellMeas();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}		
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setMeas_date(dt);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setWat_level(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPM(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTS(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setTsa(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setRng(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRdir(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRnga(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setSec(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSeca(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ160(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ40(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQ10(s.trim());
		}

		v.add(data);
	}
	}
	else {
	while (rs.next()) {
		index = 1;
		data = new HydroBase_WellMeas();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_meas_num(i);
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_num(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setMeas_date(dt);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setWl_depth(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setWl_elev(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setMeas_by(s.trim());
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setModified(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUser(s.trim());
		}


		v.add(data);
	}
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_Wells objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Wells
@throws Exception if an error occurs.
*/
private Vector toWellsList (ResultSet rs, int sqlNumber) 
throws Exception {
	HydroBase_Wells data = null;
	Vector v = new Vector();
	int index = 1;

	if (	sqlNumber != __S_WELLS &&
		sqlNumber != __S_WELLS_LAYER &&
		sqlNumber != __S_WELLS_PARCEL &&
		sqlNumber != __S_WELLS_STRUCTURE &&
		sqlNumber != __S_WELLS_PARCEL_STRUCTURE) {
		throw new Exception ("Invalid sqlNumber passed to "
			+ "'toWellsList': " + sqlNumber);
	}

	int i;
	String s;
	double d;
	float f;
	Date dt;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Wells();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_id(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setReceipt(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPermitno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitsuf(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitrpl(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWell_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setYield(f);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setPerm_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAppr_date(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDepth(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer1(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setFlag(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse3(s.trim());
		}

		if (sqlNumber == __S_WELLS_LAYER) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setLayer(i);
			}			
			f = rs.getFloat(index++);
			if (!rs.wasNull()) {
				data.setLayer_per(f);
			}			
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setEst_id(i);
			}			
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setDitches_served(i);
			}
		} 
		if (	sqlNumber == __S_WELLS_PARCEL || 
			sqlNumber == __S_WELLS_PARCEL_STRUCTURE) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setParcel(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setClass(i);
			}
			f = rs.getFloat(index++);
			if (!rs.wasNull()) {
				data.setDistance(f);
			}
			if (version >= VERSION_20000706) {
				f = rs.getFloat(index++);
				if (!rs.wasNull()) {
					data.setProrated_yield(f);
				}
				d = rs.getDouble(index++);
				if (!rs.wasNull()) {
					data.setPercent_yield(d);
				}
			}
			if (version >= VERSION_20040701) {
				i = rs.getInt(index++);
				if (!rs.wasNull()) {
					data.setDiv(i);
				}
				i = rs.getInt(index++);
				if (!rs.wasNull()) {
					data.setCal_year(i);
				}
				i = rs.getInt(index++);
				if (!rs.wasNull()) {
					data.setParcel_id(i);
				}
			}
		}	
		if (	sqlNumber == __S_WELLS_STRUCTURE || 
			sqlNumber == __S_WELLS_PARCEL_STRUCTURE) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setStructure_num(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setParcel(i);
			}
			f = rs.getFloat(index++);
			if (!rs.wasNull()) {
				data.setDitch_cov(f);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setStr_wd(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setStr_id(i);
			}
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setDitches_served(i);
			}			
			s = rs.getString(index++);
			if (!rs.wasNull()) {
				data.setDitch_id(s.trim());
			}			
			if (sqlNumber == __S_WELLS_STRUCTURE) {
				i = rs.getInt(index++);
				if (!rs.wasNull()) {
					data.setCal_year(i);
				}
				i = rs.getInt(index++);
				if (!rs.wasNull()) {
					data.setParcel_id(i);
				}
			}
		}
		if (sqlNumber == __S_WELLS) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setDitches_served(i);
			}
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_Wells objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Wells
@throws Exception if an error occurs.
*/
private Vector toWellsSPList(ResultSet rs)
throws Exception {
	HydroBase_Wells data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;
	float f;
	Date dt;
	int[] wdid = null;
	
	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Wells();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_id(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setReceipt(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPermitno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitsuf(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitrpl(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWell_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setYield(f);
		}
		if ( version >= VERSION_20070525 ) {
			f = rs.getFloat(index++);
			if (!rs.wasNull()) {
				data.setYield_apex(f);
			}
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setPerm_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAppr_date(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDepth(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer1(s.trim());
		}

		s = rs.getString(index++);
		if (!rs.wasNull()) {
			wdid = HydroBase_WaterDistrict.parseWDID(s);
			data.setWD(wdid[0]);
			data.setID(wdid[1]);
		}

		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setFlag(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse3(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDitches_served(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_Wells objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Wells
@throws Exception if an error occurs.
*/
private Vector toWellsWellToLayerSPList(ResultSet rs)
throws Exception {
	HydroBase_Wells data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;
	float f;
	Date dt;
	
	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Wells();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_id(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setReceipt(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPermitno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitsuf(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitrpl(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWell_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setYield(f);
		}
		if ( version >= VERSION_20070525 ) {
			f = rs.getFloat(index++);
			if (!rs.wasNull()) {
				data.setYield_apex(f);
			}
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setPerm_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAppr_date(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDepth(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer1(s.trim());
		}
		index++; // skip wd_id, already contained in "wd" and "id"
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setFlag(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse3(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDitches_served(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setLayer(i);
		}			
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setLayer_per(f);
		}			
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setEst_id(i);
		}			

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a result set to HydroBase_Wells objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Wells
@throws Exception if an error occurs.
*/
private Vector toWellsWellToParcelSPList(ResultSet rs)
throws Exception {
	HydroBase_Wells data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;
	double d;
	float f;
	Date dt;
	
	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Wells();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_id(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setReceipt(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPermitno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitsuf(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitrpl(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWell_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setYield(f);
		}
		if ( version >= VERSION_20070525 ) {
			f = rs.getFloat(index++);
			if (!rs.wasNull()) {
				data.setYield_apex(f);
			}
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setPerm_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAppr_date(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDepth(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer1(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setFlag(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse3(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setParcel(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setClass(i);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDistance(f);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setProrated_yield(f);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setPercent_yield(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}		
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setParcel_id(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_Wells objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Wells
@throws Exception if an error occurs.
*/
private Vector toWellsWellToParcelWellToStructureSPList(ResultSet rs)
throws Exception {
	HydroBase_Wells data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;
	double d;
	float f;
	Date dt;
	
	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Wells();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_id(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setReceipt(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPermitno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitsuf(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitrpl(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWell_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setYield(f);
		}
		if ( version >= VERSION_20070525 ) {
			f = rs.getFloat(index++);
			if (!rs.wasNull()) {
				data.setYield_apex(f);
			}
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setPerm_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAppr_date(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDepth(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer1(s.trim());
		}
		index++; 	// skip wd_id
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setFlag(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse3(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDitches_served(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setParcel(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setClass(i);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDistance(f);
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setProrated_yield(f);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setPercent_yield(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setParcel_id(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDitch_id(s.trim());
		}		
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDitch_cov(f);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStr_wd(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStr_id(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_Wells objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_Wells
@throws Exception if an error occurs.
*/
private Vector toWellsWellToStructureSPList(ResultSet rs)
throws Exception {
	HydroBase_Wells data = null;
	Vector v = new Vector();
	int index = 1;

	int i;
	String s;
	float f;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_Wells();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWell_id(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setReceipt(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setPermitno(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitsuf(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setPermitrpl(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWell_name(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setYield(f);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setPerm_date(dt);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setAppr_date(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setBperf(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDepth(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setAquifer1(s.trim());
		}
		index++;	// skip wdid
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setFlag(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse1(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse2(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUse3(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDitches_served(i);
		}

		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setParcel(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setDitch_id(s.trim());
		}
		f = rs.getFloat(index++);
		if (!rs.wasNull()) {
			data.setDitch_cov(f);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStr_wd(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStr_id(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setParcel_id(i);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WISComments objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WISComments
@throws Exception if an error occurs.
*/
private Vector toWISCommentsList (ResultSet rs) 
throws Exception {
	HydroBase_WISComments data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WISComments();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_num(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setSet_date(dt);
		}
		dt = rs.getTimestamp(index++);
		if (!rs.wasNull()) {
			data.setArchive_date(dt);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setComment(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WISDailyWC objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WISDailyWC
@throws Exception if an error occurs.
*/
private Vector toWISDailyWCList(ResultSet rs) 
throws Exception {
	HydroBase_WISDailyWC data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WISDailyWC();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQuality(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrr_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrr_mon(i);
		}
	
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWis_column(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_dailywc_num(i);
		}
		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt1(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs1(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt2(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs2(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt3(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs3(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt4(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs4(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt5(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs5(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt6(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs6(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt7(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs7(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt8(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs8(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt9(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs9(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt10(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs10(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt11(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs11(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt12(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs12(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt13(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs13(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt14(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs14(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt15(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs15(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt16(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs16(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt17(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs17(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt18(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs18(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt19(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs19(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt20(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs20(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt21(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs21(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt22(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs22(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt23(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs23(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt24(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs24(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt25(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs25(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt26(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs26(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt27(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs27(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt28(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs28(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt29(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs29(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt30(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs30(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt31(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs31(s.trim());
		}

		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFunc(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setS(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setF(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setU(s.trim());
		} 
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setT(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_WISDailyWC objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WISDailyWC
@throws Exception if an error occurs.
*/
private Vector toWISDailyWCSPList(ResultSet rs) 
throws Exception {
	HydroBase_WISDailyWC data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date date;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WISDailyWC();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_dailywc_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setQuality(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrr_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setIrr_mon(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_year(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setCal_mon(i);
		}
		
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt1(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs1(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt2(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs2(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt3(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs3(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt4(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs4(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt5(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs5(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt6(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs6(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt7(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs7(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt8(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs8(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt9(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs9(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt10(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs10(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt11(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs11(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt12(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs12(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt13(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs13(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt14(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs14(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt15(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs15(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt16(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs16(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt17(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs17(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt18(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs18(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt19(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs19(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt20(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs20(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt21(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs21(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt22(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs22(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt23(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs23(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt24(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs24(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt25(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs25(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt26(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs26(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt27(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs27(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt28(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs28(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt29(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs29(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt30(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs30(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setAmt31(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setObs31(s.trim());
		}

		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setUnit(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFunc(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setS(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setF(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setU(s.trim());
		} 
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setT(s.trim());
		}
		date = rs.getTimestamp(index++);
		if (!rs.wasNull()) {
			data.setModified(date);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setUser_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setWis_column(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WISData objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WISData
@throws Exception if an error occurs.
*/
private Vector toWISDataList (ResultSet rs) 
throws Exception {
	HydroBase_WISData data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;
	Date dt;

	long version = getDatabaseVersion();

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WISData();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_row(i);
		}
		dt = rs.getDate(index++);
		if (!rs.wasNull()) {
			data.setSet_date(dt);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setPoint_flow(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setNat_flow(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setDelivery_flow(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setGain(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTrib_natural(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setTrib_delivery(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setPriority_divr(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setDelivery_divr(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setRelease(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setComment(s.trim());
		}
		if (version >= VERSION_19990305) {
			i = rs.getInt(index++);
			if (!rs.wasNull()) {
				data.setDry_river(i);
			}
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WISFormat objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WISFormat
@throws Exception if an error occurs.
*/
private Vector toWISFormatList (ResultSet rs) 
throws Exception {
	HydroBase_WISFormat data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WISFormat();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_row(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRow_label(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRow_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setKnown_point(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_link(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setIdentifier(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setGain_factor(d);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure to HydroBase_WISFormat objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WISFormat
@throws Exception if an error occurs.
*/
private Vector toWISFormatSPList(ResultSet rs) 
throws Exception {
	HydroBase_WISFormat data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WISFormat();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_row(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRow_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setRow_label(s.trim());
		}		
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setKnown_point(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWdwater_link(i);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setStr_mile(d);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStation_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setIdentifier(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setGain_factor(d);
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WISFormula objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WISFormula
@throws Exception if an error occurs.
*/
private Vector toWISFormulaList (ResultSet rs) 
throws Exception {
	HydroBase_WISFormula data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WISFormula();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_row(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setColumn(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFormula(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setFormulastring(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WISImport objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WISImport
@throws Exception if an error occurs.
*/
private Vector toWISImportList (ResultSet rs) 
throws Exception {
	HydroBase_WISImport data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WISImport();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_row(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setColumn(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setEnd_time(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setTime_offset(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setMeas_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setImport_method(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setImport_wis_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setImport_identifier(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setImport_column(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setImport_meas_desc(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WISDiagramData objects.
@param rs ResultSet to translate.
@return a Vector of HydroBase_WISDiagramData
@throws Exception if an error occurs.
*/
private Vector toWISDiagramDataList(ResultSet rs) 
throws Exception {
	HydroBase_WISDiagramData data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WISDiagramData();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setID(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setType(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setProps(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet from a stored procedure
to HydroBase_WISSheetNameWISFormat objects.
@param rs ResultSet to translate.
@param type the kind of query that was executed
@return a Vector of HydroBase_WISSheetName
@throws Exception if an error occurs.
*/
private Vector toWISSheetNameWISFormatSPList (ResultSet rs) 
throws Exception {
	HydroBase_WISSheetNameWISFormat data = null;
	Vector v = new Vector();
	int index = 1;
	
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WISSheetNameWISFormat();
		// The following are for __S_WIS_SHEET_NAME_WIS_FORMAT_DISTINCT
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSheet_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setIdentifier(s.trim());
		}
		// For distinct, all other fields are missing.

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WISSheetName objects.
@param rs ResultSet to translate.
@param type the kind of query that was executed
@return a Vector of HydroBase_WISSheetName
@throws Exception if an error occurs.
*/
private Vector toWISSheetNameSPList (ResultSet rs) 
throws Exception {
	HydroBase_WISSheetName data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	Date dt;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WISSheetName();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWis_num(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSheet_name(s.trim());
		}
		dt = rs.getTimestamp(index++);
		if (!rs.wasNull()) {
			data.setEffective_date(dt);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setGain_method(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSheet_type(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setComments(s.trim());
		}

		v.add(data);
	}

	return v;
}

/**
Translate a ResultSet to HydroBase_WISSheetName objects.
@param rs ResultSet to translate.
@param type the kind of query that was executed
@return a Vector of HydroBase_WISSheetName
@throws Exception if an error occurs.
*/
private Vector toWISSheetNameDistinctSPList (ResultSet rs) 
throws Exception {
	HydroBase_WISSheetName data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_WISSheetName();
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setSheet_name(s.trim());
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}

		v.add(data);
	}

	return v;
}

// U METHODS

/**
Updates the archive date in calls for all records with the given call number.
@param archiveDate the date to update to.
@param callNum the number of the calls to update.
@return the number of updated records.
@throws Exception if an error occurs.
*/
public int updateCallsArchiveDateForCall_num(DateTime archiveDate, int callNum) 
throws Exception {
	DMIWriteStatement write = new DMIWriteStatement(this);
	if (canSetUpStoredProcedure(write, __W_CALLS_2)) {
		write.addValue(DMIUtil.formatDateTime(this, archiveDate,false));
		write.addValue(callNum);
		return dmiWrite(write, 0);
	}
	else {
		String dmiString = "UPDATE calls SET date_time_released = null,"
			+ "archive_date = " 
			+ DMIUtil.formatDateTime(this, archiveDate, true) + " "
			+ "where calls.call_num = " + callNum;
		return dmiWrite(dmiString);
	}
}

/**
Updates the archive date and release comments in calls for all records 
with the given call number.
@param archiveDate the date to update to.
@param callNum the number of the calls to update.
@return the number of updated records.
@throws Exception if an error occurs.
*/
public int updateCallsArchiveDateReleaseCommentsForCall_num(
DateTime archiveDate, int callNum) 
throws Exception {
	DMIWriteStatement write = new DMIWriteStatement(this);
	if (canSetUpStoredProcedure(write, __W_CALLS_3)) {
		write.addValue(DMIUtil.formatDateTime(this, archiveDate,false));
		write.addValue(callNum);
		return dmiWrite(write, 0);
	}
	else {
		String dmiString = "UPDATE calls SET date_time_released = null,"
			+ "archive_date = " 
			+ DMIUtil.formatDateTime(this, archiveDate, true)
			+ ", release_comments = NULL"
			+ " where calls.call_num = " + callNum;
		return dmiWrite(dmiString);	
	}
}

/**
Updates the set_comments, release_comments, and districts_affected fields
in Calls for the record with the given call_num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_EditCalls</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_Calls_Upd</li>
</ul>
@param call_num the call num of the record to update
@param set_comments the new set_comments value
@param release_comments the new release_comments value
@param districts_affected the new districts_affected value
@return the number of records updated
@throws Exception if an error occurs.
*/
public int updateCallsCommentsForCall_num(int call_num, String set_comments,
String release_comments, String districts_affected) 
throws Exception {
	DMIWriteStatement write = new DMIWriteStatement(this);
	if (canSetUpStoredProcedure(write, __W_CALLS)) {
		write.addValue(call_num);
		write.addValue(districts_affected);
		write.addValue(release_comments);
		write.addValue(set_comments);
		return dmiWrite(write, 0);
	}
	else {
		String sql = 
			"UPDATE calls "
			+ " SET calls.set_comments = '" + set_comments + "',"
			+ " calls.release_comments = '" + release_comments+ "',"
			+ " calls.districts_affected = '" 
				+ districts_affected + "'"
			+ " WHERE calls.call_num = " + call_num;
		boolean capitalize = getCapitalize();
		if (capitalize) {
			setCapitalize(false);
		}
		int num = dmiWrite(sql);
		setCapitalize(capitalize);
		return num;
	}
}

/**
Updates the archive date and deleted in calls for all records 
with the given call number.
@param deleted the deleted value to update to.
@param archiveDate the date to update to.
@param callNum the number of the calls to update.
@return the number of updated records.
@throws Exception if an error occurs.
*/
public int updateCallsDeletedArchiveDateForCall_num(String deleted,
DateTime archiveDate, int callNum) 
throws Exception {
	DMIWriteStatement write = new DMIWriteStatement(this);
	if (canSetUpStoredProcedure(write, __W_CALLS_4)) {
		write.addValue(
			DMIUtil.formatDateTime(this, archiveDate, false));
		write.addValue(deleted);
		write.addValue(callNum);
		return dmiWrite(write, 0);
	}
	else {		
		String dmiString = "UPDATE calls SET calls.deleted = "
			+ "'" + deleted + "', archive_date = " + archiveDate
			+ " WHERE calls.call_num = " + callNum;
		return dmiWrite(dmiString);
	}
}

/**
Updates the date time released, release comments, and archive date for calls
with the given call_num.
@param dateTimeReleased the date time released to update to.
@param releaseComments the comments to update to.
@param archiveDate the date to update to.
@param callNum the number of the calls to update.
@return the number of updated records.
@throws Exception if an error occurs.
*/
public int updateCallsDateTimeReleasedReleaseCommentsArchiveDateForCall_num(
DateTime dateTimeReleased, String releaseComments, DateTime archiveDate, 
int callNum) 
throws Exception {
	DMIWriteStatement write = new DMIWriteStatement(this);
	if (canSetUpStoredProcedure(write, __W_CALLS_5)) {
		write.addValue(
			DMIUtil.formatDateTime(this, archiveDate, false));
		write.addValue(releaseComments);
		write.addValue(
			DMIUtil.formatDateTime(this, dateTimeReleased, false));
		write.addValue(callNum);
		return dmiWrite(write, 0);
	}
	else {		
		String dmiString = "UPDATE calls SET date_time_released = " 
			+ DMIUtil.formatDateTime(this, dateTimeReleased) + ","
			+ " release_comments = '" + releaseComments + "',"
			+ " archive_date = " 
			+ DMIUtil.formatDateTime(this, archiveDate)
			+ " WHERE call_num = " + callNum;
		return dmiWrite(dmiString);
	}
}

/**
Updates the gain_method and effective_date in sheet_name for records with the
given wis_num.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WISBuilder.archiveData()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISSheetName_Upd</li>
</ul>
@param gain_method the gain_method to update to
@param effective_date the effective_date to update to
@param wis_num the wis_num of the records to update
@return the number of records updated
@throws Exception if an error occurs.
*/
public int updateSheet_nameGain_methodEffective_dateForWis_num(
String gain_method, DateTime effective_date, int wis_num) 
throws Exception {
	String table = "wis_sheet_name";
	if (getDatabaseVersion() <= VERSION_20040701) {
		table = "sheet_name";
	}

	DMIWriteStatement write = new DMIWriteStatement(this);
	if (canSetUpStoredProcedure(write, __W_WIS_SHEET_NAME_GAIN_METHOD)) {
		write.addValue(gain_method);
		write.addValue(
			DMIUtil.formatDateTime(this, effective_date, false));
		write.addWhereClause(table + ".wis_num = " + wis_num);
		return dmiWrite(write, 0);
	}
	else {
		String sql = "UPDATE " + table + " SET "
			+ table + ".gain_method = '" + gain_method 
			+ "', " + table + ".effective_date = " 
			+ DMIUtil.formatDateTime(this, effective_date)
			+ " WHERE " + table + ".wis_num = " + wis_num;
		return dmiWrite(sql);
	}
}

/**
Changes the identifier of a tsproduct.
@param id the new identifier for the tsproduct.
@param user_num the user_num of the product being changed.
@param identifier the original identifier of the product.
@return the number of records changed.
@throws Exception if an error occurred.
*/
public int updateTSProductIdentifierForUser_numIdentifier(String id, 
int user_num, String identifier) 
throws Exception {
	DMIWriteStatement write = new DMIWriteStatement(this);
	if (canSetUpStoredProcedure(write, __W_TSPRODUCT_2)) {
		write.addValue(identifier);
		write.addValue(id);
		write.addValue(user_num);
		return dmiWrite(write, 0);
	}
	else {		
		String dmiString = "UPDATE tsproduct SET identifier='" + id 
			+ "' where " + "user_num = " + user_num + " AND "
			+ "identifier = '" + identifier+ "'";
		return dmiWrite(dmiString);
	}
}

/**
Updates a user's password.
@param newPassword the new password to set.
@param login the login for which to update the password.
@param oldPassword the original password.
@param application the application for which to update.
@return the number of records updated.
@throws Exception if an error occurs.
*/
public int updateUserSecurityPasswordForLoginPasswordApplication(
String newPassword, String login, String oldPassword, String application) 
throws Exception {
	DMIWriteStatement write = new DMIWriteStatement(this);
	// Turn off printing of the Stored Procedure or SQL string to 
	// Debug 30, for the sake of security. 
	__printQueryStrings = false;
	if (canSetUpStoredProcedure(write, __W_USER_SECURITY)) {
		write.addValue(oldPassword);
		write.addValue(newPassword);
		write.addValue(login);
		write.addValue(application);
		int ret = dmiWrite(write, 0);
		// Turn back on printing of Stored Procedure or SQL strings to 
		// Debug 30.
		__printQueryStrings = true;
		return ret;
	}
	else {		
		String dmiString =
			"UPDATE user_security SET user_security.password = '"
			+ newPassword + "' WHERE user_security.login Like '"
			+ login + "' AND"
			+ " user_security.password Like '" + oldPassword + "'";
	
		if (application != null) {
			dmiString += 
				" AND user_security.application Like '" 
				+ application + "'";
		}
	
		int ret = dmiWrite(dmiString);
		// Turn back on printing of Stored Procedure or SQL strings to 
		// Debug 30.
		__printQueryStrings = true;
		return ret;
	}
}

/**
Returns whether stored procedures are being used.
@return whether stored procedures are being used.
*/
public boolean useStoredProcedures() {
	return __useSP;
}

// V METHODS
// W METHODS

/**
Writes calls data to the database.
@param call the call to write.
@return the number of records written.
@throws Exception if there is an error.
*/
public int writeCalls(HydroBase_Calls call) 
throws Exception {
	DMIWriteStatement write = new DMIWriteStatement(this);
	if (canSetUpStoredProcedure(write, __W_CALLS_6)) {
		write.addValue(call.getStructure_num());
		write.addValue(call.getNet_num());
		write.addValue(call.getWdwater_num());
		write.addValue(DMIUtil.formatDateTime(this,
			new DateTime(call.getDate_time_set()), false));
		write.addValue(call.getDeleted());
		write.addValue(call.getAdminno());
		write.addValue(call.getSet_comments());
		write.addValue(call.getDiv());
		write.addValue(call.getDistricts_affected());
		write.addValue(DMIUtil.formatDateTime(this,
			new DateTime(call.getArchive_date()), false));
		write.addValue(call.getStr_name());
		write.addValue(call.getWD());
		write.addValue(call.getID());
		write.addValue(call.getStrname());
		write.addValue(call.getStrtribto());
		write.addValue(call.getDcr_amt());
		write.addValue(DMIUtil.formatDateTime(this,
			new DateTime(call.getApro_date()), false));
		return dmiWrite(write, 0);
	}
	else {
		String dmiString = "INSERT INTO calls (";
		dmiString += "structure_num, net_num, wdwater_num, "
			+ "date_time_set, "
			+ " deleted, date_time_released, adminno, set_comments,"
			+ " release_comments, div, districts_affected, "
			+ "archive_date, "
			+ "str_name, wd, id, strname, strtribto, dcr_amt, "
			+ "apro_date)"
			+ " VALUES (";
		dmiString += 
			call.getStructure_num() + ", " 
			+ call.getNet_num()+ ", " 
			+ call.getWdwater_num()+ ", "
			+ DMIUtil.formatDateTime(this, 
				new DateTime(call.getDate_time_set())) + ", '"	
			+ call.getDeleted() + "', "
			+ "NULL, "
			+ call.getAdminno() + ", '" 
			+ call.getSet_comments() + "', " 
			+ "NULL, " 
			+ call.getDiv() + ",'" 
			+ call.getDistricts_affected() + "', "	
			+ DMIUtil.formatDateTime(this, 
				new DateTime(call.getArchive_date())) + ", '" 
			+ call.getStr_name() + "', " 
			+ call.getWD() + ", " 
			+ call.getID() + ", '" 
			+ call.getStrname() + "', " 
			+ call.getStrtribto() + ", '" 
			+ call.getDcr_amt() + "', " 
			+ DMIUtil.formatDateTime(this, 
				new DateTime(call.getApro_date())) + ")";
		return dmiWrite(dmiString);
	}
}

/**
Writes a single user preference to the database.<p>
This method is used by:<ul>
<li>HydroBaseDMI.saveUserPreferences</li>
</ul>
<p><b>Stored Procedures</b><p>
The stored procedures that correspond to these statements are:<ul>
<li>usp_CDSS_UserPreferences_Ins</li>
<li>usp_CDSS_UserPreferences_Upd</li>
</ul>
@param prefName the name of the preference to set
@param prefValue the value to set the preference to
@param userNum the number of the user setting the preference
@param programName the name of the program from which the preference is 
being set.
@param insert whether the preference to be written already exists in the 
database (and should be updated) or not (and thus should be inserted).
@throws Exception if an error occurs.
*/
public void writeUserPreference(String prefName, String prefValue, 
String userNum, String programName, boolean insert) 
throws Exception {
	String query = "";

	if (isDatabaseVersionAtLeast(VERSION_19990305)) {
		// No application field...
		DMIWriteStatement write = new DMIWriteStatement(this);
		if (insert) {
			if (canSetUpStoredProcedure(write, 
				__W_USER_PREFERENCES_INSERT)) {
				int user_num= (new Integer(userNum)).intValue();
				write.addValue(user_num);
				write.addValue(prefName.trim());
				write.addValue(prefValue.trim());
				dmiWrite(write, 0);
				return;
			}
			else {
				query = "INSERT INTO user_preferences ("
					+ "user_num, preference, pref_value) "
					+ "VALUES (" + userNum + ", '" 
					+ prefName + "', '" + prefValue + "')";
			}
		}
		else {
			if (canSetUpStoredProcedure(write, 
				__W_USER_PREFERENCES_UPDATE)) {
				int user_num= (new Integer(userNum)).intValue();
				write.addValue(user_num);
				write.addValue(prefName.trim());
				write.addValue(prefValue.trim());
				dmiWrite(write, 0);
				return;					
			}
			else {
				query = "UPDATE user_preferences SET "
					+ "user_preferences.pref_value = '" 
					+ prefValue.trim()
					+ "' where user_preferences.user_num = "
					+ userNum.trim() 
					+ " AND user_preferences.preference "
					+ "Like '" + prefName.trim()+ "'";
			}
		}
	}
	else {
		// Stored Procedures don't support older code
	
		// Older, assume that application is still in
		// the user_preferences table.
		if (insert) {
			query = "INSERT INTO user_preferences ("
				+ "user_num, preference, pref_value, "
				+ "application) VALUES ("
				+ userNum + ", '" + prefName + "', '"
				+ prefValue + "', '" + programName + "')";
		}
		else {
			query = "UPDATE user_preferences SET "
				+ "user_preferences.pref_value  = '" 
				+ prefValue.trim()
				+ "' where user_preferences.user_num = "
				+ userNum.trim() 
				+ " AND user_preferences.application "
				+ "Like '" + programName.trim()
				+ "' AND user_preferences.preference Like '" 
				+ prefName.trim()+ "'";
		}
	}
	dmiWrite(query);                      
}

/**
Writes a user preference object to the database.
@param up the object to write.
@return the number of records updated.
@throws Exception if an error occurs.
*/
public int writeUserPreferences(HydroBase_UserPreferences up) 
throws Exception {
	DMIWriteStatement write = new DMIWriteStatement(this);
	if (canSetUpStoredProcedure(write, __W_USER_PREFERENCES_INSERT)) {
		write.addValue(up.getUser_num());
		write.addValue(up.getPreference());
		write.addValue(up.getPref_value());
		return dmiWrite(write, 0);
	}
	else {
		String dmiString =
			"Insert INTO"
			+ " user_preferences "
			+ "(userNum,"
			+" preference,"
			+"pref_value)"
			+ " VALUES ("
			+ up.getUser_num() + ", '"
			+ up.getPreference()
			+ "', '"
			+ up.getPref_value()
			+ "')";
		return dmiWrite(dmiString);
	}
}


/**
Writes a new user security record.
@param us the data to write.
@return the number of records written.
@throws Exception if an error occurs.
*/
public int writeUserSecurity(HydroBase_UserSecurity us) 
throws Exception {
	DMIWriteStatement write = new DMIWriteStatement(this);
	// Turn off printing of the Stored Procedure or SQL string to 
	// Debug 30, for the sake of security. 
	__printQueryStrings = false;
	if (canSetUpStoredProcedure(write, __W_USER_SECURITY_2)) {
		write.addValue(us.getLogin());
		write.addValue(us.getPassword());
		write.addValue(us.getPermissions());
		write.addValue(us.getUser_name());
		write.addValue(us.getApplication());
		write.addValue(us.getTeam_num());
		write.addValue(us.getSupervisor());
		int ret = dmiWrite(write, 0);
		// Turn back on printing of Stored Procedure or SQL strings to 
		// Debug 30.
		__printQueryStrings = true;
		return ret;
	}
	else {
		String dmiString = "Insert INTO user_security ("
			+ " userNum,"
			+ " login,"
			+ " password,"
			+ " permissions,"
			+ " userName,"
			+ " application,"
			+ " team_num,"
			+ " supervisor) VALUES ("
			+ us.getUser_num() + ", '"
			+ us.getLogin() + "', '"
			+ us.getPassword() + "', '"
			+ us.getPermissions() + "', '"
			+ us.getUser_name() + "', '" + us.getApplication() +"',"
			+ us.getTeam_num() + ", "
			+ us.getSupervisor() + ")";
		int ret = dmiWrite(dmiString);
		// Turn back on printing of Stored Procedure or SQL strings to 
		// Debug 30.
		__printQueryStrings = true;
		return ret;
	}
}

/**
Writes a HydroBase_TSProduct record to the database.<p>
This is called by:<ul>
<li>HydroBaseDMI.writeTSProduct(TSProduct)</li>
</ul>
<p><b>Stored Procedures</b><p>
The stored procedures that correspond to these statements are:<ul>
<li>usp_CDSS_TSProduct_Ins</li>
<li>usp_CDSS_TSProduct_Upd</li>
</ul>
@param tsp the HydroBase_TSProduct to write.
@return -1 if the tsproduct already exists in the database, but if a new record
is being added, returns the number of the new record's TSProduct_num.
@throws Exception if an error occurs.
*/
public int writeTSProduct(HydroBase_TSProduct tsp) 
throws Exception {
	DMIWriteStatement w = new DMIWriteStatement(this);

	int action = 0;
	if (DMIUtil.isMissing(tsp.getTSProduct_num())) {
		action = __W_TSPRODUCT_INSERT;
	}
	else {
		action = __W_TSPRODUCT_UPDATE;
	}

	if (__useSP) {
		if (action == __W_TSPRODUCT_INSERT) {
			canSetUpStoredProcedure(w, __W_TSPRODUCT_INSERT);
			w.addValue(tsp.getProductGroup_num());
			w.addValue(tsp.getIdentifier());
			w.addValue(tsp.getName());
			w.addValue(tsp.getComment());
			w.addValue(tsp.getUser_num());
			dmiWrite(w, 0);
			return getMaxTSProductTSProduct_num();
		}
		else {
			canSetUpStoredProcedure(w, __W_TSPRODUCT_UPDATE);
			w.addValue(tsp.getTSProduct_num());
			w.addValue(tsp.getProductGroup_num());
			w.addValue(tsp.getIdentifier());
			w.addValue(tsp.getName());
			w.addValue(tsp.getComment());
			dmiWrite(w, 0);
			return -1;			
		}
	}
	else {
		buildSQL(w, action);
		w.addValue(tsp.getProductGroup_num());
		w.addValue(tsp.getIdentifier());
		w.addValue(tsp.getName());
		w.addValue(tsp.getComment());
	
		if (action == __W_TSPRODUCT_INSERT) {
			// need to create a new record
			dmiWrite(w, DMI.INSERT);
			return getMaxTSProductTSProduct_num();
		}
		else {
			// update an existing record
			w.addWhereClause("TSProduct.TSProduct_num = " 
				+ tsp.getTSProduct_num());
			dmiWrite(w, DMI.UPDATE);
			return -1;
		}
	}
}

/**
Writes a TSProduct to the database.  Writes records to both the
TSProduct and TSProductProps tables.  From the TSProductDMI interface.<p>
@param product the TSProduct to write to the table.
@return true if the TSProduct was written successfully, false if not.
*/
public boolean writeTSProduct(TSProduct product) {
	String routine = "HydroBaseDMI.writeTSProduct";
	
	// First, check to see if the TSProduct already exists in the database.

	String id = product.getPropValue("Product.ProductID");

	HydroBase_TSProduct tsp = null;
	if (__useSP) {
	try {
		tsp = readTSProductForIdentifier(id, getUserNum());
	}
	catch (Exception e) {
		Message.printWarning(1, routine, "Error reading records from "
			+ "database.");
		Message.printWarning(2, routine, e);
		return false;
	}

	// to keep track of whether a new TSProduct record will need to be
	// created ....
	boolean createNew = false;

	// if the tsp object read from the database above is null, then there
	// are no matching records in TSProduct for the user and the product id.
	if (tsp == null) {
		createNew = true;
	}
	
	// otherwise, check the ProductIDOriginal property in the product.  This
	// is a property only used internally and currently only set by the
	// HydroBase_GUI_SelectTSProduct screen when opening a TSProduct.  It
	// is never saved to persistent storage.

	// This property is the original TSProduct ID of a TSProduct when that
	// product was opened on the SelectTSProduct screen.  If the original
	// ID is not equal to the current ID, then the ID was changed in the
	// properties screen and the TSProduct must be saved to a new record.
	String orig = product.getPropValue("Product.ProductIDOriginal");
	if (orig == null) {
		orig = "";
	}
	else {
		orig = orig.trim();
	}

	if (!orig.equalsIgnoreCase(id)) {
		createNew = true;
	}

	int tsproduct_num = -1;
	if (!createNew) {
		tsp.setName(product.getPropValue("Product.ProductName"));
		tsproduct_num = tsp.getTSProduct_num();
		
		try {
			writeTSProduct(tsp);
		}
		catch (Exception e) {
			Message.printWarning(1, routine, 
				"Error writing to database.");
			Message.printWarning(2, routine, e);
			return false;
		}

		// for simplicity's sake, when re-writing an existing TSProduct
		// to the database, all its properties are simply wiped out
		// and rewritten. 

		try {
			deleteTSProductPropsForTSProduct_num(
				tsp.getTSProduct_num());
		}
		catch (Exception e) {
			Message.printWarning(1, routine, 
				"Error deleting records from database.");
			Message.printWarning(2, routine, e);
			return false;
		}
	}
	else {
		// if creating a new TSProduct for the specified ID and user_num
		// this first deletes any records belonging to that ID and 
		// user_num.  Easier than just overwriting them and hoping all
		// the records are caught.
		try {
			deleteTSProductForIdentifier(id, getUserNum());	
		}
		catch (Exception e) {
			Message.printWarning(1, routine, 
				"Error deleting records from database.");
			Message.printWarning(2, routine, e);
			return false;
		}
	
		// Writes a new TSProduct record into the database.
		tsp = new HydroBase_TSProduct();
		tsp.setName(product.getPropValue("Product.ProductName"));
		tsp.setIdentifier(id);
		tsp.setUser_num(getUserNum());
		int num = 0;
		try {
			num = writeTSProduct(tsp);
		}
		catch (Exception e) {
			Message.printWarning(1, routine, 
				"Error writing to database.");
			Message.printWarning(2, routine, e);
			return false;
		}
		tsproduct_num = num;	
		tsp.setTSProduct_num(num);
		try {
			num = writeTSProduct(tsp);
		}
		catch (Exception e) {
			Message.printWarning(1, routine, 
				"Error writing to database.");
			Message.printWarning(2, routine, e);
			return false;
		}
		
	}	
	
	// Now write all the properties from the TSProduct to the database.
	// returns all the properties, even the override properties, in one
	// single Vector.
	Vector v = product.getAllProps();

	int count = 0;		// used to keep track of the sequence number
				// of the property in the database
	int size = v.size();
	Prop p = null;
	HydroBase_TSProductProps tspp = null;
	try {
		// loop through and write almost all of them out.
		for (int i = 0; i < size; i++) {
			p = (Prop)v.elementAt(i);
			if (p.getHowSet() == Prop.SET_AS_RUNTIME_DEFAULT) {
				// do not store properties that are runtime
				// defaults.  They will be set automatically
				// next time at runtime.
			}
			else if (p.getValue().toUpperCase().endsWith(
				"PRODUCTIDORIGINAL")) {
				// This property is never stored.
			}
			else {
				tspp = new HydroBase_TSProductProps();
				tspp.setTSProduct_num(tsproduct_num);
				tspp.setSequence(count);
				tspp.setProperty(p.getKey());
				tspp.setValue(p.getValue());
				try {
					writeTSProductProps(tspp);
					count++;
				}
				catch (Exception e) {
					Message.printWarning(2, routine, 
						"Error writing to database.");
					Message.printWarning(2, routine, e);
				}
			}
		}
	}
	catch (Exception e) {
		Message.printWarning(1, routine, "Error writing to database.");
		Message.printWarning(2, routine, e);
		return false;
	}

	return true;
	}
	else {
	
	try {
		tsp = readTSProductForIdentifier(id, getUserNum());
	}
	catch (Exception e) {
		Message.printWarning(1, routine, "Error reading records from "
			+ "database.");
		Message.printWarning(2, routine, e);
		return false;
	}

	tsp.setName(product.getPropValue("Product.ProductName"));

	// to keep track of whether a new TSProduct record will need to be
	// created ....
	boolean createNew = false;

	// if the tsp object read from the database above is null, then there
	// are no matching records in TSProduct for the user and the product id.
	if (tsp == null) {
		createNew = true;
	}
	
	// otherwise, check the ProductIDOriginal property in the product.  This
	// is a property only used internally and currently only set by the
	// HydroBase_GUI_SelectTSProduct screen when opening a TSProduct.  It
	// is never saved to persistent storage.

	// This property is the original TSProduct ID of a TSProduct when that
	// product was opened on the SelectTSProduct screen.  If the original
	// ID is not equal to the current ID, then the ID was changed in the
	// properties screen and the TSProduct must be saved to a new record.
	String orig = product.getPropValue("Product.ProductIDOriginal");
	if (orig == null) {
		orig = "";
	}
	else {
		orig = orig.trim();
	}

	if (!orig.equalsIgnoreCase(id)) {
		createNew = true;
	}

	int tsproduct_num = -1;
	if (!createNew) {
		tsproduct_num = tsp.getTSProduct_num();
		tsp.setName(product.getPropValue("Product.ProductName"));
		
		// for simplicity's sake, when re-writing an existing TSProduct
		// to the database, all its properties are simply wiped out
		// and rewritten. 

		try {
			deleteTSProductPropsForTSProduct_num(
				tsp.getTSProduct_num());
		}
		catch (Exception e) {
			Message.printWarning(1, routine, 
				"Error deleting records from database.");
			Message.printWarning(2, routine, e);
			return false;
		}
	}
	else {
		// if creating a new TSProduct for the specified ID and user_num
		// this first deletes any records belonging to that ID and 
		// user_num.  Easier than just overwriting them and hoping all
		// the records are caught.
		try {
			deleteTSProductForIdentifier(id, getUserNum());	
		}
		catch (Exception e) {
			Message.printWarning(1, routine, 
				"Error deleting records from database.");
			Message.printWarning(2, routine, e);
			return false;
		}
	
		// Writes a new TSProduct record into the database.
		String sql = null;
		sql = "INSERT INTO TSProduct (Identifier, "
			+ "User_num, Name) VALUES ('" + id + "', " 
			+ getUserNum() + ", '" + 
			product.getPropValue("Product.ProductName") + "')";
		try {
			dmiWrite(sql);
		}
		catch (Exception e) {
			Message.printWarning(1, routine, 
				"Error writing to database.");
			Message.printWarning(2, routine, e);
			return false;
		}
	
		int num = getMaxTSProductTSProduct_num();

		// sets the ProductGroup_num to be the same as the tsproduct_num
		// of the record that was just written.
		sql = "UPDATE TSProduct SET TSProduct.ProductGroup_num = "
			+ num + " WHERE TSProduct.TSProduct_num = " + num 
			+ " AND TSProduct.Identifier = '" + id + "' AND "
			+ " TSProduct.User_num = " + getUserNum();

		try {
			dmiWrite(sql);
		}
		catch (Exception e) {
			Message.printWarning(1, routine, 
				"Error writing to database.");
			Message.printWarning(2, routine, e);
			return false;
		}
		tsproduct_num = num;
	}	
	
	// Now write all the properties from the TSProduct to the database.

	// returns all the properties, even the override properties, in one
	// single Vector.
	Vector v = product.getAllProps();

	int count = 0;		// used to keep track of the sequence number
				// of the property in the database
	int size = v.size();
	Prop p = null;
	String sql = null;
	try {
		// loop through and write almost all of them out.
		for (int i = 0; i < size; i++) {
			p = (Prop)v.elementAt(i);
			if (p.getHowSet() == Prop.SET_AS_RUNTIME_DEFAULT) {
				// do not store properties that are runtime
				// defaults.  They will be set automatically
				// next time at runtime.
			}
			else if (p.getValue().toUpperCase().endsWith(
				"PRODUCTIDORIGINAL")) {
				// This property is never stored.
			}
			else {
				sql = "INSERT INTO TSProductProps Values ("
					+ tsproduct_num + ", '" 
					+ p.getKey() + "', "
					+ count + ", '" + p.getValue() + "')";
				dmiWrite(sql);
				count++;
			}
		}
	}
	catch (Exception e) {
		Message.printWarning(1, routine, "Error writing to database.");
		Message.printWarning(2, routine, e);
		return false;
	}

	return true;
	}
}

/**
Writes a HydroBase_TSProductProps object to the database.<p>
@param tspp the HydroBase_TSProductProps object to write.
@throws Exception if an error occurs.
@deprecated because it's old
*/
public void writeTSProductProps(HydroBase_TSProductProps tspp) 
throws Exception {
	DMIWriteStatement w = new DMIWriteStatement(this);

	if (__useSP) {
		canSetUpStoredProcedure(w, __W_TSPRODUCTPROPS);
		w.addValue(tspp.getTSProduct_num());
		w.addValue(tspp.getSequence());
		w.addValue(tspp.getProperty());
		w.addValue(tspp.getValue());
		dmiWrite(w, 0);
	}
	else {	
		buildSQL(w, __W_TSPRODUCTPROPS);
	
		w.addValue(tspp.getTSProduct_num());
		w.addValue(tspp.getProperty());
		w.addValue(tspp.getValue());
		w.addValue(tspp.getSequence());
	
		w.addWhereClause("TSProductProps.TSProduct_num = " 
			+ tspp.getTSProduct_num());
		w.addWhereClause("TSProductProps.Property = '" 
			+ tspp.getProperty() + "'");
	
		dmiWrite(w, DMI.UPDATE_INSERT);
	}
}

/**
Writes a single wis_comments record to the database.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WIS</li>
<li>HydroBase_GUI_NewWIS</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISComments_Ins</li>
</ul>
@param wc the wis_comment object to write to the database.
@throws Exception if an error occurs
*/
public void writeWISComments(HydroBase_WISComments wc) 
throws Exception {
	DMIWriteStatement w = new DMIWriteStatement(this);

	if (__useSP) {
		canSetUpStoredProcedure(w, __W_WIS_COMMENTS);
		w.addValue(wc.getWis_num());
		w.addValue(wc.getSet_date(), DateTime.PRECISION_DAY);
		w.addValue(wc.getArchive_date(), DateTime.PRECISION_DAY);
		w.addValue(wc.getComment());
		dmiWrite(w, 0);
	}
	else {
		buildSQL(w, __W_WIS_COMMENTS);
		w.addValue(wc.getWis_num());
		w.addValue(wc.getSet_date(), DateTime.PRECISION_DAY);
		w.addValue(wc.getArchive_date(), DateTime.PRECISION_DAY);
		w.addValue(wc.getComment());
		dmiWrite(w, DMI.INSERT);
	}
}

/**
Writes a single wis_daily_wc record to the database.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WIS</li>
</ul>
<p><b>Stored Procedure</b><p>
<b>NOTE:</b> The stored procedure that is written for this method must be able
to perform either an update or an insert.  It must first check to see if the
record already exists in the database, and if so, execute the query.  Otherwise,
it should know to format everything in order to execute an update.<p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISDailyWC_Write</li>
</ul>
@param wc the wis_daily_wc object to write to the database.
@throws Exception if an error occurs.
*/
public void writeWISDailyWC(HydroBase_WISDailyWC wc) 
throws Exception {
	DMIWriteStatement w = new DMIWriteStatement(this);

	if (__useSP) {
		canSetUpStoredProcedure(w, __W_WIS_DAILY_WC);
		w.addValue(wc.getWis_dailywc_num());
		w.addValue(wc.getMeas_num());
		w.addValue(wc.getStructure_num());
		w.addValue(wc.getQuality());
		w.addValue(wc.getIrr_year());
		w.addValue(wc.getIrr_mon());		
		w.addValue(wc.getCal_year());
		w.addValue(wc.getCal_mon());
		for (int i = 1; i <= 31; i++) {
			w.addValue(wc.getAmountForDay(i));
			w.addValue(wc.getObservationForDay(i));
		}
		w.addValue(wc.getUnit());
		w.addValue(wc.getFunc());
		w.addValue(wc.getDiv());
		w.addValue(wc.getWD());
		w.addValue(wc.getID());
		w.addValue(wc.getS());
		w.addValue(wc.getF());
		w.addValue(wc.getU());
		w.addValue(wc.getT());
		w.addValue(wc.getModified());
		w.addValue(wc.getUser_num());
		w.addValue(wc.getWis_num());
		w.addValue(wc.getWis_column());
		dmiWrite(w, 0);
	}
	else {
		buildSQL(w, __W_WIS_DAILY_WC);
		w.addValue(wc.getMeas_num());
		w.addValue(wc.getStructure_num());
		w.addValue(wc.getQuality());
		w.addValue(wc.getCal_year());
		w.addValue(wc.getCal_mon());
		w.addValue(wc.getIrr_year());
		w.addValue(wc.getIrr_mon());
		w.addValue(wc.getWis_num());
		w.addValue(wc.getWis_column());
		w.addValue(wc.getWis_dailywc_num());
		for (int i = 1; i <= 31; i++) {
			w.addValue(wc.getAmountForDay(i));
			w.addValue(wc.getObservationForDay(i));
		}
		w.addValue(wc.getUnit());
		w.addValue(wc.getFunc());
		w.addValue(wc.getDiv());
		w.addValue(wc.getWD());
		w.addValue(wc.getID());
		w.addValue(wc.getS());
		w.addValue(wc.getF());
		w.addValue(wc.getU());
		w.addValue(wc.getT());
	
		// Where clauses will only be used if an UPDATE needs to be done
		w.addWhereClause("wis_daily_wc.wis_num = " + wc.getWis_num());
		w.addWhereClause("wis_daily_wc.wis_column = '" 
			+ wc.getWis_column() + "'");
		w.addWhereClause("wis_daily_wc.cal_year = " + wc.getCal_year());
		w.addWhereClause("wis_daily_wc.cal_mon = " + wc.getCal_mon());
		w.addWhereClause("wis_daily_wc.wd = " + wc.getWD());
		w.addWhereClause("wis_daily_wc.[id] = " + wc.getID());
		if (DMIUtil.isMissing(wc.getS())) {
			w.addWhereClause("wis_daily_wc.S = ''");
		}
		else {
			w.addWhereClause("wis_daily_wc.S = '" + wc.getS() 
				+ "'");
		}
		if (DMIUtil.isMissing(wc.getF())) {
			w.addWhereClause("wis_daily_wc.F = " 
				+ DMIUtil.MISSING_INT);
		}
		else {
			w.addWhereClause("wis_daily_wc.F = " + wc.getF());
		}
		if (DMIUtil.isMissing(wc.getU())) {
			w.addWhereClause("wis_daily_wc.U = ''");
		}
		else {
			w.addWhereClause("wis_daily_wc.U = '" + wc.getU() 
				+ "'");
		}
		if (DMIUtil.isMissing(wc.getT())) {
			w.addWhereClause("wis_daily_wc.T = ''");
		}
		else {
			w.addWhereClause("wis_daily_wc.T = '" + wc.getT() 
				+ "'");
		}
	
		dmiWrite(w, DMI.UPDATE_INSERT);
	}
}

/**
Writes a single wis_data record to the database.<p>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISData_Ins</li>
</ul>
@param wd the wis_data object to write to the database.
@throws Exception if an error occurs.
*/
public void writeWISData(HydroBase_WISData wd) 
throws Exception {
	DMIWriteStatement w = new DMIWriteStatement(this);

	if (__useSP) {
		canSetUpStoredProcedure(w, __W_WIS_DATA);

		w.addValue(wd.getWis_num());
		w.addValue(wd.getWis_row());
		w.addValue(wd.getSet_date());
		w.addValue(wd.getPoint_flow());
		w.addValue(wd.getNat_flow());
		w.addValue(wd.getDelivery_flow());
		w.addValue(wd.getGain());
		w.addValue(wd.getTrib_natural());
		w.addValue(wd.getTrib_delivery());
		w.addValue(wd.getPriority_divr());
		w.addValue(wd.getDelivery_divr());
		w.addValue(wd.getRelease());
		w.addValue(wd.getComment());
	
		if (getDatabaseVersion() >= VERSION_19990305) {
			w.addValue(wd.getDry_river());
		}
	
		dmiWrite(w, 0);		
	}
	else {
		buildSQL(w, __W_WIS_DATA);
	
		w.addValue(wd.getWis_num());
		w.addValue(wd.getWis_row());
		w.addValue(wd.getSet_date());
		w.addValue(wd.getPoint_flow());
		w.addValue(wd.getNat_flow());
		w.addValue(wd.getDelivery_flow());
		w.addValue(wd.getGain());
		w.addValue(wd.getTrib_natural());
		w.addValue(wd.getTrib_delivery());
		w.addValue(wd.getPriority_divr());
		w.addValue(wd.getDelivery_divr());
		w.addValue(wd.getRelease());
		w.addValue(wd.getComment());
	
		if (getDatabaseVersion() >= VERSION_19990305) {
			w.addValue(wd.getDry_river());
		}
	
		dmiWrite(w, DMI.INSERT);
	}
}

/**
Writes a single wis_diagram_data record to the database.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WISDiagramData.saveClicked()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISDiagramData_Ins</li>
</ul>
@param wnd the HydroBase_WISDiagramData object to write to the database.
@throws Exception if an error occurs.
*/
public void writeWISDiagramData(HydroBase_WISDiagramData wnd) 
throws Exception {
	DMIWriteStatement w = new DMIWriteStatement(this);

	if (__useSP) {
		canSetUpStoredProcedure(w, __W_WIS_DIAGRAM_DATA);
		w.addValue(wnd.getWis_num());
		w.addValue(wnd.getID());
		w.addValue(wnd.getType());
		w.addValue(wnd.getProps());
		dmiWrite(w, 0);		
	}
	else {
		buildSQL(w, __W_WIS_DIAGRAM_DATA);
		w.addValue(wnd.getWis_num());
		w.addValue(wnd.getID());
		w.addValue(wnd.getType());
		w.addValue(wnd.getProps());
		dmiWrite(w, DMI.INSERT);
	}
}

/**
Writes a single wis_format record to the database.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WISBuilder.archiveData()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISFormat_Ins</li></ul>
@param wf the wis_format object to write the database.
@throws Exception if an error occurs.
*/
public void writeWISFormat(HydroBase_WISFormat wf)
throws Exception {
	DMIWriteStatement w = new DMIWriteStatement(this);

	if (__useSP) {
		canSetUpStoredProcedure(w, __W_WIS_FORMAT);

		w.addValue(wf.getWis_num());
		w.addValue(wf.getWis_row());
		w.addValue(wf.getRow_label());
		w.addValue(wf.getRow_type());
		w.addValue(wf.getKnown_point());
		w.addValue(wf.getWdwater_num());
		w.addValue(wf.getWdwater_link());
		w.addValue(wf.getStr_mile());
		w.addValue(wf.getStructure_num());
		w.addValue(wf.getStation_num());
		w.addValue(wf.getIdentifier());
		w.addValue(wf.getGain_factor());
	
		dmiWrite(w, 0);
	}
	else {
		buildSQL(w, __W_WIS_FORMAT);
	
		w.addValue(wf.getWis_num());
		w.addValue(wf.getWis_row());
		w.addValue(wf.getRow_label());
		w.addValue(wf.getRow_type());
		w.addValue(wf.getKnown_point());
		w.addValue(wf.getWdwater_num());
		w.addValue(wf.getWdwater_link());
		w.addValue(wf.getStr_mile());
		w.addValue(wf.getStructure_num());
		w.addValue(wf.getStation_num());
		w.addValue(wf.getIdentifier());
		w.addValue(wf.getGain_factor());
	
		dmiWrite(w, DMI.INSERT);
	}
}

/**
Writes a single wis_formula record to the database.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WISBuilder.archiveData()</li>
<ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISFormula_Ins</li>
</ul>
@param wf the wis_formula object to write to the database.
@throws Exception if an error occurs.
*/
public void writeWISFormula(HydroBase_WISFormula wf) 
throws Exception {
	DMIWriteStatement w = new DMIWriteStatement(this);

	if (__useSP) {
		canSetUpStoredProcedure(w, __W_WIS_FORMULA);
		w.addValue(wf.getWis_num());
		w.addValue(wf.getWis_row());
		w.addValue(wf.getColumn());
		w.addValue(wf.getFormula());
		w.addValue(wf.getFormulastring());
		dmiWrite(w, 0);
	}
	else {
		buildSQL(w, __W_WIS_FORMULA);
		w.addValue(wf.getWis_num());
		w.addValue(wf.getWis_row());
		w.addValue(wf.getColumn());
		w.addValue(wf.getFormula());
		w.addValue(wf.getFormulastring());
		dmiWrite(w, DMI.INSERT);
	}
}

/**
Writes a single wis_import record to the database.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WISBuilder.archiveData()</li>
</ul>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this query is:<ul>
<li>usp_CDSS_WISImport_Ins</li>
</ul>
@param wi the wis_import object to write to the database.
@throws Exception if an error occurs.
*/
public void writeWISImport(HydroBase_WISImport wi)
throws Exception {
	DMIWriteStatement w = new DMIWriteStatement(this);

	if (__useSP) {
		canSetUpStoredProcedure(w, __W_WIS_IMPORT);
		w.addValue(wi.getWis_num());
		w.addValue(wi.getWis_row());
		w.addValue(wi.getColumn());
		w.addValue(wi.getEnd_time());
		w.addValue(wi.getTime_offset());
		w.addValue(wi.getMeas_num());
		w.addValue(wi.getImport_method());
		w.addValue(wi.getImport_wis_num());
		w.addValue(wi.getImport_identifier());
		w.addValue(wi.getImport_column());
		w.addValue(wi.getImport_meas_desc());
		dmiWrite(w, 0);
	}
	else {
		buildSQL(w, __W_WIS_IMPORT);
		w.addValue(wi.getWis_num());
		w.addValue(wi.getWis_row());
		w.addValue(wi.getColumn());
		w.addValue(wi.getEnd_time());
		w.addValue(wi.getTime_offset());
		w.addValue(wi.getMeas_num());
		w.addValue(wi.getImport_method());
		w.addValue(wi.getImport_wis_num());
		w.addValue(wi.getImport_identifier());
		w.addValue(wi.getImport_column());
		w.addValue(wi.getImport_meas_desc());
		dmiWrite(w, DMI.INSERT);
	}
}

/**
Writes a sheet_name object into the database.<p>
This method is used by:<ul>
<li>HydroBase_GUI_WISBuilder.getRecentFormatWISNum()</li>
<p><b>Stored Procedure</b><p>
The stored procedure that corresponds to this statement is:<ul>
<li>usp_CDSS_SheetName_Ins(varchar @sheet_name, date @effective_date,
int @wd, varchar @gain_method, varchar @comments)</li>
</ul>
@param sn the sheet_name object to write to the database.
@throws Exception if an error occurs.
*/
public void writeWISSheetName(HydroBase_WISSheetName sn) 
throws Exception {
	DMIWriteStatement w = new DMIWriteStatement(this);

	if (__useSP) {
		canSetUpStoredProcedure(w, __W_WIS_SHEET_NAME);
		w.addValue(sn.getSheet_name());
		DateTime dt = new DateTime(sn.getEffective_date());
		dt.setPrecision(DateTime.PRECISION_DAY);
		w.addValue(
			DMIUtil.formatDateTime(this, dt, false));
		w.addValue(sn.getWD());
		w.addValue(sn.getGain_method());
		w.addValue(sn.getComments());
		dmiWrite(w, 0);
	}
	else {
		buildSQL(w, __W_WIS_SHEET_NAME);
	
		w.addValue(sn.getSheet_name());
		w.addValue(sn.getEffective_date(), DateTime.PRECISION_DAY);
		w.addValue(sn.getWD());
		w.addValue(sn.getGain_method());
		w.addValue(sn.getSheet_type());
		w.addValue(sn.getComments());
		
		dmiWrite(w, DMI.INSERT);
	}
}

// X METHODS
// Y METHODS
// Z METHODS









////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
// JTS - 2005-02-25
// The following methods MUST be left in as they are necessary for backwards-
// compatability for StateDMI.  
// Remove in the future when the backwards compatability is no longer necessary.

protected final int _S_STATION_GEOLOC = 1641;

/**
@deprecated use readStationGeolocForStation_id().
*/
public Vector readStationGeolocListForStationIDs ( Vector stationid_Vector ) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, _S_STATION_GEOLOC);
	int size = 0;
	if (stationid_Vector != null) {
		size = stationid_Vector.size();
	}
	// Must put together one big AND clause...
	StringBuffer b = new StringBuffer();
	b.append("(");
	for ( int i = 0; i < size; i++) {
		if (i > 0) {
			b.append(" OR ");
		}
		b.append("(station.station_id = '" +
			stationid_Vector.elementAt(i) + "')");
	}
	b.append(")");
	q.addWhereClause(b.toString());
	ResultSet rs = dmiSelect(q);
	Vector v = toStationGeolocList(rs);
	closeResultSet(rs);
	return v;
}

/**
@deprecated use the other readParcelUseTSListForParcelList
*/
public Vector readParcelUseTSListForParcelList(Vector where_clauses,
Vector orderby_clauses, int div, int [] parcel_id, String land_use,
String irrig_type, DateTime req_date1, DateTime req_date2)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_PARCEL_USE_TS);

	if (where_clauses != null) {
		q.addWhereClauses(where_clauses);
	}
	if (orderby_clauses != null) {
		q.addOrderByClauses(orderby_clauses);
	}
	else {
		// Default order...
		q.addOrderByClause("parcel_use_ts.div");
		q.addOrderByClause("parcel_use_ts.parcel_id");
		q.addOrderByClause("parcel_use_ts.cal_year");
	}
	if (div > 0) {
		q.addWhereClause("parcel_use_ts.div = " + div);
	}
	if (parcel_id != null) {
		StringBuffer where = new StringBuffer();
		where.append("(");
		for ( int i = 0; i < parcel_id.length; i++) {
			if (i != 0) {
				where.append(" OR ");
			}
			where.append("(parcel_use_ts.parcel_id = " +
				parcel_id[i]+ ")");
		}
		where.append(")");
		q.addWhereClause(where.toString());
	}
	if ((land_use != null) && (land_use.length() > 0)) {
		q.addWhereClause("parcel_use_ts.land_use = '" +land_use+"'");
	}
	if (req_date1 != null) {
		q.addWhereClause("parcel_use_ts.cal_year >= " +
			req_date1.getYear());
	}
	if (req_date2 != null) {
		q.addWhereClause("parcel_use_ts.cal_year <= " + 
			req_date2.getYear());
	}

	ResultSet rs = dmiSelect(q);
	Vector v = toParcelUseTSList(rs, false);
	closeResultSet(rs);
	return v;
}

/**
@deprecated  use the other version:
readNetAmtsList(int structure_num, int wd, int id, boolean positiveNetRateAbs, 
Vector orderBys)
*/
public Vector readNetAmtsList(int wd, int id ) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_NET_AMTS_FOR_WD_ID);
	q.addWhereClause("net_amts.wd=" + wd);
	q.addWhereClause("net_amts.id=" + id);
	q.addOrderByClause("net_amts.admin_no");
	ResultSet rs = dmiSelect(q);
	Vector v = toNetAmtsList(rs);
	closeResultSet(rs);
	return v;
}

/**
@deprecated use readStructureReservoirForWDID().
*/
public Vector readStructureReservoirListForWDIDList(Vector ids) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_RESERVOIR);
	String wdid;
	boolean isWDID = false;
	Vector v;
	int structureCount = 0;
	String where = "";
	if (ids == null) {
		return new Vector();
	}
	for (int i = 0; i < ids.size(); i++) {
		wdid = (String)ids.elementAt(i);
		isWDID = true;
		int[] pwi = HydroBase_WaterDistrict.parseWDID(wdid);

		if (isWDID) {
			if (structureCount == 0) {
				where = "(structure.wd = " + pwi[0] + " AND " 
					+ "structure.id = " + pwi[1] + ")";
			}
			else {
				where = where + " OR "
					+ "(structure.wd = " + pwi[0] + " AND " 
					+ "structure.id = " + pwi[1] + ")";
			}
			structureCount++;
		}
	}
	q.addWhereClause(where);		
	
	ResultSet rs = dmiSelect(q);
	v = toStructureReservoirList(rs);
	closeResultSet(rs);
	return v;
}

/**
@deprecated use the other readParcelUseTSList():
readParcelUseTSList(int cal_year, int div, int parcel_id,
String land_use, String irrig_type, DateTime req_date1, DateTime req_date2)
*/
public Vector readParcelUseTSList(Vector where_clauses,
Vector orderby_clauses, int cal_year, int div, int parcel_id, String land_use,
String irrig_type, DateTime req_date1, DateTime req_date2)
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_PARCEL_USE_TS);

	if (where_clauses != null) {
		q.addWhereClauses(where_clauses);
	}
	if (orderby_clauses != null) {
		q.addOrderByClauses(orderby_clauses);
	}
	else {
		// Default order...
		q.addOrderByClause("parcel_use_ts.div");
		q.addOrderByClause("parcel_use_ts.parcel_id");
		q.addOrderByClause("parcel_use_ts.cal_year");
	}
	if (div > 0) {
		q.addWhereClause("parcel_use_ts.div = " + div);
	}
	if (cal_year > 0) {
		q.addWhereClause("parcel_use_ts.cal_year = " + cal_year);
	}
	if (parcel_id > 0) {
		q.addWhereClause("parcel_use_ts.parcel_id = " + parcel_id);
	}
	if ((land_use != null) && (land_use.length() > 0)) {
		q.addWhereClause("parcel_use_ts.land_use = '" +land_use+"'");
	}
	if (req_date1 != null) {
		q.addWhereClause("parcel_use_ts.cal_year >= " +
			req_date1.getYear());
	}
	if (req_date2 != null) {
		q.addWhereClause("parcel_use_ts.cal_year <= " + 
			req_date2.getYear());
	}

	ResultSet rs = dmiSelect(q);
	Vector v = toParcelUseTSList(rs, false);
	closeResultSet(rs);
	return v;
}

/**
@deprecated use one of the other versions, such as:
public Vector readStructureIrrigSummaryTSList(InputFilter_JPanel panel,
Vector orderby_clauses, int structure_num, int wd, int id, String str_name,
String land_use, DateTime req_date1, DateTime req_date2, boolean distinct ) 
*/
public Vector readStructureIrrigSummaryTSListForWDIDListLand_usePeriod (
					Vector wdidList, String landuse,
					DateTime req_date1, DateTime req_date2) 
throws Exception {
	DMISelectStatement q = new DMISelectStatement(this);
	buildSQL(q, __S_STRUCTURE_IRRIG_SUMMARY_TS_JOIN);

	int size = wdidList.size();
	StringBuffer where = new StringBuffer("");
	int [] pwdid = null;
	String wdid = null;
	int count = 0;
	for (int i = 0; i < size; i++) {
		wdid = (String)wdidList.elementAt(i);
		try {
			pwdid = HydroBase_WaterDistrict.parseWDID(wdid);
		}
		catch ( Exception e) {
			// Ignore the WDID...
			continue;
		}
		if (count > 0) {
			where.append(" OR ");
		}
		where.append ("(structure.wd = " + pwdid[0] + " AND "
			+ "structure.[id] = " + pwdid[1] + ")");
		count++;
	}

	q.addWhereClause(where.toString());
	if ((landuse != null) && (landuse.length() > 0)) {
		q.addWhereClause("irrig_summary_ts.land_use = '" +landuse+"'");
	}
	if (req_date1 != null) {
		q.addWhereClause("irrig_summary_ts.cal_year >= " +
			req_date1.getYear());
	}
	if (req_date2 != null) {
		q.addWhereClause("irrig_summary_ts.cal_year <= " + 
			req_date2.getYear());
	}
	q.addOrderByClause("structure.wd");
	q.addOrderByClause("structure.id");
	q.addOrderByClause("irrig_summary_ts.land_use");
	q.addOrderByClause("irrig_summary_ts.cal_year");

	ResultSet rs = dmiSelect(q);
	Vector v = toStructureIrrigSummaryTSList(rs, 
		__S_STRUCTURE_IRRIG_SUMMARY_TS_JOIN);
	closeResultSet(rs);
	return v;
}

// MAY NOT BE NECESSARY
// 2005-06-28
public int getMaxTSProductTSProduct_num() {
	DMISelectStatement q = new DMISelectStatement(this);
	try {
		if (canSetUpStoredProcedure(q, 
		    __S_TSPRODUCT_MAX_TSPRODUCT_NUM)) {
			ResultSet rs = dmiSelect(q);
			int i = 0;
			int max = -1;
			if (rs.next()) {
				i = rs.getInt(1);
				if (!rs.wasNull()) {
					max = i;
				}
			}
			closeResultSet(rs, __lastStatement);
			return max;
		}
		else {
			return DMIUtil.getMaxRecord(this, "TSProduct", 
				"TSProduct_num");			
		}
	}
	catch (Exception e) {
		Message.printWarning(2, "getMaxTSPRoductTSProduct_num", 
			e);
		return -1;
	}	
}

/**
This method is in place temporarily (a few months, no more) for  use in Access 
databases that query time series.  The normal structure view query has too many 
joins and is very inefficient in access.  This one pulls out the bare minimum of
data necessary.
REVISIT (JTS - 2005-06-30)
written on this date.  Probably should be gone by 2006-01-01
*/
public HydroBase_StructureView readStructureViewForWDIDForAccess(int wd, int id)
throws Exception {
	ResultSet rs = dmiSelect(
		"SELECT structure.structure_num, structure.div, structure.wd, "
		+ "structure.id, structure.str_name, geoloc.county, "
		+ "geoloc.elev, geoloc.huc, geoloc.st, geoloc.latdecdeg, "
		+ "geoloc.longdecdeg FROM structure, geoloc WHERE "
		+ "structure.geoloc_num = geoloc.geoloc_num "
		+ "AND structure.wd = " + wd 
		+ "AND structure.id = " + id);

	HydroBase_StructureView data = null;
	Vector v = new Vector();
	int index = 1;
	
	int i;
	String s;
	double d;

	while (rs.next()) {
		index = 1;
		data = new HydroBase_StructureView();
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setStructure_num(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setDiv(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setWD(i);
		}
		i = rs.getInt(index++);
		if (!rs.wasNull()) {
			data.setID(i);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setStr_name(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setCounty(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()){ 
			data.setElevation(d);
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setHUC(s.trim());
		}
		s = rs.getString(index++);
		if (!rs.wasNull()) {
			data.setST(s.trim());
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLatdecdeg(d);
		}
		d = rs.getDouble(index++);
		if (!rs.wasNull()) {
			data.setLongdecdeg(d);
		}

		v.add(data);
	}

	if (v.size() == 0) {
		return null;
	}
	else {
		return (HydroBase_StructureView)v.elementAt(0);
	}
}

}
